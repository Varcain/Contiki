
stm32f4discovery-tests.stm32f4discovery:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000091b4  08000188  08000188  00008188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init_array   00000004  0800933c  0800933c  0001133c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000004  08009340  08009340  00011340  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         00000880  20000000  08009344  00018000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00001718  20000880  08009bc4  00018880  2**2
                  ALLOC
  6 .ARM.attributes 00000037  00000000  00000000  00018880  2**0
                  CONTENTS, READONLY
  7 .comment      00000037  00000000  00000000  000188b7  2**0
                  CONTENTS, READONLY
  8 .debug_info   0000fb42  00000000  00000000  000188ee  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0000424d  00000000  00000000  00028430  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000059a0  00000000  00000000  0002c67d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 000011a8  00000000  00000000  00032020  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000df0  00000000  00000000  000331c8  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00006758  00000000  00000000  00033fb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00004667  00000000  00000000  0003a710  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  000031a0  00000000  00000000  0003ed78  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000188 <deregister_tm_clones>:
 8000188:	b508      	push	{r3, lr}
 800018a:	4805      	ldr	r0, [pc, #20]	; (80001a0 <deregister_tm_clones+0x18>)
 800018c:	4b05      	ldr	r3, [pc, #20]	; (80001a4 <deregister_tm_clones+0x1c>)
 800018e:	1a1b      	subs	r3, r3, r0
 8000190:	2b06      	cmp	r3, #6
 8000192:	d800      	bhi.n	8000196 <deregister_tm_clones+0xe>
 8000194:	bd08      	pop	{r3, pc}
 8000196:	4b04      	ldr	r3, [pc, #16]	; (80001a8 <deregister_tm_clones+0x20>)
 8000198:	2b00      	cmp	r3, #0
 800019a:	d0fb      	beq.n	8000194 <deregister_tm_clones+0xc>
 800019c:	4798      	blx	r3
 800019e:	e7f9      	b.n	8000194 <deregister_tm_clones+0xc>
 80001a0:	20000880 	.word	0x20000880
 80001a4:	20000883 	.word	0x20000883
 80001a8:	00000000 	.word	0x00000000

080001ac <register_tm_clones>:
 80001ac:	b508      	push	{r3, lr}
 80001ae:	4807      	ldr	r0, [pc, #28]	; (80001cc <register_tm_clones+0x20>)
 80001b0:	4b07      	ldr	r3, [pc, #28]	; (80001d0 <register_tm_clones+0x24>)
 80001b2:	1a1b      	subs	r3, r3, r0
 80001b4:	109b      	asrs	r3, r3, #2
 80001b6:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 80001ba:	1059      	asrs	r1, r3, #1
 80001bc:	d100      	bne.n	80001c0 <register_tm_clones+0x14>
 80001be:	bd08      	pop	{r3, pc}
 80001c0:	4a04      	ldr	r2, [pc, #16]	; (80001d4 <register_tm_clones+0x28>)
 80001c2:	2a00      	cmp	r2, #0
 80001c4:	d0fb      	beq.n	80001be <register_tm_clones+0x12>
 80001c6:	4790      	blx	r2
 80001c8:	e7f9      	b.n	80001be <register_tm_clones+0x12>
 80001ca:	bf00      	nop
 80001cc:	20000880 	.word	0x20000880
 80001d0:	20000880 	.word	0x20000880
 80001d4:	00000000 	.word	0x00000000

080001d8 <__do_global_dtors_aux>:
 80001d8:	b510      	push	{r4, lr}
 80001da:	4c06      	ldr	r4, [pc, #24]	; (80001f4 <__do_global_dtors_aux+0x1c>)
 80001dc:	7823      	ldrb	r3, [r4, #0]
 80001de:	b943      	cbnz	r3, 80001f2 <__do_global_dtors_aux+0x1a>
 80001e0:	f7ff ffd2 	bl	8000188 <deregister_tm_clones>
 80001e4:	4b04      	ldr	r3, [pc, #16]	; (80001f8 <__do_global_dtors_aux+0x20>)
 80001e6:	b113      	cbz	r3, 80001ee <__do_global_dtors_aux+0x16>
 80001e8:	4804      	ldr	r0, [pc, #16]	; (80001fc <__do_global_dtors_aux+0x24>)
 80001ea:	f3af 8000 	nop.w
 80001ee:	2301      	movs	r3, #1
 80001f0:	7023      	strb	r3, [r4, #0]
 80001f2:	bd10      	pop	{r4, pc}
 80001f4:	20000880 	.word	0x20000880
 80001f8:	00000000 	.word	0x00000000
 80001fc:	08009324 	.word	0x08009324

08000200 <frame_dummy>:
 8000200:	b508      	push	{r3, lr}
 8000202:	4b08      	ldr	r3, [pc, #32]	; (8000224 <frame_dummy+0x24>)
 8000204:	b11b      	cbz	r3, 800020e <frame_dummy+0xe>
 8000206:	4808      	ldr	r0, [pc, #32]	; (8000228 <frame_dummy+0x28>)
 8000208:	4908      	ldr	r1, [pc, #32]	; (800022c <frame_dummy+0x2c>)
 800020a:	f3af 8000 	nop.w
 800020e:	4808      	ldr	r0, [pc, #32]	; (8000230 <frame_dummy+0x30>)
 8000210:	6803      	ldr	r3, [r0, #0]
 8000212:	b113      	cbz	r3, 800021a <frame_dummy+0x1a>
 8000214:	4b07      	ldr	r3, [pc, #28]	; (8000234 <frame_dummy+0x34>)
 8000216:	b103      	cbz	r3, 800021a <frame_dummy+0x1a>
 8000218:	4798      	blx	r3
 800021a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800021e:	f7ff bfc5 	b.w	80001ac <register_tm_clones>
 8000222:	bf00      	nop
 8000224:	00000000 	.word	0x00000000
 8000228:	08009324 	.word	0x08009324
 800022c:	20000884 	.word	0x20000884
 8000230:	20000880 	.word	0x20000880
 8000234:	00000000 	.word	0x00000000

08000238 <__libc_init_array>:
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
 8000238:	b570      	push	{r4, r5, r6, lr}
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
 800023a:	4b0e      	ldr	r3, [pc, #56]	; (8000274 <__libc_init_array+0x3c>)
 800023c:	4d0e      	ldr	r5, [pc, #56]	; (8000278 <__libc_init_array+0x40>)
 800023e:	1aed      	subs	r5, r5, r3
 8000240:	10ad      	asrs	r5, r5, #2
  for (i = 0; i < count; i++)
 8000242:	2400      	movs	r4, #0
    __preinit_array_start[i] ();
 8000244:	461e      	mov	r6, r3
{
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
 8000246:	e003      	b.n	8000250 <__libc_init_array+0x18>
    __preinit_array_start[i] ();
 8000248:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
 800024c:	4790      	blx	r2
{
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
 800024e:	3401      	adds	r4, #1
 8000250:	42ac      	cmp	r4, r5
 8000252:	d1f9      	bne.n	8000248 <__libc_init_array+0x10>
    __preinit_array_start[i] ();

  _init ();
 8000254:	f009 f866 	bl	8009324 <_init>

  count = __init_array_end - __init_array_start;
 8000258:	4d08      	ldr	r5, [pc, #32]	; (800027c <__libc_init_array+0x44>)
 800025a:	4b09      	ldr	r3, [pc, #36]	; (8000280 <__libc_init_array+0x48>)
 800025c:	1aed      	subs	r5, r5, r3
 800025e:	10ad      	asrs	r5, r5, #2
  for (i = 0; i < count; i++)
 8000260:	2400      	movs	r4, #0
    __init_array_start[i] ();
 8000262:	461e      	mov	r6, r3
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
  for (i = 0; i < count; i++)
 8000264:	e003      	b.n	800026e <__libc_init_array+0x36>
    __init_array_start[i] ();
 8000266:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
 800026a:	4790      	blx	r2
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
  for (i = 0; i < count; i++)
 800026c:	3401      	adds	r4, #1
 800026e:	42ac      	cmp	r4, r5
 8000270:	d1f9      	bne.n	8000266 <__libc_init_array+0x2e>
    __init_array_start[i] ();
}
 8000272:	bd70      	pop	{r4, r5, r6, pc}
 8000274:	0800933c 	.word	0x0800933c
 8000278:	0800933c 	.word	0x0800933c
 800027c:	08009340 	.word	0x08009340
 8000280:	0800933c 	.word	0x0800933c

08000284 <memchr>:
	_CONST _PTR src_void _AND
	int c _AND
	size_t length)
{
  _CONST unsigned char *src = (_CONST unsigned char *) src_void;
  unsigned char d = c;
 8000284:	b2c9      	uxtb	r1, r1
#define NULL 0
#endif

_BEGIN_STD_C

_PTR 	 _EXFUN(memchr,(const _PTR, int, size_t));
 8000286:	1882      	adds	r2, r0, r2
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
 8000288:	e003      	b.n	8000292 <memchr+0xe>
    {
      if (*src == d)
 800028a:	7803      	ldrb	r3, [r0, #0]
 800028c:	428b      	cmp	r3, r1
 800028e:	d003      	beq.n	8000298 <memchr+0x14>
        return (void *) src;
      src++;
 8000290:	3001      	adds	r0, #1
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
 8000292:	4290      	cmp	r0, r2
 8000294:	d1f9      	bne.n	800028a <memchr+0x6>
      if (*src == d)
        return (void *) src;
      src++;
    }

  return NULL;
 8000296:	2000      	movs	r0, #0
}
 8000298:	4770      	bx	lr

0800029a <memcmp>:
int
_DEFUN (memcmp, (m1, m2, n),
	_CONST _PTR m1 _AND
	_CONST _PTR m2 _AND
	size_t n)
{
 800029a:	b530      	push	{r4, r5, lr}
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  unsigned char *s1 = (unsigned char *) m1;
  unsigned char *s2 = (unsigned char *) m2;

  while (n--)
 800029c:	2300      	movs	r3, #0
 800029e:	e008      	b.n	80002b2 <memcmp+0x18>
    {
      if (*s1 != *s2)
 80002a0:	5cc5      	ldrb	r5, [r0, r3]
 80002a2:	3301      	adds	r3, #1
int 	 _EXFUN(memcmp,(const _PTR, const _PTR, size_t));
 80002a4:	18cc      	adds	r4, r1, r3
 80002a6:	f814 4c01 	ldrb.w	r4, [r4, #-1]
 80002aa:	42a5      	cmp	r5, r4
 80002ac:	d001      	beq.n	80002b2 <memcmp+0x18>
	{
	  return *s1 - *s2;
 80002ae:	1b28      	subs	r0, r5, r4
 80002b0:	bd30      	pop	{r4, r5, pc}
{
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  unsigned char *s1 = (unsigned char *) m1;
  unsigned char *s2 = (unsigned char *) m2;

  while (n--)
 80002b2:	4293      	cmp	r3, r2
 80002b4:	d1f4      	bne.n	80002a0 <memcmp+0x6>
	  return *s1 - *s2;
	}
      s1++;
      s2++;
    }
  return 0;
 80002b6:	2000      	movs	r0, #0
      s2++;
    }

  return 0;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 80002b8:	bd30      	pop	{r4, r5, pc}

080002ba <memcpy>:
_PTR
_DEFUN (memcpy, (dst0, src0, len0),
	_PTR dst0 _AND
	_CONST _PTR src0 _AND
	size_t len0)
{
 80002ba:	b510      	push	{r4, lr}
  char *dst = (char *) dst0;
  char *src = (char *) src0;

  _PTR save = dst0;

  while (len0--)
 80002bc:	2300      	movs	r3, #0
 80002be:	e002      	b.n	80002c6 <memcpy+0xc>
    {
      *dst++ = *src++;
 80002c0:	5ccc      	ldrb	r4, [r1, r3]
 80002c2:	54c4      	strb	r4, [r0, r3]
 80002c4:	3301      	adds	r3, #1
  char *dst = (char *) dst0;
  char *src = (char *) src0;

  _PTR save = dst0;

  while (len0--)
 80002c6:	4293      	cmp	r3, r2
 80002c8:	d1fa      	bne.n	80002c0 <memcpy+0x6>
  while (len0--)
    *dst++ = *src++;

  return dst0;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 80002ca:	bd10      	pop	{r4, pc}

080002cc <memset>:
      s = (char*)aligned_addr;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
 80002cc:	2300      	movs	r3, #0
 80002ce:	e001      	b.n	80002d4 <memset+0x8>
    *s++ = (char) c;
 80002d0:	54c1      	strb	r1, [r0, r3]
 80002d2:	3301      	adds	r3, #1
      s = (char*)aligned_addr;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
 80002d4:	4293      	cmp	r3, r2
 80002d6:	d1fb      	bne.n	80002d0 <memset+0x4>
    *s++ = (char) c;

  return m;
}
 80002d8:	4770      	bx	lr
	...

080002dc <srand>:

void
_DEFUN (srand, (seed), unsigned int seed)
{
  _REENT_CHECK_RAND48(_REENT);
  _REENT_RAND_NEXT(_REENT) = seed;
 80002dc:	4b03      	ldr	r3, [pc, #12]	; (80002ec <srand+0x10>)
 80002de:	681b      	ldr	r3, [r3, #0]
 80002e0:	2200      	movs	r2, #0
 80002e2:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
 80002e6:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
 80002ea:	4770      	bx	lr
 80002ec:	20000008 	.word	0x20000008

080002f0 <rand>:
}

int
_DEFUN_VOID (rand)
{
 80002f0:	b510      	push	{r4, lr}
  /* This multiplier was obtained from Knuth, D.E., "The Art of
     Computer Programming," Vol 2, Seminumerical Algorithms, Third
     Edition, Addison-Wesley, 1998, p. 106 (line 26) & p. 108 */
  _REENT_CHECK_RAND48(_REENT);
  _REENT_RAND_NEXT(_REENT) = 
     _REENT_RAND_NEXT(_REENT) * __extension__ 6364136223846793005LL + 1;
 80002f2:	4b0b      	ldr	r3, [pc, #44]	; (8000320 <rand+0x30>)
 80002f4:	4c0b      	ldr	r4, [pc, #44]	; (8000324 <rand+0x34>)
 80002f6:	6819      	ldr	r1, [r3, #0]
 80002f8:	4b0b      	ldr	r3, [pc, #44]	; (8000328 <rand+0x38>)
 80002fa:	f8d1 20a8 	ldr.w	r2, [r1, #168]	; 0xa8
 80002fe:	f8d1 00ac 	ldr.w	r0, [r1, #172]	; 0xac
 8000302:	4354      	muls	r4, r2
 8000304:	fb03 4000 	mla	r0, r3, r0, r4
 8000308:	fba2 2303 	umull	r2, r3, r2, r3
 800030c:	3201      	adds	r2, #1
 800030e:	4403      	add	r3, r0
 8000310:	f143 0300 	adc.w	r3, r3, #0
{
  /* This multiplier was obtained from Knuth, D.E., "The Art of
     Computer Programming," Vol 2, Seminumerical Algorithms, Third
     Edition, Addison-Wesley, 1998, p. 106 (line 26) & p. 108 */
  _REENT_CHECK_RAND48(_REENT);
  _REENT_RAND_NEXT(_REENT) = 
 8000314:	e9c1 232a 	strd	r2, r3, [r1, #168]	; 0xa8
     _REENT_RAND_NEXT(_REENT) * __extension__ 6364136223846793005LL + 1;
  return (int)((_REENT_RAND_NEXT(_REENT) >> 32) & RAND_MAX);
}
 8000318:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
 800031c:	bd10      	pop	{r4, pc}
 800031e:	bf00      	nop
 8000320:	20000008 	.word	0x20000008
 8000324:	5851f42d 	.word	0x5851f42d
 8000328:	4c957f2d 	.word	0x4c957f2d

0800032c <strchr>:
_DEFUN (strchr, (s1, i),
	_CONST char *s1 _AND
	int i)
{
  _CONST unsigned char *s = (_CONST unsigned char *)s1;
  unsigned char c = i;
 800032c:	b2c9      	uxtb	r1, r1
 800032e:	4603      	mov	r3, r0

  s = (unsigned char *) aligned_addr;

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (*s && *s != c)
 8000330:	f810 2b01 	ldrb.w	r2, [r0], #1
 8000334:	b112      	cbz	r2, 800033c <strchr+0x10>
 8000336:	428a      	cmp	r2, r1
 8000338:	d1f9      	bne.n	800032e <strchr+0x2>
 800033a:	e002      	b.n	8000342 <strchr+0x16>
    s++;
  if (*s == c)
    return (char *)s;
  return NULL;
 800033c:	2900      	cmp	r1, #0
 800033e:	bf18      	it	ne
 8000340:	2300      	movne	r3, #0
}
 8000342:	4618      	mov	r0, r3
 8000344:	4770      	bx	lr

08000346 <strcmp>:
#endif

int 
__attribute__((naked)) strcmp (const char* s1, const char* s2)
{
  asm(
 8000346:	f810 2b01 	ldrb.w	r2, [r0], #1
 800034a:	f811 3b01 	ldrb.w	r3, [r1], #1
 800034e:	2a01      	cmp	r2, #1
 8000350:	bf28      	it	cs
 8000352:	429a      	cmpcs	r2, r3
 8000354:	d0f7      	beq.n	8000346 <strcmp>
 8000356:	eba2 0003 	sub.w	r0, r2, r3
 800035a:	4770      	bx	lr

0800035c <strlen>:
       "bne	1b"
       : "=&r" (len), "=&r" (scratch) : "r" (str) : "memory", "cc");
  return len - 1;
#else
  const char* end;
  asm ("1:\n\t"
 800035c:	4603      	mov	r3, r0
 800035e:	f813 2b01 	ldrb.w	r2, [r3], #1
 8000362:	2a00      	cmp	r2, #0
 8000364:	d1fb      	bne.n	800035e <strlen+0x2>
       "ldrb	%1, [%0], #1\n\t"
       "cmp	%1, #0\n\t"
       "bne	1b"
       : "=&r" (end), "=&r" (scratch) : "0" (str) : "memory", "cc");
  return end - str - 1;
 8000366:	1a18      	subs	r0, r3, r0
#endif
}
 8000368:	3801      	subs	r0, #1
 800036a:	4770      	bx	lr

0800036c <strncmp>:
int 
_DEFUN (strncmp, (s1, s2, n),
	_CONST char *s1 _AND
	_CONST char *s2 _AND
	size_t n)
{
 800036c:	b570      	push	{r4, r5, r6, lr}
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  if (n == 0)
 800036e:	b1aa      	cbz	r2, 800039c <strncmp+0x30>
 8000370:	e008      	b.n	8000384 <strncmp+0x18>
    return 0;

  while (n-- != 0 && *s1 == *s2)
    {
      if (n == 0 || *s1 == '\0')
 8000372:	2a01      	cmp	r2, #1
 8000374:	d103      	bne.n	800037e <strncmp+0x12>
	break;
      s1++;
      s2++;
    }

  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
 8000376:	7828      	ldrb	r0, [r5, #0]
 8000378:	781b      	ldrb	r3, [r3, #0]
 800037a:	1ac0      	subs	r0, r0, r3
 800037c:	bd70      	pop	{r4, r5, r6, pc}
 800037e:	3a01      	subs	r2, #1
  if (n == 0)
    return 0;

  while (n-- != 0 && *s1 == *s2)
    {
      if (n == 0 || *s1 == '\0')
 8000380:	2c00      	cmp	r4, #0
 8000382:	d0f8      	beq.n	8000376 <strncmp+0xa>
 8000384:	460b      	mov	r3, r1
 8000386:	4605      	mov	r5, r0
{
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  if (n == 0)
    return 0;

  while (n-- != 0 && *s1 == *s2)
 8000388:	2a00      	cmp	r2, #0
 800038a:	d0f4      	beq.n	8000376 <strncmp+0xa>
 800038c:	f810 6b01 	ldrb.w	r6, [r0], #1
 8000390:	781c      	ldrb	r4, [r3, #0]
 8000392:	42b4      	cmp	r4, r6
 8000394:	f101 0101 	add.w	r1, r1, #1
 8000398:	d0eb      	beq.n	8000372 <strncmp+0x6>
 800039a:	e7ec      	b.n	8000376 <strncmp+0xa>
	_CONST char *s2 _AND
	size_t n)
{
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  if (n == 0)
    return 0;
 800039c:	4610      	mov	r0, r2
      s1++;
      s2++;
    }
  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 800039e:	bd70      	pop	{r4, r5, r6, pc}

080003a0 <strncpy>:
char *
_DEFUN (strncpy, (dst0, src0),
	char *dst0 _AND
	_CONST char *src0 _AND
	size_t count)
{
 80003a0:	b530      	push	{r4, r5, lr}
size_t	 _EXFUN(strcspn,(const char *, const char *));
char 	*_EXFUN(strerror,(int));
size_t	 _EXFUN(strlen,(const char *));
char 	*_EXFUN(strncat,(char *, const char *, size_t));
int	 _EXFUN(strncmp,(const char *, const char *, size_t));
char 	*_EXFUN(strncpy,(char *, const char *, size_t));
 80003a2:	3901      	subs	r1, #1
 80003a4:	4603      	mov	r3, r0
  char *dscan;
  _CONST char *sscan;

  dscan = dst0;
  sscan = src0;
  while (count > 0)
 80003a6:	e009      	b.n	80003bc <strncpy+0x1c>
    {
      --count;
      if ((*dscan++ = *sscan++) == '\0')
 80003a8:	f811 5f01 	ldrb.w	r5, [r1, #1]!
 80003ac:	f803 5b01 	strb.w	r5, [r3], #1

  dscan = dst0;
  sscan = src0;
  while (count > 0)
    {
      --count;
 80003b0:	3a01      	subs	r2, #1
      if ((*dscan++ = *sscan++) == '\0')
 80003b2:	461c      	mov	r4, r3
 80003b4:	b915      	cbnz	r5, 80003bc <strncpy+0x1c>
 80003b6:	189b      	adds	r3, r3, r2
	break;
    }
  while (count-- > 0)
    *dscan++ = '\0';
 80003b8:	2200      	movs	r2, #0
 80003ba:	e005      	b.n	80003c8 <strncpy+0x28>
 80003bc:	461c      	mov	r4, r3
  char *dscan;
  _CONST char *sscan;

  dscan = dst0;
  sscan = src0;
  while (count > 0)
 80003be:	2a00      	cmp	r2, #0
 80003c0:	d1f2      	bne.n	80003a8 <strncpy+0x8>
 80003c2:	e7f8      	b.n	80003b6 <strncpy+0x16>
      --count;
      if ((*dscan++ = *sscan++) == '\0')
	break;
    }
  while (count-- > 0)
    *dscan++ = '\0';
 80003c4:	f804 2b01 	strb.w	r2, [r4], #1
    {
      --count;
      if ((*dscan++ = *sscan++) == '\0')
	break;
    }
  while (count-- > 0)
 80003c8:	429c      	cmp	r4, r3
 80003ca:	d1fb      	bne.n	80003c4 <strncpy+0x24>
  while (count-- > 0)
    *dst++ = '\0';

  return dst0;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 80003cc:	bd30      	pop	{r4, r5, pc}
	...

080003d0 <process_thread_shell_init_process>:
/*---------------------------------------------------------------------------*/
PROCESS(shell_init_process, "Shell init process");
AUTOSTART_PROCESSES(&telnetd_process, &shell_init_process);
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_init_process, ev, data)
{
 80003d0:	b580      	push	{r7, lr}
 80003d2:	b086      	sub	sp, #24
 80003d4:	af00      	add	r7, sp, #0
 80003d6:	60f8      	str	r0, [r7, #12]
 80003d8:	460b      	mov	r3, r1
 80003da:	607a      	str	r2, [r7, #4]
 80003dc:	72fb      	strb	r3, [r7, #11]
	PROCESS_BEGIN();
 80003de:	2301      	movs	r3, #1
 80003e0:	75fb      	strb	r3, [r7, #23]
 80003e2:	68fb      	ldr	r3, [r7, #12]
 80003e4:	881b      	ldrh	r3, [r3, #0]
 80003e6:	2b00      	cmp	r3, #0
 80003e8:	d10f      	bne.n	800040a <process_thread_shell_init_process+0x3a>
	shell_ps_init();
 80003ea:	f001 fa35 	bl	8001858 <shell_ps_init>
	shell_netstat_init();
 80003ee:	f002 fba9 	bl	8002b44 <shell_netstat_init>
	shell_memdebug_init();
 80003f2:	f002 fc99 	bl	8002d28 <shell_memdebug_init>
	shell_run_init();
 80003f6:	f002 f9c3 	bl	8002780 <shell_run_init>
	shell_text_init();
 80003fa:	f001 fdc9 	bl	8001f90 <shell_text_init>
	shell_time_init();
 80003fe:	f002 f95d 	bl	80026bc <shell_time_init>
	shell_ping_init();
 8000402:	f002 fb03 	bl	8002a0c <shell_ping_init>
	shell_blink_init();
 8000406:	f001 fb4d 	bl	8001aa4 <shell_blink_init>

	PROCESS_END();
 800040a:	2300      	movs	r3, #0
 800040c:	75fb      	strb	r3, [r7, #23]
 800040e:	68fb      	ldr	r3, [r7, #12]
 8000410:	2200      	movs	r2, #0
 8000412:	801a      	strh	r2, [r3, #0]
 8000414:	2303      	movs	r3, #3
}
 8000416:	4618      	mov	r0, r3
 8000418:	f107 0718 	add.w	r7, r7, #24
 800041c:	46bd      	mov	sp, r7
 800041e:	bd80      	pop	{r7, pc}

08000420 <buf_init>:

#define MIN(a, b) ((a) < (b)? (a): (b))
/*---------------------------------------------------------------------------*/
static void
buf_init(struct telnetd_buf *buf)
{
 8000420:	b480      	push	{r7}
 8000422:	b083      	sub	sp, #12
 8000424:	af00      	add	r7, sp, #0
 8000426:	6078      	str	r0, [r7, #4]
  buf->ptr = 0;
 8000428:	687b      	ldr	r3, [r7, #4]
 800042a:	2200      	movs	r2, #0
 800042c:	f8c3 27d0 	str.w	r2, [r3, #2000]	; 0x7d0
  buf->size = TELNETD_CONF_NUMLINES * TELNETD_CONF_LINELEN;
 8000430:	687b      	ldr	r3, [r7, #4]
 8000432:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8000436:	f8c3 27d4 	str.w	r2, [r3, #2004]	; 0x7d4
}
 800043a:	f107 070c 	add.w	r7, r7, #12
 800043e:	46bd      	mov	sp, r7
 8000440:	bc80      	pop	{r7}
 8000442:	4770      	bx	lr

08000444 <buf_append>:
/*---------------------------------------------------------------------------*/
static int
buf_append(struct telnetd_buf *buf, const char *data, int len)
{
 8000444:	b580      	push	{r7, lr}
 8000446:	b086      	sub	sp, #24
 8000448:	af00      	add	r7, sp, #0
 800044a:	60f8      	str	r0, [r7, #12]
 800044c:	60b9      	str	r1, [r7, #8]
 800044e:	607a      	str	r2, [r7, #4]
  int copylen;

  PRINTF("buf_append len %d (%d) '%.*s'\n", len, buf->ptr, len, data);
  copylen = MIN(len, buf->size - buf->ptr);
 8000450:	68fb      	ldr	r3, [r7, #12]
 8000452:	f8d3 27d4 	ldr.w	r2, [r3, #2004]	; 0x7d4
 8000456:	68fb      	ldr	r3, [r7, #12]
 8000458:	f8d3 37d0 	ldr.w	r3, [r3, #2000]	; 0x7d0
 800045c:	1ad2      	subs	r2, r2, r3
 800045e:	687b      	ldr	r3, [r7, #4]
 8000460:	429a      	cmp	r2, r3
 8000462:	bfb8      	it	lt
 8000464:	4613      	movlt	r3, r2
 8000466:	617b      	str	r3, [r7, #20]
  memcpy(&buf->bufmem[buf->ptr], data, copylen);
 8000468:	68fb      	ldr	r3, [r7, #12]
 800046a:	f8d3 37d0 	ldr.w	r3, [r3, #2000]	; 0x7d0
 800046e:	68fa      	ldr	r2, [r7, #12]
 8000470:	18d2      	adds	r2, r2, r3
 8000472:	697b      	ldr	r3, [r7, #20]
 8000474:	4610      	mov	r0, r2
 8000476:	68b9      	ldr	r1, [r7, #8]
 8000478:	461a      	mov	r2, r3
 800047a:	f7ff ff1e 	bl	80002ba <memcpy>
  petsciiconv_toascii(&buf->bufmem[buf->ptr], copylen);
  buf->ptr += copylen;
 800047e:	68fb      	ldr	r3, [r7, #12]
 8000480:	f8d3 27d0 	ldr.w	r2, [r3, #2000]	; 0x7d0
 8000484:	697b      	ldr	r3, [r7, #20]
 8000486:	18d2      	adds	r2, r2, r3
 8000488:	68fb      	ldr	r3, [r7, #12]
 800048a:	f8c3 27d0 	str.w	r2, [r3, #2000]	; 0x7d0

  return copylen;
 800048e:	697b      	ldr	r3, [r7, #20]
}
 8000490:	4618      	mov	r0, r3
 8000492:	f107 0718 	add.w	r7, r7, #24
 8000496:	46bd      	mov	sp, r7
 8000498:	bd80      	pop	{r7, pc}
 800049a:	bf00      	nop

0800049c <buf_copyto>:
/*---------------------------------------------------------------------------*/
static void
buf_copyto(struct telnetd_buf *buf, char *to, int len)
{
 800049c:	b580      	push	{r7, lr}
 800049e:	b084      	sub	sp, #16
 80004a0:	af00      	add	r7, sp, #0
 80004a2:	60f8      	str	r0, [r7, #12]
 80004a4:	60b9      	str	r1, [r7, #8]
 80004a6:	607a      	str	r2, [r7, #4]
  memcpy(to, &buf->bufmem[0], len);
 80004a8:	68fa      	ldr	r2, [r7, #12]
 80004aa:	687b      	ldr	r3, [r7, #4]
 80004ac:	68b8      	ldr	r0, [r7, #8]
 80004ae:	4611      	mov	r1, r2
 80004b0:	461a      	mov	r2, r3
 80004b2:	f7ff ff02 	bl	80002ba <memcpy>
}
 80004b6:	f107 0710 	add.w	r7, r7, #16
 80004ba:	46bd      	mov	sp, r7
 80004bc:	bd80      	pop	{r7, pc}
 80004be:	bf00      	nop

080004c0 <buf_pop>:
/*---------------------------------------------------------------------------*/
static void
buf_pop(struct telnetd_buf *buf, int len)
{
 80004c0:	b580      	push	{r7, lr}
 80004c2:	b084      	sub	sp, #16
 80004c4:	af00      	add	r7, sp, #0
 80004c6:	6078      	str	r0, [r7, #4]
 80004c8:	6039      	str	r1, [r7, #0]
  int poplen;

  PRINTF("buf_pop len %d (%d)\n", len, buf->ptr);
  poplen = MIN(len, buf->ptr);
 80004ca:	687b      	ldr	r3, [r7, #4]
 80004cc:	f8d3 27d0 	ldr.w	r2, [r3, #2000]	; 0x7d0
 80004d0:	683b      	ldr	r3, [r7, #0]
 80004d2:	429a      	cmp	r2, r3
 80004d4:	bfb8      	it	lt
 80004d6:	4613      	movlt	r3, r2
 80004d8:	60fb      	str	r3, [r7, #12]
  memcpy(&buf->bufmem[0], &buf->bufmem[poplen], buf->ptr - poplen);
 80004da:	6879      	ldr	r1, [r7, #4]
 80004dc:	687a      	ldr	r2, [r7, #4]
 80004de:	68fb      	ldr	r3, [r7, #12]
 80004e0:	18d2      	adds	r2, r2, r3
 80004e2:	687b      	ldr	r3, [r7, #4]
 80004e4:	f8d3 07d0 	ldr.w	r0, [r3, #2000]	; 0x7d0
 80004e8:	68fb      	ldr	r3, [r7, #12]
 80004ea:	1ac3      	subs	r3, r0, r3
 80004ec:	4608      	mov	r0, r1
 80004ee:	4611      	mov	r1, r2
 80004f0:	461a      	mov	r2, r3
 80004f2:	f7ff fee2 	bl	80002ba <memcpy>
  buf->ptr -= poplen;
 80004f6:	687b      	ldr	r3, [r7, #4]
 80004f8:	f8d3 27d0 	ldr.w	r2, [r3, #2000]	; 0x7d0
 80004fc:	68fb      	ldr	r3, [r7, #12]
 80004fe:	1ad2      	subs	r2, r2, r3
 8000500:	687b      	ldr	r3, [r7, #4]
 8000502:	f8c3 27d0 	str.w	r2, [r3, #2000]	; 0x7d0
}
 8000506:	f107 0710 	add.w	r7, r7, #16
 800050a:	46bd      	mov	sp, r7
 800050c:	bd80      	pop	{r7, pc}
 800050e:	bf00      	nop

08000510 <buf_len>:
/*---------------------------------------------------------------------------*/
static int
buf_len(struct telnetd_buf *buf)
{
 8000510:	b480      	push	{r7}
 8000512:	b083      	sub	sp, #12
 8000514:	af00      	add	r7, sp, #0
 8000516:	6078      	str	r0, [r7, #4]
  return buf->ptr;
 8000518:	687b      	ldr	r3, [r7, #4]
 800051a:	f8d3 37d0 	ldr.w	r3, [r3, #2000]	; 0x7d0
}
 800051e:	4618      	mov	r0, r3
 8000520:	f107 070c 	add.w	r7, r7, #12
 8000524:	46bd      	mov	sp, r7
 8000526:	bc80      	pop	{r7}
 8000528:	4770      	bx	lr
 800052a:	bf00      	nop

0800052c <telnetd_quit>:
/*---------------------------------------------------------------------------*/
void
telnetd_quit(void)
{
 800052c:	b580      	push	{r7, lr}
 800052e:	af00      	add	r7, sp, #0
  shell_quit();
 8000530:	f001 f934 	bl	800179c <shell_quit>
#if TELNETD_CONF_GUI
  telnetd_gui_quit();
#endif /* TELNETD_CONF_GUI */
  process_exit(&telnetd_process);
 8000534:	f240 4048 	movw	r0, #1096	; 0x448
 8000538:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800053c:	f003 fcf6 	bl	8003f2c <process_exit>
  LOADER_UNLOAD();
}
 8000540:	bd80      	pop	{r7, pc}
 8000542:	bf00      	nop

08000544 <shell_prompt>:
/*---------------------------------------------------------------------------*/
void
shell_prompt(char *str)
{
 8000544:	b580      	push	{r7, lr}
 8000546:	b082      	sub	sp, #8
 8000548:	af00      	add	r7, sp, #0
 800054a:	6078      	str	r0, [r7, #4]
  buf_append(&buf, str, (int)strlen(str));
 800054c:	6878      	ldr	r0, [r7, #4]
 800054e:	f7ff ff05 	bl	800035c <strlen>
 8000552:	4603      	mov	r3, r0
 8000554:	f640 00f4 	movw	r0, #2292	; 0x8f4
 8000558:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800055c:	6879      	ldr	r1, [r7, #4]
 800055e:	461a      	mov	r2, r3
 8000560:	f7ff ff70 	bl	8000444 <buf_append>
}
 8000564:	f107 0708 	add.w	r7, r7, #8
 8000568:	46bd      	mov	sp, r7
 800056a:	bd80      	pop	{r7, pc}

0800056c <shell_default_output>:
/*---------------------------------------------------------------------------*/
void
shell_default_output(const char *str1, int len1, const char *str2, int len2)
{
 800056c:	b580      	push	{r7, lr}
 800056e:	b084      	sub	sp, #16
 8000570:	af00      	add	r7, sp, #0
 8000572:	60f8      	str	r0, [r7, #12]
 8000574:	60b9      	str	r1, [r7, #8]
 8000576:	607a      	str	r2, [r7, #4]
 8000578:	603b      	str	r3, [r7, #0]
  if(len1 > 0 && str1[len1 - 1] == '\n') {
 800057a:	68bb      	ldr	r3, [r7, #8]
 800057c:	2b00      	cmp	r3, #0
 800057e:	dd09      	ble.n	8000594 <shell_default_output+0x28>
 8000580:	68bb      	ldr	r3, [r7, #8]
 8000582:	3b01      	subs	r3, #1
 8000584:	68fa      	ldr	r2, [r7, #12]
 8000586:	18d3      	adds	r3, r2, r3
 8000588:	781b      	ldrb	r3, [r3, #0]
 800058a:	2b0a      	cmp	r3, #10
 800058c:	d102      	bne.n	8000594 <shell_default_output+0x28>
    --len1;
 800058e:	68bb      	ldr	r3, [r7, #8]
 8000590:	3b01      	subs	r3, #1
 8000592:	60bb      	str	r3, [r7, #8]
  }
  if(len2 > 0 && str2[len2 - 1] == '\n') {
 8000594:	683b      	ldr	r3, [r7, #0]
 8000596:	2b00      	cmp	r3, #0
 8000598:	dd09      	ble.n	80005ae <shell_default_output+0x42>
 800059a:	683b      	ldr	r3, [r7, #0]
 800059c:	3b01      	subs	r3, #1
 800059e:	687a      	ldr	r2, [r7, #4]
 80005a0:	18d3      	adds	r3, r2, r3
 80005a2:	781b      	ldrb	r3, [r3, #0]
 80005a4:	2b0a      	cmp	r3, #10
 80005a6:	d102      	bne.n	80005ae <shell_default_output+0x42>
    --len2;
 80005a8:	683b      	ldr	r3, [r7, #0]
 80005aa:	3b01      	subs	r3, #1
 80005ac:	603b      	str	r3, [r7, #0]
  /*  PRINTF("shell_default_output: %.*s %.*s\n", len1, str1, len2, str2);*/
  
#if TELNETD_CONF_GUI
  telnetd_gui_output(str1, len1, str2, len2);
#endif /* TELNETD_CONF_GUI */
  buf_append(&buf, str1, len1);
 80005ae:	f640 00f4 	movw	r0, #2292	; 0x8f4
 80005b2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80005b6:	68f9      	ldr	r1, [r7, #12]
 80005b8:	68ba      	ldr	r2, [r7, #8]
 80005ba:	f7ff ff43 	bl	8000444 <buf_append>
  buf_append(&buf, str2, len2);
 80005be:	f640 00f4 	movw	r0, #2292	; 0x8f4
 80005c2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80005c6:	6879      	ldr	r1, [r7, #4]
 80005c8:	683a      	ldr	r2, [r7, #0]
 80005ca:	f7ff ff3b 	bl	8000444 <buf_append>
  buf_append(&buf, "\r\n", 2);
 80005ce:	f640 00f4 	movw	r0, #2292	; 0x8f4
 80005d2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80005d6:	f648 01d0 	movw	r1, #35024	; 0x88d0
 80005da:	f6c0 0100 	movt	r1, #2048	; 0x800
 80005de:	2202      	movs	r2, #2
 80005e0:	f7ff ff30 	bl	8000444 <buf_append>
}
 80005e4:	f107 0710 	add.w	r7, r7, #16
 80005e8:	46bd      	mov	sp, r7
 80005ea:	bd80      	pop	{r7, pc}

080005ec <shell_exit>:
/*---------------------------------------------------------------------------*/
void
shell_exit(void)
{
 80005ec:	b480      	push	{r7}
 80005ee:	af00      	add	r7, sp, #0
  s.state = STATE_CLOSE;
 80005f0:	f640 039c 	movw	r3, #2204	; 0x89c
 80005f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005f8:	2206      	movs	r2, #6
 80005fa:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
}
 80005fe:	46bd      	mov	sp, r7
 8000600:	bc80      	pop	{r7}
 8000602:	4770      	bx	lr

08000604 <process_thread_telnetd_process>:
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(telnetd_process, ev, data)
{
 8000604:	b580      	push	{r7, lr}
 8000606:	b086      	sub	sp, #24
 8000608:	af00      	add	r7, sp, #0
 800060a:	60f8      	str	r0, [r7, #12]
 800060c:	460b      	mov	r3, r1
 800060e:	607a      	str	r2, [r7, #4]
 8000610:	72fb      	strb	r3, [r7, #11]
  PROCESS_BEGIN();
 8000612:	2301      	movs	r3, #1
 8000614:	75fb      	strb	r3, [r7, #23]
 8000616:	68fb      	ldr	r3, [r7, #12]
 8000618:	881b      	ldrh	r3, [r3, #0]
 800061a:	2b00      	cmp	r3, #0
 800061c:	d002      	beq.n	8000624 <process_thread_telnetd_process+0x20>
 800061e:	2bd1      	cmp	r3, #209	; 0xd1
 8000620:	d00d      	beq.n	800063e <process_thread_telnetd_process+0x3a>
 8000622:	e023      	b.n	800066c <process_thread_telnetd_process+0x68>
  
  shell_init();
 8000624:	f000 ffca 	bl	80015bc <shell_init>
  telnetd_gui_init();
#endif /* TELNETD_CONF_GUI */

  petsciiconv_toascii(telnetd_reject_text, strlen(telnetd_reject_text));

  tcp_listen(UIP_HTONS(23));
 8000628:	f44f 50b8 	mov.w	r0, #5888	; 0x1700
 800062c:	f006 fae8 	bl	8006c00 <tcp_listen>
 8000630:	e000      	b.n	8000634 <process_thread_telnetd_process+0x30>
    } else {
#if TELNETD_CONF_GUI
      telnetd_gui_eventhandler(ev, data);
#endif /* TELNETD_CONF_GUI */
    }
  }
 8000632:	bf00      	nop
  petsciiconv_toascii(telnetd_reject_text, strlen(telnetd_reject_text));

  tcp_listen(UIP_HTONS(23));

  while(1) {
    PROCESS_WAIT_EVENT();
 8000634:	2300      	movs	r3, #0
 8000636:	75fb      	strb	r3, [r7, #23]
 8000638:	68fb      	ldr	r3, [r7, #12]
 800063a:	22d1      	movs	r2, #209	; 0xd1
 800063c:	801a      	strh	r2, [r3, #0]
 800063e:	7dfb      	ldrb	r3, [r7, #23]
 8000640:	2b00      	cmp	r3, #0
 8000642:	d101      	bne.n	8000648 <process_thread_telnetd_process+0x44>
 8000644:	2301      	movs	r3, #1
 8000646:	e017      	b.n	8000678 <process_thread_telnetd_process+0x74>
    if(ev == tcpip_event) {
 8000648:	f641 7394 	movw	r3, #8084	; 0x1f94
 800064c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000650:	781b      	ldrb	r3, [r3, #0]
 8000652:	7afa      	ldrb	r2, [r7, #11]
 8000654:	429a      	cmp	r2, r3
 8000656:	d103      	bne.n	8000660 <process_thread_telnetd_process+0x5c>
      telnetd_appcall(data);
 8000658:	6878      	ldr	r0, [r7, #4]
 800065a:	f000 f9c1 	bl	80009e0 <telnetd_appcall>
    } else {
#if TELNETD_CONF_GUI
      telnetd_gui_eventhandler(ev, data);
#endif /* TELNETD_CONF_GUI */
    }
  }
 800065e:	e7e8      	b.n	8000632 <process_thread_telnetd_process+0x2e>

  while(1) {
    PROCESS_WAIT_EVENT();
    if(ev == tcpip_event) {
      telnetd_appcall(data);
    } else if(ev == PROCESS_EVENT_EXIT) {
 8000660:	7afb      	ldrb	r3, [r7, #11]
 8000662:	2b83      	cmp	r3, #131	; 0x83
 8000664:	d1e5      	bne.n	8000632 <process_thread_telnetd_process+0x2e>
      telnetd_quit();
 8000666:	f7ff ff61 	bl	800052c <telnetd_quit>
    } else {
#if TELNETD_CONF_GUI
      telnetd_gui_eventhandler(ev, data);
#endif /* TELNETD_CONF_GUI */
    }
  }
 800066a:	e7e2      	b.n	8000632 <process_thread_telnetd_process+0x2e>
  
  PROCESS_END();
 800066c:	2300      	movs	r3, #0
 800066e:	75fb      	strb	r3, [r7, #23]
 8000670:	68fb      	ldr	r3, [r7, #12]
 8000672:	2200      	movs	r2, #0
 8000674:	801a      	strh	r2, [r3, #0]
 8000676:	2303      	movs	r3, #3
}
 8000678:	4618      	mov	r0, r3
 800067a:	f107 0718 	add.w	r7, r7, #24
 800067e:	46bd      	mov	sp, r7
 8000680:	bd80      	pop	{r7, pc}
 8000682:	bf00      	nop

08000684 <acked>:
/*---------------------------------------------------------------------------*/
static void
acked(void)
{
 8000684:	b580      	push	{r7, lr}
 8000686:	af00      	add	r7, sp, #0
  buf_pop(&buf, s.numsent);
 8000688:	f640 039c 	movw	r3, #2204	; 0x89c
 800068c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000690:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 8000694:	f640 00f4 	movw	r0, #2292	; 0x8f4
 8000698:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800069c:	4619      	mov	r1, r3
 800069e:	f7ff ff0f 	bl	80004c0 <buf_pop>
}
 80006a2:	bd80      	pop	{r7, pc}

080006a4 <senddata>:
/*---------------------------------------------------------------------------*/
static void
senddata(void)
{
 80006a4:	b580      	push	{r7, lr}
 80006a6:	b082      	sub	sp, #8
 80006a8:	af00      	add	r7, sp, #0
  int len;
  len = MIN(buf_len(&buf), uip_mss());
 80006aa:	f640 00f4 	movw	r0, #2292	; 0x8f4
 80006ae:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80006b2:	f7ff ff2d 	bl	8000510 <buf_len>
 80006b6:	4602      	mov	r2, r0
 80006b8:	f641 03c8 	movw	r3, #6344	; 0x18c8
 80006bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80006c0:	681b      	ldr	r3, [r3, #0]
 80006c2:	8a5b      	ldrh	r3, [r3, #18]
 80006c4:	429a      	cmp	r2, r3
 80006c6:	da07      	bge.n	80006d8 <senddata+0x34>
 80006c8:	f640 00f4 	movw	r0, #2292	; 0x8f4
 80006cc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80006d0:	f7ff ff1e 	bl	8000510 <buf_len>
 80006d4:	4603      	mov	r3, r0
 80006d6:	e005      	b.n	80006e4 <senddata+0x40>
 80006d8:	f641 03c8 	movw	r3, #6344	; 0x18c8
 80006dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80006e0:	681b      	ldr	r3, [r3, #0]
 80006e2:	8a5b      	ldrh	r3, [r3, #18]
 80006e4:	607b      	str	r3, [r7, #4]
  PRINTF("senddata len %d\n", len);
  buf_copyto(&buf, uip_appdata, len);
 80006e6:	f641 03c4 	movw	r3, #6340	; 0x18c4
 80006ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80006ee:	681b      	ldr	r3, [r3, #0]
 80006f0:	f640 00f4 	movw	r0, #2292	; 0x8f4
 80006f4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80006f8:	4619      	mov	r1, r3
 80006fa:	687a      	ldr	r2, [r7, #4]
 80006fc:	f7ff fece 	bl	800049c <buf_copyto>
  uip_send(uip_appdata, len);
 8000700:	f641 03c4 	movw	r3, #6340	; 0x18c4
 8000704:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000708:	681b      	ldr	r3, [r3, #0]
 800070a:	4618      	mov	r0, r3
 800070c:	6879      	ldr	r1, [r7, #4]
 800070e:	f006 f985 	bl	8006a1c <uip_send>
  s.numsent = len;
 8000712:	687b      	ldr	r3, [r7, #4]
 8000714:	b29a      	uxth	r2, r3
 8000716:	f640 039c 	movw	r3, #2204	; 0x89c
 800071a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800071e:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
}
 8000722:	f107 0708 	add.w	r7, r7, #8
 8000726:	46bd      	mov	sp, r7
 8000728:	bd80      	pop	{r7, pc}
 800072a:	bf00      	nop

0800072c <get_char>:
/*---------------------------------------------------------------------------*/
static void
get_char(uint8_t c)
{
 800072c:	b580      	push	{r7, lr}
 800072e:	b082      	sub	sp, #8
 8000730:	af00      	add	r7, sp, #0
 8000732:	4603      	mov	r3, r0
 8000734:	71fb      	strb	r3, [r7, #7]
  PRINTF("telnetd: get_char '%c' %d %d\n", c, c, s.bufptr);

  if(c == 0) {
 8000736:	79fb      	ldrb	r3, [r7, #7]
 8000738:	2b00      	cmp	r3, #0
 800073a:	d060      	beq.n	80007fe <get_char+0xd2>
    return;
  }

  if(c != ISO_nl && c != ISO_cr) {
 800073c:	79fb      	ldrb	r3, [r7, #7]
 800073e:	2b0a      	cmp	r3, #10
 8000740:	d01d      	beq.n	800077e <get_char+0x52>
 8000742:	79fb      	ldrb	r3, [r7, #7]
 8000744:	2b0d      	cmp	r3, #13
 8000746:	d01a      	beq.n	800077e <get_char+0x52>
    s.buf[(int)s.bufptr] = c;
 8000748:	f640 039c 	movw	r3, #2204	; 0x89c
 800074c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000750:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 8000754:	461a      	mov	r2, r3
 8000756:	f640 039c 	movw	r3, #2204	; 0x89c
 800075a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800075e:	79f9      	ldrb	r1, [r7, #7]
 8000760:	5499      	strb	r1, [r3, r2]
    ++s.bufptr;
 8000762:	f640 039c 	movw	r3, #2204	; 0x89c
 8000766:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800076a:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 800076e:	3301      	adds	r3, #1
 8000770:	b2da      	uxtb	r2, r3
 8000772:	f640 039c 	movw	r3, #2204	; 0x89c
 8000776:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800077a:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
  }
  if(((c == ISO_nl || c == ISO_cr) && s.bufptr > 0) ||
 800077e:	79fb      	ldrb	r3, [r7, #7]
 8000780:	2b0a      	cmp	r3, #10
 8000782:	d002      	beq.n	800078a <get_char+0x5e>
 8000784:	79fb      	ldrb	r3, [r7, #7]
 8000786:	2b0d      	cmp	r3, #13
 8000788:	d107      	bne.n	800079a <get_char+0x6e>
 800078a:	f640 039c 	movw	r3, #2204	; 0x89c
 800078e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000792:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 8000796:	2b00      	cmp	r3, #0
 8000798:	d107      	bne.n	80007aa <get_char+0x7e>
     s.bufptr == sizeof(s.buf)) {
 800079a:	f640 039c 	movw	r3, #2204	; 0x89c
 800079e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80007a2:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51

  if(c != ISO_nl && c != ISO_cr) {
    s.buf[(int)s.bufptr] = c;
    ++s.bufptr;
  }
  if(((c == ISO_nl || c == ISO_cr) && s.bufptr > 0) ||
 80007a6:	2b51      	cmp	r3, #81	; 0x51
 80007a8:	d12a      	bne.n	8000800 <get_char+0xd4>
     s.bufptr == sizeof(s.buf)) {
    if(s.bufptr < sizeof(s.buf)) {
 80007aa:	f640 039c 	movw	r3, #2204	; 0x89c
 80007ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80007b2:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 80007b6:	2b50      	cmp	r3, #80	; 0x50
 80007b8:	d80c      	bhi.n	80007d4 <get_char+0xa8>
      s.buf[(int)s.bufptr] = 0;
 80007ba:	f640 039c 	movw	r3, #2204	; 0x89c
 80007be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80007c2:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 80007c6:	461a      	mov	r2, r3
 80007c8:	f640 039c 	movw	r3, #2204	; 0x89c
 80007cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80007d0:	2100      	movs	r1, #0
 80007d2:	5499      	strb	r1, [r3, r2]
    }
    petsciiconv_topetscii(s.buf, TELNETD_CONF_LINELEN);
    PRINTF("telnetd: get_char '%.*s'\n", s.bufptr, s.buf);
    shell_input(s.buf, s.bufptr);
 80007d4:	f640 039c 	movw	r3, #2204	; 0x89c
 80007d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80007dc:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 80007e0:	f640 009c 	movw	r0, #2204	; 0x89c
 80007e4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80007e8:	4619      	mov	r1, r3
 80007ea:	f000 fcd1 	bl	8001190 <shell_input>
    s.bufptr = 0;
 80007ee:	f640 039c 	movw	r3, #2204	; 0x89c
 80007f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80007f6:	2200      	movs	r2, #0
 80007f8:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
 80007fc:	e000      	b.n	8000800 <get_char+0xd4>
get_char(uint8_t c)
{
  PRINTF("telnetd: get_char '%c' %d %d\n", c, c, s.bufptr);

  if(c == 0) {
    return;
 80007fe:	bf00      	nop
    petsciiconv_topetscii(s.buf, TELNETD_CONF_LINELEN);
    PRINTF("telnetd: get_char '%.*s'\n", s.bufptr, s.buf);
    shell_input(s.buf, s.bufptr);
    s.bufptr = 0;
  }
}
 8000800:	f107 0708 	add.w	r7, r7, #8
 8000804:	46bd      	mov	sp, r7
 8000806:	bd80      	pop	{r7, pc}

08000808 <sendopt>:
/*---------------------------------------------------------------------------*/
static void
sendopt(uint8_t option, uint8_t value)
{
 8000808:	b580      	push	{r7, lr}
 800080a:	b084      	sub	sp, #16
 800080c:	af00      	add	r7, sp, #0
 800080e:	4602      	mov	r2, r0
 8000810:	460b      	mov	r3, r1
 8000812:	71fa      	strb	r2, [r7, #7]
 8000814:	71bb      	strb	r3, [r7, #6]
  char line[4];
  line[0] = (char)TELNET_IAC;
 8000816:	23ff      	movs	r3, #255	; 0xff
 8000818:	733b      	strb	r3, [r7, #12]
  line[1] = option;
 800081a:	79fb      	ldrb	r3, [r7, #7]
 800081c:	737b      	strb	r3, [r7, #13]
  line[2] = value;
 800081e:	79bb      	ldrb	r3, [r7, #6]
 8000820:	73bb      	strb	r3, [r7, #14]
  line[3] = 0;
 8000822:	2300      	movs	r3, #0
 8000824:	73fb      	strb	r3, [r7, #15]
  petsciiconv_topetscii(line, 4);
  buf_append(&buf, line, 4);
 8000826:	f107 030c 	add.w	r3, r7, #12
 800082a:	f640 00f4 	movw	r0, #2292	; 0x8f4
 800082e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000832:	4619      	mov	r1, r3
 8000834:	2204      	movs	r2, #4
 8000836:	f7ff fe05 	bl	8000444 <buf_append>
}
 800083a:	f107 0710 	add.w	r7, r7, #16
 800083e:	46bd      	mov	sp, r7
 8000840:	bd80      	pop	{r7, pc}
 8000842:	bf00      	nop

08000844 <newdata>:
/*---------------------------------------------------------------------------*/
static void
newdata(void)
{
 8000844:	b580      	push	{r7, lr}
 8000846:	b084      	sub	sp, #16
 8000848:	af00      	add	r7, sp, #0
  uint16_t len;
  uint8_t c;
  uint8_t *ptr;
    
  len = uip_datalen();
 800084a:	f241 730c 	movw	r3, #5900	; 0x170c
 800084e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000852:	881b      	ldrh	r3, [r3, #0]
 8000854:	81fb      	strh	r3, [r7, #14]
  PRINTF("newdata len %d '%.*s'\n", len, len, (char *)uip_appdata);

  ptr = uip_appdata;
 8000856:	f641 03c4 	movw	r3, #6340	; 0x18c4
 800085a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800085e:	681b      	ldr	r3, [r3, #0]
 8000860:	60bb      	str	r3, [r7, #8]
  while(len > 0 && s.bufptr < sizeof(s.buf)) {
 8000862:	e0ac      	b.n	80009be <newdata+0x17a>
    c = *ptr;
 8000864:	68bb      	ldr	r3, [r7, #8]
 8000866:	781b      	ldrb	r3, [r3, #0]
 8000868:	71fb      	strb	r3, [r7, #7]
    PRINTF("newdata char '%c' %d %d state %d\n", c, c, len, s.state);
    ++ptr;
 800086a:	68bb      	ldr	r3, [r7, #8]
 800086c:	3301      	adds	r3, #1
 800086e:	60bb      	str	r3, [r7, #8]
    --len;
 8000870:	89fb      	ldrh	r3, [r7, #14]
 8000872:	3b01      	subs	r3, #1
 8000874:	81fb      	strh	r3, [r7, #14]
    switch(s.state) {
 8000876:	f640 039c 	movw	r3, #2204	; 0x89c
 800087a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800087e:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 8000882:	2b05      	cmp	r3, #5
 8000884:	f200 809b 	bhi.w	80009be <newdata+0x17a>
 8000888:	a201      	add	r2, pc, #4	; (adr r2, 8000890 <newdata+0x4c>)
 800088a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800088e:	bf00      	nop
 8000890:	0800099f 	.word	0x0800099f
 8000894:	080008a9 	.word	0x080008a9
 8000898:	08000937 	.word	0x08000937
 800089c:	08000951 	.word	0x08000951
 80008a0:	0800096b 	.word	0x0800096b
 80008a4:	08000985 	.word	0x08000985
    case STATE_IAC:
      if(c == TELNET_IAC) {
 80008a8:	79fb      	ldrb	r3, [r7, #7]
 80008aa:	2bff      	cmp	r3, #255	; 0xff
 80008ac:	d10b      	bne.n	80008c6 <newdata+0x82>
	get_char(c);
 80008ae:	79fb      	ldrb	r3, [r7, #7]
 80008b0:	4618      	mov	r0, r3
 80008b2:	f7ff ff3b 	bl	800072c <get_char>
	s.state = STATE_NORMAL;
 80008b6:	f640 039c 	movw	r3, #2204	; 0x89c
 80008ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80008be:	2200      	movs	r2, #0
 80008c0:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
	default:
	  s.state = STATE_NORMAL;
	  break;
	}
      }
      break;
 80008c4:	e07b      	b.n	80009be <newdata+0x17a>
    case STATE_IAC:
      if(c == TELNET_IAC) {
	get_char(c);
	s.state = STATE_NORMAL;
      } else {
	switch(c) {
 80008c6:	79fb      	ldrb	r3, [r7, #7]
 80008c8:	3bfb      	subs	r3, #251	; 0xfb
 80008ca:	2b03      	cmp	r3, #3
 80008cc:	d82a      	bhi.n	8000924 <newdata+0xe0>
 80008ce:	a201      	add	r2, pc, #4	; (adr r2, 80008d4 <newdata+0x90>)
 80008d0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80008d4:	080008e5 	.word	0x080008e5
 80008d8:	080008f5 	.word	0x080008f5
 80008dc:	08000905 	.word	0x08000905
 80008e0:	08000915 	.word	0x08000915
	case TELNET_WILL:
	  s.state = STATE_WILL;
 80008e4:	f640 039c 	movw	r3, #2204	; 0x89c
 80008e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80008ec:	2202      	movs	r2, #2
 80008ee:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
	  break;
 80008f2:	e01f      	b.n	8000934 <newdata+0xf0>
	case TELNET_WONT:
	  s.state = STATE_WONT;
 80008f4:	f640 039c 	movw	r3, #2204	; 0x89c
 80008f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80008fc:	2203      	movs	r2, #3
 80008fe:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
	  break;
 8000902:	e017      	b.n	8000934 <newdata+0xf0>
	case TELNET_DO:
	  s.state = STATE_DO;
 8000904:	f640 039c 	movw	r3, #2204	; 0x89c
 8000908:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800090c:	2204      	movs	r2, #4
 800090e:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
	  break;
 8000912:	e00f      	b.n	8000934 <newdata+0xf0>
	case TELNET_DONT:
	  s.state = STATE_DONT;
 8000914:	f640 039c 	movw	r3, #2204	; 0x89c
 8000918:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800091c:	2205      	movs	r2, #5
 800091e:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
	  break;
 8000922:	e007      	b.n	8000934 <newdata+0xf0>
	default:
	  s.state = STATE_NORMAL;
 8000924:	f640 039c 	movw	r3, #2204	; 0x89c
 8000928:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800092c:	2200      	movs	r2, #0
 800092e:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
	  break;
 8000932:	bf00      	nop
	}
      }
      break;
 8000934:	e043      	b.n	80009be <newdata+0x17a>
    case STATE_WILL:
      /* Reply with a DONT */
      sendopt(TELNET_DONT, c);
 8000936:	79fb      	ldrb	r3, [r7, #7]
 8000938:	20fe      	movs	r0, #254	; 0xfe
 800093a:	4619      	mov	r1, r3
 800093c:	f7ff ff64 	bl	8000808 <sendopt>
      s.state = STATE_NORMAL;
 8000940:	f640 039c 	movw	r3, #2204	; 0x89c
 8000944:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000948:	2200      	movs	r2, #0
 800094a:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
      break;
 800094e:	e036      	b.n	80009be <newdata+0x17a>
      
    case STATE_WONT:
      /* Reply with a DONT */
      sendopt(TELNET_DONT, c);
 8000950:	79fb      	ldrb	r3, [r7, #7]
 8000952:	20fe      	movs	r0, #254	; 0xfe
 8000954:	4619      	mov	r1, r3
 8000956:	f7ff ff57 	bl	8000808 <sendopt>
      s.state = STATE_NORMAL;
 800095a:	f640 039c 	movw	r3, #2204	; 0x89c
 800095e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000962:	2200      	movs	r2, #0
 8000964:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
      break;
 8000968:	e029      	b.n	80009be <newdata+0x17a>
    case STATE_DO:
      /* Reply with a WONT */
      sendopt(TELNET_WONT, c);
 800096a:	79fb      	ldrb	r3, [r7, #7]
 800096c:	20fc      	movs	r0, #252	; 0xfc
 800096e:	4619      	mov	r1, r3
 8000970:	f7ff ff4a 	bl	8000808 <sendopt>
      s.state = STATE_NORMAL;
 8000974:	f640 039c 	movw	r3, #2204	; 0x89c
 8000978:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800097c:	2200      	movs	r2, #0
 800097e:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
      break;
 8000982:	e01c      	b.n	80009be <newdata+0x17a>
    case STATE_DONT:
      /* Reply with a WONT */
      sendopt(TELNET_WONT, c);
 8000984:	79fb      	ldrb	r3, [r7, #7]
 8000986:	20fc      	movs	r0, #252	; 0xfc
 8000988:	4619      	mov	r1, r3
 800098a:	f7ff ff3d 	bl	8000808 <sendopt>
      s.state = STATE_NORMAL;
 800098e:	f640 039c 	movw	r3, #2204	; 0x89c
 8000992:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000996:	2200      	movs	r2, #0
 8000998:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
      break;
 800099c:	e00f      	b.n	80009be <newdata+0x17a>
    case STATE_NORMAL:
      if(c == TELNET_IAC) {
 800099e:	79fb      	ldrb	r3, [r7, #7]
 80009a0:	2bff      	cmp	r3, #255	; 0xff
 80009a2:	d107      	bne.n	80009b4 <newdata+0x170>
	s.state = STATE_IAC;
 80009a4:	f640 039c 	movw	r3, #2204	; 0x89c
 80009a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80009ac:	2201      	movs	r2, #1
 80009ae:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
      } else {
	get_char(c);
      }
      break;
 80009b2:	e003      	b.n	80009bc <newdata+0x178>
      break;
    case STATE_NORMAL:
      if(c == TELNET_IAC) {
	s.state = STATE_IAC;
      } else {
	get_char(c);
 80009b4:	79fb      	ldrb	r3, [r7, #7]
 80009b6:	4618      	mov	r0, r3
 80009b8:	f7ff feb8 	bl	800072c <get_char>
      }
      break;
 80009bc:	bf00      	nop
    
  len = uip_datalen();
  PRINTF("newdata len %d '%.*s'\n", len, len, (char *)uip_appdata);

  ptr = uip_appdata;
  while(len > 0 && s.bufptr < sizeof(s.buf)) {
 80009be:	89fb      	ldrh	r3, [r7, #14]
 80009c0:	2b00      	cmp	r3, #0
 80009c2:	d008      	beq.n	80009d6 <newdata+0x192>
 80009c4:	f640 039c 	movw	r3, #2204	; 0x89c
 80009c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80009cc:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 80009d0:	2b50      	cmp	r3, #80	; 0x50
 80009d2:	f67f af47 	bls.w	8000864 <newdata+0x20>
	get_char(c);
      }
      break;
    }
  }
}
 80009d6:	f107 0710 	add.w	r7, r7, #16
 80009da:	46bd      	mov	sp, r7
 80009dc:	bd80      	pop	{r7, pc}
 80009de:	bf00      	nop

080009e0 <telnetd_appcall>:
/*---------------------------------------------------------------------------*/
void
telnetd_appcall(void *ts)
{
 80009e0:	b580      	push	{r7, lr}
 80009e2:	b082      	sub	sp, #8
 80009e4:	af00      	add	r7, sp, #0
 80009e6:	6078      	str	r0, [r7, #4]
  if(uip_connected()) {
 80009e8:	f641 03bc 	movw	r3, #6332	; 0x18bc
 80009ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80009f0:	781b      	ldrb	r3, [r3, #0]
 80009f2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80009f6:	2b00      	cmp	r3, #0
 80009f8:	d03e      	beq.n	8000a78 <telnetd_appcall+0x98>
    if(!connected) {
 80009fa:	f241 03cc 	movw	r3, #4300	; 0x10cc
 80009fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a02:	781b      	ldrb	r3, [r3, #0]
 8000a04:	2b00      	cmp	r3, #0
 8000a06:	d11e      	bne.n	8000a46 <telnetd_appcall+0x66>
      buf_init(&buf);
 8000a08:	f640 00f4 	movw	r0, #2292	; 0x8f4
 8000a0c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000a10:	f7ff fd06 	bl	8000420 <buf_init>
      s.bufptr = 0;
 8000a14:	f640 039c 	movw	r3, #2204	; 0x89c
 8000a18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a1c:	2200      	movs	r2, #0
 8000a1e:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
      s.state = STATE_NORMAL;
 8000a22:	f640 039c 	movw	r3, #2204	; 0x89c
 8000a26:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a2a:	2200      	movs	r2, #0
 8000a2c:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
      connected = 1;
 8000a30:	f241 03cc 	movw	r3, #4300	; 0x10cc
 8000a34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a38:	2201      	movs	r2, #1
 8000a3a:	701a      	strb	r2, [r3, #0]
      shell_start();
 8000a3c:	f000 fe88 	bl	8001750 <shell_start>
      ts = (char *)0;
 8000a40:	2300      	movs	r3, #0
 8000a42:	607b      	str	r3, [r7, #4]
 8000a44:	e00f      	b.n	8000a66 <telnetd_appcall+0x86>
    } else {
      uip_send(telnetd_reject_text, strlen(telnetd_reject_text));
 8000a46:	f240 4058 	movw	r0, #1112	; 0x458
 8000a4a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000a4e:	f7ff fc85 	bl	800035c <strlen>
 8000a52:	4603      	mov	r3, r0
 8000a54:	f240 4058 	movw	r0, #1112	; 0x458
 8000a58:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000a5c:	4619      	mov	r1, r3
 8000a5e:	f005 ffdd 	bl	8006a1c <uip_send>
      ts = (char *)1;
 8000a62:	2301      	movs	r3, #1
 8000a64:	607b      	str	r3, [r7, #4]
    }
    tcp_markconn(uip_conn, ts);
 8000a66:	f641 03c8 	movw	r3, #6344	; 0x18c8
 8000a6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a6e:	681b      	ldr	r3, [r3, #0]
 8000a70:	4618      	mov	r0, r3
 8000a72:	6879      	ldr	r1, [r7, #4]
 8000a74:	f006 f902 	bl	8006c7c <tcp_attach>
  }

  if(!ts) {
 8000a78:	687b      	ldr	r3, [r7, #4]
 8000a7a:	2b00      	cmp	r3, #0
 8000a7c:	d17e      	bne.n	8000b7c <telnetd_appcall+0x19c>
    if(s.state == STATE_CLOSE) {
 8000a7e:	f640 039c 	movw	r3, #2204	; 0x89c
 8000a82:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a86:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 8000a8a:	2b06      	cmp	r3, #6
 8000a8c:	d10d      	bne.n	8000aaa <telnetd_appcall+0xca>
      s.state = STATE_NORMAL;
 8000a8e:	f640 039c 	movw	r3, #2204	; 0x89c
 8000a92:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a96:	2200      	movs	r2, #0
 8000a98:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
      uip_close();
 8000a9c:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8000aa0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000aa4:	2210      	movs	r2, #16
 8000aa6:	701a      	strb	r2, [r3, #0]
      return;
 8000aa8:	e086      	b.n	8000bb8 <telnetd_appcall+0x1d8>
    }
    if(uip_closed() ||
 8000aaa:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8000aae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ab2:	781b      	ldrb	r3, [r3, #0]
 8000ab4:	f003 0310 	and.w	r3, r3, #16
 8000ab8:	2b00      	cmp	r3, #0
 8000aba:	d111      	bne.n	8000ae0 <telnetd_appcall+0x100>
       uip_aborted() ||
 8000abc:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8000ac0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ac4:	781b      	ldrb	r3, [r3, #0]
 8000ac6:	f003 0320 	and.w	r3, r3, #32
    if(s.state == STATE_CLOSE) {
      s.state = STATE_NORMAL;
      uip_close();
      return;
    }
    if(uip_closed() ||
 8000aca:	2b00      	cmp	r3, #0
 8000acc:	d108      	bne.n	8000ae0 <telnetd_appcall+0x100>
       uip_aborted() ||
 8000ace:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8000ad2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ad6:	781b      	ldrb	r3, [r3, #0]
 8000ad8:	b2db      	uxtb	r3, r3
 8000ada:	b25b      	sxtb	r3, r3
 8000adc:	2b00      	cmp	r3, #0
 8000ade:	da07      	bge.n	8000af0 <telnetd_appcall+0x110>
       uip_timedout()) {
      shell_stop();
 8000ae0:	f000 fe56 	bl	8001790 <shell_stop>
      connected = 0;
 8000ae4:	f241 03cc 	movw	r3, #4300	; 0x10cc
 8000ae8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000aec:	2200      	movs	r2, #0
 8000aee:	701a      	strb	r2, [r3, #0]
    }
    if(uip_acked()) {
 8000af0:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8000af4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000af8:	781b      	ldrb	r3, [r3, #0]
 8000afa:	f003 0301 	and.w	r3, r3, #1
 8000afe:	2b00      	cmp	r3, #0
 8000b00:	d001      	beq.n	8000b06 <telnetd_appcall+0x126>
      acked();
 8000b02:	f7ff fdbf 	bl	8000684 <acked>
    }
    if(uip_newdata()) {
 8000b06:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8000b0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000b0e:	781b      	ldrb	r3, [r3, #0]
 8000b10:	f003 0302 	and.w	r3, r3, #2
 8000b14:	2b00      	cmp	r3, #0
 8000b16:	d001      	beq.n	8000b1c <telnetd_appcall+0x13c>
      newdata();
 8000b18:	f7ff fe94 	bl	8000844 <newdata>
    }
    if(uip_rexmit() ||
 8000b1c:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8000b20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000b24:	781b      	ldrb	r3, [r3, #0]
 8000b26:	f003 0304 	and.w	r3, r3, #4
 8000b2a:	2b00      	cmp	r3, #0
 8000b2c:	d123      	bne.n	8000b76 <telnetd_appcall+0x196>
       uip_newdata() ||
 8000b2e:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8000b32:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000b36:	781b      	ldrb	r3, [r3, #0]
 8000b38:	f003 0302 	and.w	r3, r3, #2
      acked();
    }
    if(uip_newdata()) {
      newdata();
    }
    if(uip_rexmit() ||
 8000b3c:	2b00      	cmp	r3, #0
 8000b3e:	d11a      	bne.n	8000b76 <telnetd_appcall+0x196>
       uip_newdata() ||
       uip_acked() ||
 8000b40:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8000b44:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000b48:	781b      	ldrb	r3, [r3, #0]
 8000b4a:	f003 0301 	and.w	r3, r3, #1
    }
    if(uip_newdata()) {
      newdata();
    }
    if(uip_rexmit() ||
       uip_newdata() ||
 8000b4e:	2b00      	cmp	r3, #0
 8000b50:	d111      	bne.n	8000b76 <telnetd_appcall+0x196>
       uip_acked() ||
       uip_connected() ||
 8000b52:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8000b56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000b5a:	781b      	ldrb	r3, [r3, #0]
 8000b5c:	f003 0340 	and.w	r3, r3, #64	; 0x40
    if(uip_newdata()) {
      newdata();
    }
    if(uip_rexmit() ||
       uip_newdata() ||
       uip_acked() ||
 8000b60:	2b00      	cmp	r3, #0
 8000b62:	d108      	bne.n	8000b76 <telnetd_appcall+0x196>
       uip_connected() ||
       uip_poll()) {
 8000b64:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8000b68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000b6c:	781b      	ldrb	r3, [r3, #0]
 8000b6e:	f003 0308 	and.w	r3, r3, #8
      newdata();
    }
    if(uip_rexmit() ||
       uip_newdata() ||
       uip_acked() ||
       uip_connected() ||
 8000b72:	2b00      	cmp	r3, #0
 8000b74:	d020      	beq.n	8000bb8 <telnetd_appcall+0x1d8>
       uip_poll()) {
      senddata();
 8000b76:	f7ff fd95 	bl	80006a4 <senddata>
 8000b7a:	e01d      	b.n	8000bb8 <telnetd_appcall+0x1d8>
    }
  } else {
    if(uip_poll()) {
 8000b7c:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8000b80:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000b84:	781b      	ldrb	r3, [r3, #0]
 8000b86:	f003 0308 	and.w	r3, r3, #8
 8000b8a:	2b00      	cmp	r3, #0
 8000b8c:	d014      	beq.n	8000bb8 <telnetd_appcall+0x1d8>
      if(ts == (char *)10) {
 8000b8e:	687b      	ldr	r3, [r7, #4]
 8000b90:	2b0a      	cmp	r3, #10
 8000b92:	d106      	bne.n	8000ba2 <telnetd_appcall+0x1c2>
        uip_close();
 8000b94:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8000b98:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000b9c:	2210      	movs	r2, #16
 8000b9e:	701a      	strb	r2, [r3, #0]
 8000ba0:	e00a      	b.n	8000bb8 <telnetd_appcall+0x1d8>
      } else {
        tcp_markconn(uip_conn, (char *)ts + 1);
 8000ba2:	f641 03c8 	movw	r3, #6344	; 0x18c8
 8000ba6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000baa:	681a      	ldr	r2, [r3, #0]
 8000bac:	687b      	ldr	r3, [r7, #4]
 8000bae:	3301      	adds	r3, #1
 8000bb0:	4610      	mov	r0, r2
 8000bb2:	4619      	mov	r1, r3
 8000bb4:	f006 f862 	bl	8006c7c <tcp_attach>
      }
    }
  }
}
 8000bb8:	f107 0708 	add.w	r7, r7, #8
 8000bbc:	46bd      	mov	sp, r7
 8000bbe:	bd80      	pop	{r7, pc}

08000bc0 <process_thread_shell_null_process>:
	      &shell_exit_process);
SHELL_COMMAND(quit_command, "quit", "quit: exit shell",
	      &shell_exit_process);
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_null_process, ev, data)
{
 8000bc0:	b480      	push	{r7}
 8000bc2:	b087      	sub	sp, #28
 8000bc4:	af00      	add	r7, sp, #0
 8000bc6:	60f8      	str	r0, [r7, #12]
 8000bc8:	460b      	mov	r3, r1
 8000bca:	607a      	str	r2, [r7, #4]
 8000bcc:	72fb      	strb	r3, [r7, #11]
  struct shell_input *input;
  PROCESS_BEGIN();
 8000bce:	2301      	movs	r3, #1
 8000bd0:	75fb      	strb	r3, [r7, #23]
 8000bd2:	68fb      	ldr	r3, [r7, #12]
 8000bd4:	881b      	ldrh	r3, [r3, #0]
 8000bd6:	2b00      	cmp	r3, #0
 8000bd8:	d003      	beq.n	8000be2 <process_thread_shell_null_process+0x22>
 8000bda:	2b69      	cmp	r3, #105	; 0x69
 8000bdc:	d006      	beq.n	8000bec <process_thread_shell_null_process+0x2c>
 8000bde:	e020      	b.n	8000c22 <process_thread_shell_null_process+0x62>
    input = data;

    if(input->len1 + input->len2 == 0) {
      PROCESS_EXIT();
    }
  }
 8000be0:	bf00      	nop
PROCESS_THREAD(shell_null_process, ev, data)
{
  struct shell_input *input;
  PROCESS_BEGIN();
  while(1) {
    PROCESS_WAIT_EVENT_UNTIL(ev == shell_event_input);
 8000be2:	2300      	movs	r3, #0
 8000be4:	75fb      	strb	r3, [r7, #23]
 8000be6:	68fb      	ldr	r3, [r7, #12]
 8000be8:	2269      	movs	r2, #105	; 0x69
 8000bea:	801a      	strh	r2, [r3, #0]
 8000bec:	7dfb      	ldrb	r3, [r7, #23]
 8000bee:	2b00      	cmp	r3, #0
 8000bf0:	d007      	beq.n	8000c02 <process_thread_shell_null_process+0x42>
 8000bf2:	7afa      	ldrb	r2, [r7, #11]
 8000bf4:	f241 63f8 	movw	r3, #5880	; 0x16f8
 8000bf8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000bfc:	681b      	ldr	r3, [r3, #0]
 8000bfe:	429a      	cmp	r2, r3
 8000c00:	d001      	beq.n	8000c06 <process_thread_shell_null_process+0x46>
 8000c02:	2301      	movs	r3, #1
 8000c04:	e013      	b.n	8000c2e <process_thread_shell_null_process+0x6e>
    input = data;
 8000c06:	687b      	ldr	r3, [r7, #4]
 8000c08:	613b      	str	r3, [r7, #16]

    if(input->len1 + input->len2 == 0) {
 8000c0a:	693b      	ldr	r3, [r7, #16]
 8000c0c:	689a      	ldr	r2, [r3, #8]
 8000c0e:	693b      	ldr	r3, [r7, #16]
 8000c10:	68db      	ldr	r3, [r3, #12]
 8000c12:	18d3      	adds	r3, r2, r3
 8000c14:	2b00      	cmp	r3, #0
 8000c16:	d1e3      	bne.n	8000be0 <process_thread_shell_null_process+0x20>
      PROCESS_EXIT();
 8000c18:	68fb      	ldr	r3, [r7, #12]
 8000c1a:	2200      	movs	r2, #0
 8000c1c:	801a      	strh	r2, [r3, #0]
 8000c1e:	2302      	movs	r3, #2
 8000c20:	e005      	b.n	8000c2e <process_thread_shell_null_process+0x6e>
    }
  }
  PROCESS_END();
 8000c22:	2300      	movs	r3, #0
 8000c24:	75fb      	strb	r3, [r7, #23]
 8000c26:	68fb      	ldr	r3, [r7, #12]
 8000c28:	2200      	movs	r2, #0
 8000c2a:	801a      	strh	r2, [r3, #0]
 8000c2c:	2303      	movs	r3, #3
}
 8000c2e:	4618      	mov	r0, r3
 8000c30:	f107 071c 	add.w	r7, r7, #28
 8000c34:	46bd      	mov	sp, r7
 8000c36:	bc80      	pop	{r7}
 8000c38:	4770      	bx	lr
 8000c3a:	bf00      	nop

08000c3c <command_kill>:
/*---------------------------------------------------------------------------*/
static void
command_kill(struct shell_command *c)
{
 8000c3c:	b580      	push	{r7, lr}
 8000c3e:	b082      	sub	sp, #8
 8000c40:	af00      	add	r7, sp, #0
 8000c42:	6078      	str	r0, [r7, #4]
  if(c != NULL) {
 8000c44:	687b      	ldr	r3, [r7, #4]
 8000c46:	2b00      	cmp	r3, #0
 8000c48:	d011      	beq.n	8000c6e <command_kill+0x32>
    shell_output_str(&killall_command, "Stopping command ", c->command);
 8000c4a:	687b      	ldr	r3, [r7, #4]
 8000c4c:	685b      	ldr	r3, [r3, #4]
 8000c4e:	f240 5018 	movw	r0, #1304	; 0x518
 8000c52:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000c56:	f648 11d4 	movw	r1, #35284	; 0x89d4
 8000c5a:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000c5e:	461a      	mov	r2, r3
 8000c60:	f000 fae4 	bl	800122c <shell_output_str>
    process_exit(c->process);
 8000c64:	687b      	ldr	r3, [r7, #4]
 8000c66:	68db      	ldr	r3, [r3, #12]
 8000c68:	4618      	mov	r0, r3
 8000c6a:	f003 f95f 	bl	8003f2c <process_exit>
  }
}
 8000c6e:	f107 0708 	add.w	r7, r7, #8
 8000c72:	46bd      	mov	sp, r7
 8000c74:	bd80      	pop	{r7, pc}
 8000c76:	bf00      	nop

08000c78 <killall>:
/*---------------------------------------------------------------------------*/
static void
killall(void)
{
 8000c78:	b580      	push	{r7, lr}
 8000c7a:	b082      	sub	sp, #8
 8000c7c:	af00      	add	r7, sp, #0
  struct shell_command *c;
  for(c = list_head(commands);
 8000c7e:	f240 43ac 	movw	r3, #1196	; 0x4ac
 8000c82:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c86:	681b      	ldr	r3, [r3, #0]
 8000c88:	4618      	mov	r0, r3
 8000c8a:	f003 fb89 	bl	80043a0 <list_head>
 8000c8e:	6078      	str	r0, [r7, #4]
 8000c90:	e014      	b.n	8000cbc <killall+0x44>
      c != NULL;
      c = c->next) {
    if(c != &killall_command && process_is_running(c->process)) {
 8000c92:	687a      	ldr	r2, [r7, #4]
 8000c94:	f240 5318 	movw	r3, #1304	; 0x518
 8000c98:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c9c:	429a      	cmp	r2, r3
 8000c9e:	d00a      	beq.n	8000cb6 <killall+0x3e>
 8000ca0:	687b      	ldr	r3, [r7, #4]
 8000ca2:	68db      	ldr	r3, [r3, #12]
 8000ca4:	4618      	mov	r0, r3
 8000ca6:	f003 fb3f 	bl	8004328 <process_is_running>
 8000caa:	4603      	mov	r3, r0
 8000cac:	2b00      	cmp	r3, #0
 8000cae:	d002      	beq.n	8000cb6 <killall+0x3e>
      command_kill(c);
 8000cb0:	6878      	ldr	r0, [r7, #4]
 8000cb2:	f7ff ffc3 	bl	8000c3c <command_kill>
killall(void)
{
  struct shell_command *c;
  for(c = list_head(commands);
      c != NULL;
      c = c->next) {
 8000cb6:	687b      	ldr	r3, [r7, #4]
 8000cb8:	681b      	ldr	r3, [r3, #0]
 8000cba:	607b      	str	r3, [r7, #4]
/*---------------------------------------------------------------------------*/
static void
killall(void)
{
  struct shell_command *c;
  for(c = list_head(commands);
 8000cbc:	687b      	ldr	r3, [r7, #4]
 8000cbe:	2b00      	cmp	r3, #0
 8000cc0:	d1e7      	bne.n	8000c92 <killall+0x1a>
      c = c->next) {
    if(c != &killall_command && process_is_running(c->process)) {
      command_kill(c);
    }
  }
}
 8000cc2:	f107 0708 	add.w	r7, r7, #8
 8000cc6:	46bd      	mov	sp, r7
 8000cc8:	bd80      	pop	{r7, pc}
 8000cca:	bf00      	nop

08000ccc <process_thread_shell_killall_process>:
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_killall_process, ev, data)
{
 8000ccc:	b580      	push	{r7, lr}
 8000cce:	b086      	sub	sp, #24
 8000cd0:	af00      	add	r7, sp, #0
 8000cd2:	60f8      	str	r0, [r7, #12]
 8000cd4:	460b      	mov	r3, r1
 8000cd6:	607a      	str	r2, [r7, #4]
 8000cd8:	72fb      	strb	r3, [r7, #11]

  PROCESS_BEGIN();
 8000cda:	2301      	movs	r3, #1
 8000cdc:	75fb      	strb	r3, [r7, #23]
 8000cde:	68fb      	ldr	r3, [r7, #12]
 8000ce0:	881b      	ldrh	r3, [r3, #0]
 8000ce2:	2b00      	cmp	r3, #0
 8000ce4:	d101      	bne.n	8000cea <process_thread_shell_killall_process+0x1e>

  killall();
 8000ce6:	f7ff ffc7 	bl	8000c78 <killall>
  
  PROCESS_END();
 8000cea:	2300      	movs	r3, #0
 8000cec:	75fb      	strb	r3, [r7, #23]
 8000cee:	68fb      	ldr	r3, [r7, #12]
 8000cf0:	2200      	movs	r2, #0
 8000cf2:	801a      	strh	r2, [r3, #0]
 8000cf4:	2303      	movs	r3, #3
}
 8000cf6:	4618      	mov	r0, r3
 8000cf8:	f107 0718 	add.w	r7, r7, #24
 8000cfc:	46bd      	mov	sp, r7
 8000cfe:	bd80      	pop	{r7, pc}

08000d00 <process_thread_shell_kill_process>:
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_kill_process, ev, data)
{
 8000d00:	b580      	push	{r7, lr}
 8000d02:	b088      	sub	sp, #32
 8000d04:	af00      	add	r7, sp, #0
 8000d06:	60f8      	str	r0, [r7, #12]
 8000d08:	460b      	mov	r3, r1
 8000d0a:	607a      	str	r2, [r7, #4]
 8000d0c:	72fb      	strb	r3, [r7, #11]
  struct shell_command *c;
  char *name;
  PROCESS_BEGIN();
 8000d0e:	2301      	movs	r3, #1
 8000d10:	76fb      	strb	r3, [r7, #27]
 8000d12:	68fb      	ldr	r3, [r7, #12]
 8000d14:	881b      	ldrh	r3, [r3, #0]
 8000d16:	2b00      	cmp	r3, #0
 8000d18:	d151      	bne.n	8000dbe <process_thread_shell_kill_process+0xbe>

  name = data;
 8000d1a:	687b      	ldr	r3, [r7, #4]
 8000d1c:	617b      	str	r3, [r7, #20]
  if(name == NULL || strlen(name) == 0) {
 8000d1e:	697b      	ldr	r3, [r7, #20]
 8000d20:	2b00      	cmp	r3, #0
 8000d22:	d003      	beq.n	8000d2c <process_thread_shell_kill_process+0x2c>
 8000d24:	697b      	ldr	r3, [r7, #20]
 8000d26:	781b      	ldrb	r3, [r3, #0]
 8000d28:	2b00      	cmp	r3, #0
 8000d2a:	d10d      	bne.n	8000d48 <process_thread_shell_kill_process+0x48>
    shell_output_str(&kill_command,
 8000d2c:	f240 503c 	movw	r0, #1340	; 0x53c
 8000d30:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000d34:	f648 11e8 	movw	r1, #35304	; 0x89e8
 8000d38:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000d3c:	f648 2214 	movw	r2, #35348	; 0x8a14
 8000d40:	f6c0 0200 	movt	r2, #2048	; 0x800
 8000d44:	f000 fa72 	bl	800122c <shell_output_str>
		     "kill <command>: command name must be given", "");
  }

  for(c = list_head(commands);
 8000d48:	f240 43ac 	movw	r3, #1196	; 0x4ac
 8000d4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000d50:	681b      	ldr	r3, [r3, #0]
 8000d52:	4618      	mov	r0, r3
 8000d54:	f003 fb24 	bl	80043a0 <list_head>
 8000d58:	61f8      	str	r0, [r7, #28]
 8000d5a:	e022      	b.n	8000da2 <process_thread_shell_kill_process+0xa2>
      c != NULL;
      c = c->next) {
    if(strcmp(name, c->command) == 0 &&
 8000d5c:	69fb      	ldr	r3, [r7, #28]
 8000d5e:	685b      	ldr	r3, [r3, #4]
 8000d60:	6978      	ldr	r0, [r7, #20]
 8000d62:	4619      	mov	r1, r3
 8000d64:	f7ff faef 	bl	8000346 <strcmp>
 8000d68:	4603      	mov	r3, r0
 8000d6a:	2b00      	cmp	r3, #0
 8000d6c:	d116      	bne.n	8000d9c <process_thread_shell_kill_process+0x9c>
 8000d6e:	69fa      	ldr	r2, [r7, #28]
 8000d70:	f240 533c 	movw	r3, #1340	; 0x53c
 8000d74:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000d78:	429a      	cmp	r2, r3
 8000d7a:	d00f      	beq.n	8000d9c <process_thread_shell_kill_process+0x9c>
       c != &kill_command &&
       process_is_running(c->process)) {
 8000d7c:	69fb      	ldr	r3, [r7, #28]
 8000d7e:	68db      	ldr	r3, [r3, #12]
 8000d80:	4618      	mov	r0, r3
 8000d82:	f003 fad1 	bl	8004328 <process_is_running>
 8000d86:	4603      	mov	r3, r0

  for(c = list_head(commands);
      c != NULL;
      c = c->next) {
    if(strcmp(name, c->command) == 0 &&
       c != &kill_command &&
 8000d88:	2b00      	cmp	r3, #0
 8000d8a:	d007      	beq.n	8000d9c <process_thread_shell_kill_process+0x9c>
       process_is_running(c->process)) {
      command_kill(c);
 8000d8c:	69f8      	ldr	r0, [r7, #28]
 8000d8e:	f7ff ff55 	bl	8000c3c <command_kill>
      PROCESS_EXIT();
 8000d92:	68fb      	ldr	r3, [r7, #12]
 8000d94:	2200      	movs	r2, #0
 8000d96:	801a      	strh	r2, [r3, #0]
 8000d98:	2302      	movs	r3, #2
 8000d9a:	e016      	b.n	8000dca <process_thread_shell_kill_process+0xca>
		     "kill <command>: command name must be given", "");
  }

  for(c = list_head(commands);
      c != NULL;
      c = c->next) {
 8000d9c:	69fb      	ldr	r3, [r7, #28]
 8000d9e:	681b      	ldr	r3, [r3, #0]
 8000da0:	61fb      	str	r3, [r7, #28]
  if(name == NULL || strlen(name) == 0) {
    shell_output_str(&kill_command,
		     "kill <command>: command name must be given", "");
  }

  for(c = list_head(commands);
 8000da2:	69fb      	ldr	r3, [r7, #28]
 8000da4:	2b00      	cmp	r3, #0
 8000da6:	d1d9      	bne.n	8000d5c <process_thread_shell_kill_process+0x5c>
      command_kill(c);
      PROCESS_EXIT();
    }
  }

  shell_output_str(&kill_command, "Command not found: ", name);
 8000da8:	f240 503c 	movw	r0, #1340	; 0x53c
 8000dac:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000db0:	f648 2118 	movw	r1, #35352	; 0x8a18
 8000db4:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000db8:	697a      	ldr	r2, [r7, #20]
 8000dba:	f000 fa37 	bl	800122c <shell_output_str>
  
  PROCESS_END();
 8000dbe:	2300      	movs	r3, #0
 8000dc0:	76fb      	strb	r3, [r7, #27]
 8000dc2:	68fb      	ldr	r3, [r7, #12]
 8000dc4:	2200      	movs	r2, #0
 8000dc6:	801a      	strh	r2, [r3, #0]
 8000dc8:	2303      	movs	r3, #3
}
 8000dca:	4618      	mov	r0, r3
 8000dcc:	f107 0720 	add.w	r7, r7, #32
 8000dd0:	46bd      	mov	sp, r7
 8000dd2:	bd80      	pop	{r7, pc}

08000dd4 <process_thread_help_command_process>:
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(help_command_process, ev, data)
{
 8000dd4:	b580      	push	{r7, lr}
 8000dd6:	b086      	sub	sp, #24
 8000dd8:	af00      	add	r7, sp, #0
 8000dda:	60f8      	str	r0, [r7, #12]
 8000ddc:	460b      	mov	r3, r1
 8000dde:	607a      	str	r2, [r7, #4]
 8000de0:	72fb      	strb	r3, [r7, #11]
  struct shell_command *c;
  PROCESS_BEGIN();
 8000de2:	2301      	movs	r3, #1
 8000de4:	74fb      	strb	r3, [r7, #19]
 8000de6:	68fb      	ldr	r3, [r7, #12]
 8000de8:	881b      	ldrh	r3, [r3, #0]
 8000dea:	2b00      	cmp	r3, #0
 8000dec:	d12a      	bne.n	8000e44 <process_thread_help_command_process+0x70>

  shell_output_str(&help_command, "Available commands:", "");
 8000dee:	f240 40e0 	movw	r0, #1248	; 0x4e0
 8000df2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000df6:	f648 212c 	movw	r1, #35372	; 0x8a2c
 8000dfa:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000dfe:	f648 2214 	movw	r2, #35348	; 0x8a14
 8000e02:	f6c0 0200 	movt	r2, #2048	; 0x800
 8000e06:	f000 fa11 	bl	800122c <shell_output_str>
  for(c = list_head(commands);
 8000e0a:	f240 43ac 	movw	r3, #1196	; 0x4ac
 8000e0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000e12:	681b      	ldr	r3, [r3, #0]
 8000e14:	4618      	mov	r0, r3
 8000e16:	f003 fac3 	bl	80043a0 <list_head>
 8000e1a:	6178      	str	r0, [r7, #20]
 8000e1c:	e00f      	b.n	8000e3e <process_thread_help_command_process+0x6a>
      c != NULL;
      c = c->next) {
    shell_output_str(&help_command, c->description, "");
 8000e1e:	697b      	ldr	r3, [r7, #20]
 8000e20:	689b      	ldr	r3, [r3, #8]
 8000e22:	f240 40e0 	movw	r0, #1248	; 0x4e0
 8000e26:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000e2a:	4619      	mov	r1, r3
 8000e2c:	f648 2214 	movw	r2, #35348	; 0x8a14
 8000e30:	f6c0 0200 	movt	r2, #2048	; 0x800
 8000e34:	f000 f9fa 	bl	800122c <shell_output_str>
  PROCESS_BEGIN();

  shell_output_str(&help_command, "Available commands:", "");
  for(c = list_head(commands);
      c != NULL;
      c = c->next) {
 8000e38:	697b      	ldr	r3, [r7, #20]
 8000e3a:	681b      	ldr	r3, [r3, #0]
 8000e3c:	617b      	str	r3, [r7, #20]
{
  struct shell_command *c;
  PROCESS_BEGIN();

  shell_output_str(&help_command, "Available commands:", "");
  for(c = list_head(commands);
 8000e3e:	697b      	ldr	r3, [r7, #20]
 8000e40:	2b00      	cmp	r3, #0
 8000e42:	d1ec      	bne.n	8000e1e <process_thread_help_command_process+0x4a>
      c != NULL;
      c = c->next) {
    shell_output_str(&help_command, c->description, "");
  }

  PROCESS_END();
 8000e44:	2300      	movs	r3, #0
 8000e46:	74fb      	strb	r3, [r7, #19]
 8000e48:	68fb      	ldr	r3, [r7, #12]
 8000e4a:	2200      	movs	r2, #0
 8000e4c:	801a      	strh	r2, [r3, #0]
 8000e4e:	2303      	movs	r3, #3
}
 8000e50:	4618      	mov	r0, r3
 8000e52:	f107 0718 	add.w	r7, r7, #24
 8000e56:	46bd      	mov	sp, r7
 8000e58:	bd80      	pop	{r7, pc}
 8000e5a:	bf00      	nop

08000e5c <process_thread_shell_exit_process>:
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_exit_process, ev, data)
{
 8000e5c:	b580      	push	{r7, lr}
 8000e5e:	b086      	sub	sp, #24
 8000e60:	af00      	add	r7, sp, #0
 8000e62:	60f8      	str	r0, [r7, #12]
 8000e64:	460b      	mov	r3, r1
 8000e66:	607a      	str	r2, [r7, #4]
 8000e68:	72fb      	strb	r3, [r7, #11]
  PROCESS_BEGIN();
 8000e6a:	2301      	movs	r3, #1
 8000e6c:	75fb      	strb	r3, [r7, #23]
 8000e6e:	68fb      	ldr	r3, [r7, #12]
 8000e70:	881b      	ldrh	r3, [r3, #0]
 8000e72:	2b00      	cmp	r3, #0
 8000e74:	d101      	bne.n	8000e7a <process_thread_shell_exit_process+0x1e>

  shell_exit();
 8000e76:	f7ff fbb9 	bl	80005ec <shell_exit>

  PROCESS_END();
 8000e7a:	2300      	movs	r3, #0
 8000e7c:	75fb      	strb	r3, [r7, #23]
 8000e7e:	68fb      	ldr	r3, [r7, #12]
 8000e80:	2200      	movs	r2, #0
 8000e82:	801a      	strh	r2, [r3, #0]
 8000e84:	2303      	movs	r3, #3
}
 8000e86:	4618      	mov	r0, r3
 8000e88:	f107 0718 	add.w	r7, r7, #24
 8000e8c:	46bd      	mov	sp, r7
 8000e8e:	bd80      	pop	{r7, pc}

08000e90 <replace_braces>:
/*---------------------------------------------------------------------------*/
static void
replace_braces(char *commandline)
{
 8000e90:	b480      	push	{r7}
 8000e92:	b085      	sub	sp, #20
 8000e94:	af00      	add	r7, sp, #0
 8000e96:	6078      	str	r0, [r7, #4]
  char *ptr;
  int level = 0;
 8000e98:	2300      	movs	r3, #0
 8000e9a:	60bb      	str	r3, [r7, #8]
  
  for(ptr = commandline; *ptr != 0; ++ptr) {
 8000e9c:	687b      	ldr	r3, [r7, #4]
 8000e9e:	60fb      	str	r3, [r7, #12]
 8000ea0:	e01d      	b.n	8000ede <replace_braces+0x4e>
    if(*ptr == '{') {
 8000ea2:	68fb      	ldr	r3, [r7, #12]
 8000ea4:	781b      	ldrb	r3, [r3, #0]
 8000ea6:	2b7b      	cmp	r3, #123	; 0x7b
 8000ea8:	d109      	bne.n	8000ebe <replace_braces+0x2e>
      if(level == 0) {
 8000eaa:	68bb      	ldr	r3, [r7, #8]
 8000eac:	2b00      	cmp	r3, #0
 8000eae:	d102      	bne.n	8000eb6 <replace_braces+0x26>
	*ptr = ' ';
 8000eb0:	68fb      	ldr	r3, [r7, #12]
 8000eb2:	2220      	movs	r2, #32
 8000eb4:	701a      	strb	r2, [r3, #0]
      }
      ++level;
 8000eb6:	68bb      	ldr	r3, [r7, #8]
 8000eb8:	3301      	adds	r3, #1
 8000eba:	60bb      	str	r3, [r7, #8]
 8000ebc:	e00c      	b.n	8000ed8 <replace_braces+0x48>
    } else if(*ptr == '}') {
 8000ebe:	68fb      	ldr	r3, [r7, #12]
 8000ec0:	781b      	ldrb	r3, [r3, #0]
 8000ec2:	2b7d      	cmp	r3, #125	; 0x7d
 8000ec4:	d108      	bne.n	8000ed8 <replace_braces+0x48>
      --level;
 8000ec6:	68bb      	ldr	r3, [r7, #8]
 8000ec8:	3b01      	subs	r3, #1
 8000eca:	60bb      	str	r3, [r7, #8]
      if(level == 0) {
 8000ecc:	68bb      	ldr	r3, [r7, #8]
 8000ece:	2b00      	cmp	r3, #0
 8000ed0:	d102      	bne.n	8000ed8 <replace_braces+0x48>
	*ptr = ' ';
 8000ed2:	68fb      	ldr	r3, [r7, #12]
 8000ed4:	2220      	movs	r2, #32
 8000ed6:	701a      	strb	r2, [r3, #0]
replace_braces(char *commandline)
{
  char *ptr;
  int level = 0;
  
  for(ptr = commandline; *ptr != 0; ++ptr) {
 8000ed8:	68fb      	ldr	r3, [r7, #12]
 8000eda:	3301      	adds	r3, #1
 8000edc:	60fb      	str	r3, [r7, #12]
 8000ede:	68fb      	ldr	r3, [r7, #12]
 8000ee0:	781b      	ldrb	r3, [r3, #0]
 8000ee2:	2b00      	cmp	r3, #0
 8000ee4:	d1dd      	bne.n	8000ea2 <replace_braces+0x12>
      if(level == 0) {
	*ptr = ' ';
      }
    }
  }
}
 8000ee6:	f107 0714 	add.w	r7, r7, #20
 8000eea:	46bd      	mov	sp, r7
 8000eec:	bc80      	pop	{r7}
 8000eee:	4770      	bx	lr

08000ef0 <find_pipe>:
/*---------------------------------------------------------------------------*/
static char *
find_pipe(char *commandline)
{
 8000ef0:	b480      	push	{r7}
 8000ef2:	b085      	sub	sp, #20
 8000ef4:	af00      	add	r7, sp, #0
 8000ef6:	6078      	str	r0, [r7, #4]
  char *ptr;
  int level = 0;
 8000ef8:	2300      	movs	r3, #0
 8000efa:	60bb      	str	r3, [r7, #8]
  
  for(ptr = commandline; *ptr != 0; ++ptr) {
 8000efc:	687b      	ldr	r3, [r7, #4]
 8000efe:	60fb      	str	r3, [r7, #12]
 8000f00:	e01b      	b.n	8000f3a <find_pipe+0x4a>
    if(*ptr == '{') {
 8000f02:	68fb      	ldr	r3, [r7, #12]
 8000f04:	781b      	ldrb	r3, [r3, #0]
 8000f06:	2b7b      	cmp	r3, #123	; 0x7b
 8000f08:	d103      	bne.n	8000f12 <find_pipe+0x22>
      ++level;
 8000f0a:	68bb      	ldr	r3, [r7, #8]
 8000f0c:	3301      	adds	r3, #1
 8000f0e:	60bb      	str	r3, [r7, #8]
 8000f10:	e010      	b.n	8000f34 <find_pipe+0x44>
    } else if(*ptr == '}') {
 8000f12:	68fb      	ldr	r3, [r7, #12]
 8000f14:	781b      	ldrb	r3, [r3, #0]
 8000f16:	2b7d      	cmp	r3, #125	; 0x7d
 8000f18:	d103      	bne.n	8000f22 <find_pipe+0x32>
      --level;
 8000f1a:	68bb      	ldr	r3, [r7, #8]
 8000f1c:	3b01      	subs	r3, #1
 8000f1e:	60bb      	str	r3, [r7, #8]
 8000f20:	e008      	b.n	8000f34 <find_pipe+0x44>
    } else if(*ptr == '|') {
 8000f22:	68fb      	ldr	r3, [r7, #12]
 8000f24:	781b      	ldrb	r3, [r3, #0]
 8000f26:	2b7c      	cmp	r3, #124	; 0x7c
 8000f28:	d104      	bne.n	8000f34 <find_pipe+0x44>
      if(level == 0) {
 8000f2a:	68bb      	ldr	r3, [r7, #8]
 8000f2c:	2b00      	cmp	r3, #0
 8000f2e:	d101      	bne.n	8000f34 <find_pipe+0x44>
	return ptr;
 8000f30:	68fb      	ldr	r3, [r7, #12]
 8000f32:	e007      	b.n	8000f44 <find_pipe+0x54>
find_pipe(char *commandline)
{
  char *ptr;
  int level = 0;
  
  for(ptr = commandline; *ptr != 0; ++ptr) {
 8000f34:	68fb      	ldr	r3, [r7, #12]
 8000f36:	3301      	adds	r3, #1
 8000f38:	60fb      	str	r3, [r7, #12]
 8000f3a:	68fb      	ldr	r3, [r7, #12]
 8000f3c:	781b      	ldrb	r3, [r3, #0]
 8000f3e:	2b00      	cmp	r3, #0
 8000f40:	d1df      	bne.n	8000f02 <find_pipe+0x12>
      if(level == 0) {
	return ptr;
      }
    }
  }
  return NULL;
 8000f42:	2300      	movs	r3, #0
}
 8000f44:	4618      	mov	r0, r3
 8000f46:	f107 0714 	add.w	r7, r7, #20
 8000f4a:	46bd      	mov	sp, r7
 8000f4c:	bc80      	pop	{r7}
 8000f4e:	4770      	bx	lr

08000f50 <start_command>:
/*---------------------------------------------------------------------------*/
static struct shell_command *
start_command(char *commandline, struct shell_command *child)
{
 8000f50:	b580      	push	{r7, lr}
 8000f52:	b086      	sub	sp, #24
 8000f54:	af00      	add	r7, sp, #0
 8000f56:	6078      	str	r0, [r7, #4]
 8000f58:	6039      	str	r1, [r7, #0]
  char *next, *args;
  int command_len;
  struct shell_command *c;

  /* Shave off any leading spaces. */
  while(*commandline == ' ') {
 8000f5a:	e002      	b.n	8000f62 <start_command+0x12>
    commandline++;
 8000f5c:	687b      	ldr	r3, [r7, #4]
 8000f5e:	3301      	adds	r3, #1
 8000f60:	607b      	str	r3, [r7, #4]
  char *next, *args;
  int command_len;
  struct shell_command *c;

  /* Shave off any leading spaces. */
  while(*commandline == ' ') {
 8000f62:	687b      	ldr	r3, [r7, #4]
 8000f64:	781b      	ldrb	r3, [r3, #0]
 8000f66:	2b20      	cmp	r3, #32
 8000f68:	d0f8      	beq.n	8000f5c <start_command+0xc>
    commandline++;
  }

  /* Find the next command in a pipeline and start it. */
  next = find_pipe(commandline);
 8000f6a:	6878      	ldr	r0, [r7, #4]
 8000f6c:	f7ff ffc0 	bl	8000ef0 <find_pipe>
 8000f70:	60b8      	str	r0, [r7, #8]
  if(next != NULL) {
 8000f72:	68bb      	ldr	r3, [r7, #8]
 8000f74:	2b00      	cmp	r3, #0
 8000f76:	d009      	beq.n	8000f8c <start_command+0x3c>
    *next = 0;
 8000f78:	68bb      	ldr	r3, [r7, #8]
 8000f7a:	2200      	movs	r2, #0
 8000f7c:	701a      	strb	r2, [r3, #0]
    child = start_command(next + 1, child);
 8000f7e:	68bb      	ldr	r3, [r7, #8]
 8000f80:	3301      	adds	r3, #1
 8000f82:	4618      	mov	r0, r3
 8000f84:	6839      	ldr	r1, [r7, #0]
 8000f86:	f7ff ffe3 	bl	8000f50 <start_command>
 8000f8a:	6038      	str	r0, [r7, #0]
  }

  /* Separate the command arguments, and remove braces. */
  replace_braces(commandline);
 8000f8c:	6878      	ldr	r0, [r7, #4]
 8000f8e:	f7ff ff7f 	bl	8000e90 <replace_braces>
  args = strchr(commandline, ' ');
 8000f92:	6878      	ldr	r0, [r7, #4]
 8000f94:	2120      	movs	r1, #32
 8000f96:	f7ff f9c9 	bl	800032c <strchr>
 8000f9a:	6178      	str	r0, [r7, #20]
  if(args != NULL) {
 8000f9c:	697b      	ldr	r3, [r7, #20]
 8000f9e:	2b00      	cmp	r3, #0
 8000fa0:	d002      	beq.n	8000fa8 <start_command+0x58>
    args++;
 8000fa2:	697b      	ldr	r3, [r7, #20]
 8000fa4:	3301      	adds	r3, #1
 8000fa6:	617b      	str	r3, [r7, #20]
  }

  /* Shave off any trailing spaces. */
  command_len = (int)strlen(commandline);
 8000fa8:	6878      	ldr	r0, [r7, #4]
 8000faa:	f7ff f9d7 	bl	800035c <strlen>
 8000fae:	4603      	mov	r3, r0
 8000fb0:	613b      	str	r3, [r7, #16]
  while(command_len > 0 && commandline[command_len - 1] == ' ') {
 8000fb2:	e008      	b.n	8000fc6 <start_command+0x76>
    commandline[command_len - 1] = 0;
 8000fb4:	693b      	ldr	r3, [r7, #16]
 8000fb6:	3b01      	subs	r3, #1
 8000fb8:	687a      	ldr	r2, [r7, #4]
 8000fba:	18d3      	adds	r3, r2, r3
 8000fbc:	2200      	movs	r2, #0
 8000fbe:	701a      	strb	r2, [r3, #0]
    command_len--;
 8000fc0:	693b      	ldr	r3, [r7, #16]
 8000fc2:	3b01      	subs	r3, #1
 8000fc4:	613b      	str	r3, [r7, #16]
    args++;
  }

  /* Shave off any trailing spaces. */
  command_len = (int)strlen(commandline);
  while(command_len > 0 && commandline[command_len - 1] == ' ') {
 8000fc6:	693b      	ldr	r3, [r7, #16]
 8000fc8:	2b00      	cmp	r3, #0
 8000fca:	dd06      	ble.n	8000fda <start_command+0x8a>
 8000fcc:	693b      	ldr	r3, [r7, #16]
 8000fce:	3b01      	subs	r3, #1
 8000fd0:	687a      	ldr	r2, [r7, #4]
 8000fd2:	18d3      	adds	r3, r2, r3
 8000fd4:	781b      	ldrb	r3, [r3, #0]
 8000fd6:	2b20      	cmp	r3, #32
 8000fd8:	d0ec      	beq.n	8000fb4 <start_command+0x64>
    commandline[command_len - 1] = 0;
    command_len--;
  }
  
  if(args == NULL) {
 8000fda:	697b      	ldr	r3, [r7, #20]
 8000fdc:	2b00      	cmp	r3, #0
 8000fde:	d109      	bne.n	8000ff4 <start_command+0xa4>
    command_len = (int)strlen(commandline);
 8000fe0:	6878      	ldr	r0, [r7, #4]
 8000fe2:	f7ff f9bb 	bl	800035c <strlen>
 8000fe6:	4603      	mov	r3, r0
 8000fe8:	613b      	str	r3, [r7, #16]
    args = &commandline[command_len];
 8000fea:	693b      	ldr	r3, [r7, #16]
 8000fec:	687a      	ldr	r2, [r7, #4]
 8000fee:	18d3      	adds	r3, r2, r3
 8000ff0:	617b      	str	r3, [r7, #20]
 8000ff2:	e004      	b.n	8000ffe <start_command+0xae>
  } else {
    command_len = (int)(args - commandline - 1);
 8000ff4:	697a      	ldr	r2, [r7, #20]
 8000ff6:	687b      	ldr	r3, [r7, #4]
 8000ff8:	1ad3      	subs	r3, r2, r3
 8000ffa:	3b01      	subs	r3, #1
 8000ffc:	613b      	str	r3, [r7, #16]
  

  
  /* Go through list of commands to find a match for the first word in
     the command line. */
  for(c = list_head(commands);
 8000ffe:	f240 43ac 	movw	r3, #1196	; 0x4ac
 8001002:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001006:	681b      	ldr	r3, [r3, #0]
 8001008:	4618      	mov	r0, r3
 800100a:	f003 f9c9 	bl	80043a0 <list_head>
 800100e:	60f8      	str	r0, [r7, #12]
 8001010:	e002      	b.n	8001018 <start_command+0xc8>
      c != NULL &&
	!(strncmp(c->command, commandline, command_len) == 0 &&
	  c->command[command_len] == 0);
      c = c->next);
 8001012:	68fb      	ldr	r3, [r7, #12]
 8001014:	681b      	ldr	r3, [r3, #0]
 8001016:	60fb      	str	r3, [r7, #12]
  

  
  /* Go through list of commands to find a match for the first word in
     the command line. */
  for(c = list_head(commands);
 8001018:	68fb      	ldr	r3, [r7, #12]
 800101a:	2b00      	cmp	r3, #0
 800101c:	d011      	beq.n	8001042 <start_command+0xf2>
      c != NULL &&
	!(strncmp(c->command, commandline, command_len) == 0 &&
 800101e:	68fb      	ldr	r3, [r7, #12]
 8001020:	685a      	ldr	r2, [r3, #4]
 8001022:	693b      	ldr	r3, [r7, #16]
 8001024:	4610      	mov	r0, r2
 8001026:	6879      	ldr	r1, [r7, #4]
 8001028:	461a      	mov	r2, r3
 800102a:	f7ff f99f 	bl	800036c <strncmp>
 800102e:	4603      	mov	r3, r0

  
  /* Go through list of commands to find a match for the first word in
     the command line. */
  for(c = list_head(commands);
      c != NULL &&
 8001030:	2b00      	cmp	r3, #0
 8001032:	d1ee      	bne.n	8001012 <start_command+0xc2>
	!(strncmp(c->command, commandline, command_len) == 0 &&
	  c->command[command_len] == 0);
 8001034:	68fb      	ldr	r3, [r7, #12]
 8001036:	685a      	ldr	r2, [r3, #4]
 8001038:	693b      	ldr	r3, [r7, #16]
 800103a:	18d3      	adds	r3, r2, r3
 800103c:	781b      	ldrb	r3, [r3, #0]
  
  /* Go through list of commands to find a match for the first word in
     the command line. */
  for(c = list_head(commands);
      c != NULL &&
	!(strncmp(c->command, commandline, command_len) == 0 &&
 800103e:	2b00      	cmp	r3, #0
 8001040:	d1e7      	bne.n	8001012 <start_command+0xc2>
	  c->command[command_len] == 0);
      c = c->next);
  
  if(c == NULL) {
 8001042:	68fb      	ldr	r3, [r7, #12]
 8001044:	2b00      	cmp	r3, #0
 8001046:	d10d      	bne.n	8001064 <start_command+0x114>
    shell_output_str(NULL, commandline, ": command not found (try 'help')");
 8001048:	2000      	movs	r0, #0
 800104a:	6879      	ldr	r1, [r7, #4]
 800104c:	f648 2240 	movw	r2, #35392	; 0x8a40
 8001050:	f6c0 0200 	movt	r2, #2048	; 0x800
 8001054:	f000 f8ea 	bl	800122c <shell_output_str>
    command_kill(child);
 8001058:	6838      	ldr	r0, [r7, #0]
 800105a:	f7ff fdef 	bl	8000c3c <command_kill>
    c = NULL;
 800105e:	2300      	movs	r3, #0
 8001060:	60fb      	str	r3, [r7, #12]
 8001062:	e022      	b.n	80010aa <start_command+0x15a>
  } else if(process_is_running(c->process) || child == c) {
 8001064:	68fb      	ldr	r3, [r7, #12]
 8001066:	68db      	ldr	r3, [r3, #12]
 8001068:	4618      	mov	r0, r3
 800106a:	f003 f95d 	bl	8004328 <process_is_running>
 800106e:	4603      	mov	r3, r0
 8001070:	2b00      	cmp	r3, #0
 8001072:	d103      	bne.n	800107c <start_command+0x12c>
 8001074:	683a      	ldr	r2, [r7, #0]
 8001076:	68fb      	ldr	r3, [r7, #12]
 8001078:	429a      	cmp	r2, r3
 800107a:	d10d      	bne.n	8001098 <start_command+0x148>
    shell_output_str(NULL, commandline, ": command already running");
 800107c:	2000      	movs	r0, #0
 800107e:	6879      	ldr	r1, [r7, #4]
 8001080:	f648 2264 	movw	r2, #35428	; 0x8a64
 8001084:	f6c0 0200 	movt	r2, #2048	; 0x800
 8001088:	f000 f8d0 	bl	800122c <shell_output_str>
    c->child = NULL;
 800108c:	68fb      	ldr	r3, [r7, #12]
 800108e:	2200      	movs	r2, #0
 8001090:	611a      	str	r2, [r3, #16]
    c = NULL;
 8001092:	2300      	movs	r3, #0
 8001094:	60fb      	str	r3, [r7, #12]
 8001096:	e008      	b.n	80010aa <start_command+0x15a>
  } else {
    c->child = child;
 8001098:	68fb      	ldr	r3, [r7, #12]
 800109a:	683a      	ldr	r2, [r7, #0]
 800109c:	611a      	str	r2, [r3, #16]
    /*    printf("shell: start_command starting '%s'\n", c->process->name);*/
    /* Start a new process for the command. */
    process_start(c->process, args);
 800109e:	68fb      	ldr	r3, [r7, #12]
 80010a0:	68db      	ldr	r3, [r3, #12]
 80010a2:	4618      	mov	r0, r3
 80010a4:	6979      	ldr	r1, [r7, #20]
 80010a6:	f002 fe53 	bl	8003d50 <process_start>
  }
  
  return c;
 80010aa:	68fb      	ldr	r3, [r7, #12]
}
 80010ac:	4618      	mov	r0, r3
 80010ae:	f107 0718 	add.w	r7, r7, #24
 80010b2:	46bd      	mov	sp, r7
 80010b4:	bd80      	pop	{r7, pc}
 80010b6:	bf00      	nop

080010b8 <shell_start_command>:
/*---------------------------------------------------------------------------*/
int
shell_start_command(char *commandline, int commandline_len,
		    struct shell_command *child,
		    struct process **started_process)
{
 80010b8:	b580      	push	{r7, lr}
 80010ba:	b086      	sub	sp, #24
 80010bc:	af00      	add	r7, sp, #0
 80010be:	60f8      	str	r0, [r7, #12]
 80010c0:	60b9      	str	r1, [r7, #8]
 80010c2:	607a      	str	r2, [r7, #4]
 80010c4:	603b      	str	r3, [r7, #0]
  struct shell_command *c;
  int background = 0;
 80010c6:	2300      	movs	r3, #0
 80010c8:	617b      	str	r3, [r7, #20]

  if(commandline_len == 0) {
 80010ca:	68bb      	ldr	r3, [r7, #8]
 80010cc:	2b00      	cmp	r3, #0
 80010ce:	d107      	bne.n	80010e0 <shell_start_command+0x28>
    if(started_process != NULL) {
 80010d0:	683b      	ldr	r3, [r7, #0]
 80010d2:	2b00      	cmp	r3, #0
 80010d4:	d002      	beq.n	80010dc <shell_start_command+0x24>
      *started_process = NULL;
 80010d6:	683b      	ldr	r3, [r7, #0]
 80010d8:	2200      	movs	r2, #0
 80010da:	601a      	str	r2, [r3, #0]
    }
    return SHELL_NOTHING;
 80010dc:	2302      	movs	r3, #2
 80010de:	e028      	b.n	8001132 <shell_start_command+0x7a>
  }

  if(commandline[commandline_len - 1] == '&') {
 80010e0:	68bb      	ldr	r3, [r7, #8]
 80010e2:	3b01      	subs	r3, #1
 80010e4:	68fa      	ldr	r2, [r7, #12]
 80010e6:	18d3      	adds	r3, r2, r3
 80010e8:	781b      	ldrb	r3, [r3, #0]
 80010ea:	2b26      	cmp	r3, #38	; 0x26
 80010ec:	d10a      	bne.n	8001104 <shell_start_command+0x4c>
    commandline[commandline_len - 1] = 0;
 80010ee:	68bb      	ldr	r3, [r7, #8]
 80010f0:	3b01      	subs	r3, #1
 80010f2:	68fa      	ldr	r2, [r7, #12]
 80010f4:	18d3      	adds	r3, r2, r3
 80010f6:	2200      	movs	r2, #0
 80010f8:	701a      	strb	r2, [r3, #0]
    background = 1;
 80010fa:	2301      	movs	r3, #1
 80010fc:	617b      	str	r3, [r7, #20]
    commandline_len--;
 80010fe:	68bb      	ldr	r3, [r7, #8]
 8001100:	3b01      	subs	r3, #1
 8001102:	60bb      	str	r3, [r7, #8]
  }

  c = start_command(commandline, child);
 8001104:	68f8      	ldr	r0, [r7, #12]
 8001106:	6879      	ldr	r1, [r7, #4]
 8001108:	f7ff ff22 	bl	8000f50 <start_command>
 800110c:	6138      	str	r0, [r7, #16]

  /* Return a pointer to the started process, so that the caller can
     wait for the process to complete. */
  if(c != NULL && started_process != NULL) {
 800110e:	693b      	ldr	r3, [r7, #16]
 8001110:	2b00      	cmp	r3, #0
 8001112:	d00d      	beq.n	8001130 <shell_start_command+0x78>
 8001114:	683b      	ldr	r3, [r7, #0]
 8001116:	2b00      	cmp	r3, #0
 8001118:	d00a      	beq.n	8001130 <shell_start_command+0x78>
    *started_process = c->process;
 800111a:	693b      	ldr	r3, [r7, #16]
 800111c:	68da      	ldr	r2, [r3, #12]
 800111e:	683b      	ldr	r3, [r7, #0]
 8001120:	601a      	str	r2, [r3, #0]
    if(background) {
 8001122:	697b      	ldr	r3, [r7, #20]
 8001124:	2b00      	cmp	r3, #0
 8001126:	d001      	beq.n	800112c <shell_start_command+0x74>
      return SHELL_BACKGROUND;
 8001128:	2301      	movs	r3, #1
 800112a:	e002      	b.n	8001132 <shell_start_command+0x7a>
    } else {
      return SHELL_FOREGROUND;
 800112c:	2300      	movs	r3, #0
 800112e:	e000      	b.n	8001132 <shell_start_command+0x7a>
    }
  }
  return SHELL_NOTHING;
 8001130:	2302      	movs	r3, #2
}
 8001132:	4618      	mov	r0, r3
 8001134:	f107 0718 	add.w	r7, r7, #24
 8001138:	46bd      	mov	sp, r7
 800113a:	bd80      	pop	{r7, pc}

0800113c <input_to_child_command>:
/*---------------------------------------------------------------------------*/
static void
input_to_child_command(struct shell_command *c,
		       char *data1, int len1,
		       const char *data2, int len2)
{
 800113c:	b580      	push	{r7, lr}
 800113e:	b088      	sub	sp, #32
 8001140:	af00      	add	r7, sp, #0
 8001142:	60f8      	str	r0, [r7, #12]
 8001144:	60b9      	str	r1, [r7, #8]
 8001146:	607a      	str	r2, [r7, #4]
 8001148:	603b      	str	r3, [r7, #0]
  struct shell_input input;
  if(process_is_running(c->process)) {
 800114a:	68fb      	ldr	r3, [r7, #12]
 800114c:	68db      	ldr	r3, [r3, #12]
 800114e:	4618      	mov	r0, r3
 8001150:	f003 f8ea 	bl	8004328 <process_is_running>
 8001154:	4603      	mov	r3, r0
 8001156:	2b00      	cmp	r3, #0
 8001158:	d016      	beq.n	8001188 <input_to_child_command+0x4c>
    input.data1 = data1;
 800115a:	68bb      	ldr	r3, [r7, #8]
 800115c:	613b      	str	r3, [r7, #16]
    input.len1 = len1;
 800115e:	687b      	ldr	r3, [r7, #4]
 8001160:	61bb      	str	r3, [r7, #24]
    input.data2 = data2;
 8001162:	683b      	ldr	r3, [r7, #0]
 8001164:	617b      	str	r3, [r7, #20]
    input.len2 = len2;
 8001166:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001168:	61fb      	str	r3, [r7, #28]
    process_post_synch(c->process, shell_event_input, &input);
 800116a:	68fb      	ldr	r3, [r7, #12]
 800116c:	68d9      	ldr	r1, [r3, #12]
 800116e:	f241 63f8 	movw	r3, #5880	; 0x16f8
 8001172:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001176:	681b      	ldr	r3, [r3, #0]
 8001178:	b2da      	uxtb	r2, r3
 800117a:	f107 0310 	add.w	r3, r7, #16
 800117e:	4608      	mov	r0, r1
 8001180:	4611      	mov	r1, r2
 8001182:	461a      	mov	r2, r3
 8001184:	f003 f894 	bl	80042b0 <process_post_synch>
  }
}
 8001188:	f107 0720 	add.w	r7, r7, #32
 800118c:	46bd      	mov	sp, r7
 800118e:	bd80      	pop	{r7, pc}

08001190 <shell_input>:
/*---------------------------------------------------------------------------*/
void
shell_input(char *commandline, int commandline_len)
{
 8001190:	b580      	push	{r7, lr}
 8001192:	b086      	sub	sp, #24
 8001194:	af00      	add	r7, sp, #0
 8001196:	6078      	str	r0, [r7, #4]
 8001198:	6039      	str	r1, [r7, #0]
  struct shell_input input;

  /*  printf("shell_input front_process '%s'\n", front_process->name);*/

  if(commandline[0] == '~' &&
 800119a:	687b      	ldr	r3, [r7, #4]
 800119c:	781b      	ldrb	r3, [r3, #0]
 800119e:	2b7e      	cmp	r3, #126	; 0x7e
 80011a0:	d118      	bne.n	80011d4 <shell_input+0x44>
     commandline[1] == 'K') {
 80011a2:	687b      	ldr	r3, [r7, #4]
 80011a4:	3301      	adds	r3, #1
 80011a6:	781b      	ldrb	r3, [r3, #0]
{
  struct shell_input input;

  /*  printf("shell_input front_process '%s'\n", front_process->name);*/

  if(commandline[0] == '~' &&
 80011a8:	2b4b      	cmp	r3, #75	; 0x4b
 80011aa:	d113      	bne.n	80011d4 <shell_input+0x44>
     commandline[1] == 'K') {
    /*    process_start(&shell_killall_process, commandline);*/
    if(front_process != &shell_process) {
 80011ac:	f241 03d4 	movw	r3, #4308	; 0x10d4
 80011b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80011b4:	681a      	ldr	r2, [r3, #0]
 80011b6:	f240 43b0 	movw	r3, #1200	; 0x4b0
 80011ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80011be:	429a      	cmp	r2, r3
 80011c0:	d030      	beq.n	8001224 <shell_input+0x94>
      process_exit(front_process);
 80011c2:	f241 03d4 	movw	r3, #4308	; 0x10d4
 80011c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80011ca:	681b      	ldr	r3, [r3, #0]
 80011cc:	4618      	mov	r0, r3
 80011ce:	f002 fead 	bl	8003f2c <process_exit>
  /*  printf("shell_input front_process '%s'\n", front_process->name);*/

  if(commandline[0] == '~' &&
     commandline[1] == 'K') {
    /*    process_start(&shell_killall_process, commandline);*/
    if(front_process != &shell_process) {
 80011d2:	e027      	b.n	8001224 <shell_input+0x94>
      process_exit(front_process);
    }
  } else {
    if(process_is_running(front_process)) {
 80011d4:	f241 03d4 	movw	r3, #4308	; 0x10d4
 80011d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80011dc:	681b      	ldr	r3, [r3, #0]
 80011de:	4618      	mov	r0, r3
 80011e0:	f003 f8a2 	bl	8004328 <process_is_running>
 80011e4:	4603      	mov	r3, r0
 80011e6:	2b00      	cmp	r3, #0
 80011e8:	d01c      	beq.n	8001224 <shell_input+0x94>
      input.data1 = commandline;
 80011ea:	687b      	ldr	r3, [r7, #4]
 80011ec:	60bb      	str	r3, [r7, #8]
      input.len1 = commandline_len;
 80011ee:	683b      	ldr	r3, [r7, #0]
 80011f0:	613b      	str	r3, [r7, #16]
      input.data2 = "";
 80011f2:	f648 2314 	movw	r3, #35348	; 0x8a14
 80011f6:	f6c0 0300 	movt	r3, #2048	; 0x800
 80011fa:	60fb      	str	r3, [r7, #12]
      input.len2 = 0;
 80011fc:	2300      	movs	r3, #0
 80011fe:	617b      	str	r3, [r7, #20]
      process_post_synch(front_process, shell_event_input, &input);
 8001200:	f241 03d4 	movw	r3, #4308	; 0x10d4
 8001204:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001208:	6819      	ldr	r1, [r3, #0]
 800120a:	f241 63f8 	movw	r3, #5880	; 0x16f8
 800120e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001212:	681b      	ldr	r3, [r3, #0]
 8001214:	b2da      	uxtb	r2, r3
 8001216:	f107 0308 	add.w	r3, r7, #8
 800121a:	4608      	mov	r0, r1
 800121c:	4611      	mov	r1, r2
 800121e:	461a      	mov	r2, r3
 8001220:	f003 f846 	bl	80042b0 <process_post_synch>
    }
  }
}
 8001224:	f107 0718 	add.w	r7, r7, #24
 8001228:	46bd      	mov	sp, r7
 800122a:	bd80      	pop	{r7, pc}

0800122c <shell_output_str>:
/*---------------------------------------------------------------------------*/
void
shell_output_str(struct shell_command *c, char *text1, const char *text2)
{
 800122c:	b5b0      	push	{r4, r5, r7, lr}
 800122e:	b086      	sub	sp, #24
 8001230:	af02      	add	r7, sp, #8
 8001232:	60f8      	str	r0, [r7, #12]
 8001234:	60b9      	str	r1, [r7, #8]
 8001236:	607a      	str	r2, [r7, #4]
  if(c != NULL && c->child != NULL) {
 8001238:	68fb      	ldr	r3, [r7, #12]
 800123a:	2b00      	cmp	r3, #0
 800123c:	d016      	beq.n	800126c <shell_output_str+0x40>
 800123e:	68fb      	ldr	r3, [r7, #12]
 8001240:	691b      	ldr	r3, [r3, #16]
 8001242:	2b00      	cmp	r3, #0
 8001244:	d012      	beq.n	800126c <shell_output_str+0x40>
    input_to_child_command(c->child, text1, (int)strlen(text1),
 8001246:	68fb      	ldr	r3, [r7, #12]
 8001248:	691d      	ldr	r5, [r3, #16]
 800124a:	68b8      	ldr	r0, [r7, #8]
 800124c:	f7ff f886 	bl	800035c <strlen>
 8001250:	4603      	mov	r3, r0
 8001252:	461c      	mov	r4, r3
			   text2, (int)strlen(text2));
 8001254:	6878      	ldr	r0, [r7, #4]
 8001256:	f7ff f881 	bl	800035c <strlen>
 800125a:	4603      	mov	r3, r0
/*---------------------------------------------------------------------------*/
void
shell_output_str(struct shell_command *c, char *text1, const char *text2)
{
  if(c != NULL && c->child != NULL) {
    input_to_child_command(c->child, text1, (int)strlen(text1),
 800125c:	9300      	str	r3, [sp, #0]
 800125e:	4628      	mov	r0, r5
 8001260:	68b9      	ldr	r1, [r7, #8]
 8001262:	4622      	mov	r2, r4
 8001264:	687b      	ldr	r3, [r7, #4]
 8001266:	f7ff ff69 	bl	800113c <input_to_child_command>
 800126a:	e00d      	b.n	8001288 <shell_output_str+0x5c>
			   text2, (int)strlen(text2));
  } else {
    shell_default_output(text1, (int)strlen(text1),
 800126c:	68b8      	ldr	r0, [r7, #8]
 800126e:	f7ff f875 	bl	800035c <strlen>
 8001272:	4603      	mov	r3, r0
 8001274:	461c      	mov	r4, r3
			 text2, (int)strlen(text2));
 8001276:	6878      	ldr	r0, [r7, #4]
 8001278:	f7ff f870 	bl	800035c <strlen>
 800127c:	4603      	mov	r3, r0
{
  if(c != NULL && c->child != NULL) {
    input_to_child_command(c->child, text1, (int)strlen(text1),
			   text2, (int)strlen(text2));
  } else {
    shell_default_output(text1, (int)strlen(text1),
 800127e:	68b8      	ldr	r0, [r7, #8]
 8001280:	4621      	mov	r1, r4
 8001282:	687a      	ldr	r2, [r7, #4]
 8001284:	f7ff f972 	bl	800056c <shell_default_output>
			 text2, (int)strlen(text2));
  }
}
 8001288:	f107 0710 	add.w	r7, r7, #16
 800128c:	46bd      	mov	sp, r7
 800128e:	bdb0      	pop	{r4, r5, r7, pc}

08001290 <shell_output>:
/*---------------------------------------------------------------------------*/
void
shell_output(struct shell_command *c,
	     void *data1, int len1,
	     const void *data2, int len2)
{
 8001290:	b580      	push	{r7, lr}
 8001292:	b086      	sub	sp, #24
 8001294:	af02      	add	r7, sp, #8
 8001296:	60f8      	str	r0, [r7, #12]
 8001298:	60b9      	str	r1, [r7, #8]
 800129a:	607a      	str	r2, [r7, #4]
 800129c:	603b      	str	r3, [r7, #0]
  if(c != NULL && c->child != NULL) {
 800129e:	68fb      	ldr	r3, [r7, #12]
 80012a0:	2b00      	cmp	r3, #0
 80012a2:	d00e      	beq.n	80012c2 <shell_output+0x32>
 80012a4:	68fb      	ldr	r3, [r7, #12]
 80012a6:	691b      	ldr	r3, [r3, #16]
 80012a8:	2b00      	cmp	r3, #0
 80012aa:	d00a      	beq.n	80012c2 <shell_output+0x32>
    input_to_child_command(c->child, data1, len1, data2, len2);
 80012ac:	68fb      	ldr	r3, [r7, #12]
 80012ae:	691b      	ldr	r3, [r3, #16]
 80012b0:	69ba      	ldr	r2, [r7, #24]
 80012b2:	9200      	str	r2, [sp, #0]
 80012b4:	4618      	mov	r0, r3
 80012b6:	68b9      	ldr	r1, [r7, #8]
 80012b8:	687a      	ldr	r2, [r7, #4]
 80012ba:	683b      	ldr	r3, [r7, #0]
 80012bc:	f7ff ff3e 	bl	800113c <input_to_child_command>
 80012c0:	e005      	b.n	80012ce <shell_output+0x3e>
  } else {
    shell_default_output(data1, len1, data2, len2);
 80012c2:	68b8      	ldr	r0, [r7, #8]
 80012c4:	6879      	ldr	r1, [r7, #4]
 80012c6:	683a      	ldr	r2, [r7, #0]
 80012c8:	69bb      	ldr	r3, [r7, #24]
 80012ca:	f7ff f94f 	bl	800056c <shell_default_output>
  }
}
 80012ce:	f107 0710 	add.w	r7, r7, #16
 80012d2:	46bd      	mov	sp, r7
 80012d4:	bd80      	pop	{r7, pc}
 80012d6:	bf00      	nop

080012d8 <shell_register_command>:
  list_remove(commands, c);
}
/*---------------------------------------------------------------------------*/
void
shell_register_command(struct shell_command *c)
{
 80012d8:	b580      	push	{r7, lr}
 80012da:	b084      	sub	sp, #16
 80012dc:	af00      	add	r7, sp, #0
 80012de:	6078      	str	r0, [r7, #4]
  struct shell_command *i, *p;

  p = NULL;
 80012e0:	2300      	movs	r3, #0
 80012e2:	60bb      	str	r3, [r7, #8]
  for(i = list_head(commands);
 80012e4:	f240 43ac 	movw	r3, #1196	; 0x4ac
 80012e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80012ec:	681b      	ldr	r3, [r3, #0]
 80012ee:	4618      	mov	r0, r3
 80012f0:	f003 f856 	bl	80043a0 <list_head>
 80012f4:	60f8      	str	r0, [r7, #12]
 80012f6:	e004      	b.n	8001302 <shell_register_command+0x2a>
      i != NULL &&
	strcmp(i->command, c->command) < 0;
      i = i->next) {
    p = i;
 80012f8:	68fb      	ldr	r3, [r7, #12]
 80012fa:	60bb      	str	r3, [r7, #8]

  p = NULL;
  for(i = list_head(commands);
      i != NULL &&
	strcmp(i->command, c->command) < 0;
      i = i->next) {
 80012fc:	68fb      	ldr	r3, [r7, #12]
 80012fe:	681b      	ldr	r3, [r3, #0]
 8001300:	60fb      	str	r3, [r7, #12]
shell_register_command(struct shell_command *c)
{
  struct shell_command *i, *p;

  p = NULL;
  for(i = list_head(commands);
 8001302:	68fb      	ldr	r3, [r7, #12]
 8001304:	2b00      	cmp	r3, #0
 8001306:	d00a      	beq.n	800131e <shell_register_command+0x46>
      i != NULL &&
	strcmp(i->command, c->command) < 0;
 8001308:	68fb      	ldr	r3, [r7, #12]
 800130a:	685a      	ldr	r2, [r3, #4]
 800130c:	687b      	ldr	r3, [r7, #4]
 800130e:	685b      	ldr	r3, [r3, #4]
 8001310:	4610      	mov	r0, r2
 8001312:	4619      	mov	r1, r3
 8001314:	f7ff f817 	bl	8000346 <strcmp>
 8001318:	4603      	mov	r3, r0
{
  struct shell_command *i, *p;

  p = NULL;
  for(i = list_head(commands);
      i != NULL &&
 800131a:	2b00      	cmp	r3, #0
 800131c:	dbec      	blt.n	80012f8 <shell_register_command+0x20>
	strcmp(i->command, c->command) < 0;
      i = i->next) {
    p = i;
  }
  if(p == NULL) {
 800131e:	68bb      	ldr	r3, [r7, #8]
 8001320:	2b00      	cmp	r3, #0
 8001322:	d109      	bne.n	8001338 <shell_register_command+0x60>
    list_push(commands, c);
 8001324:	f240 43ac 	movw	r3, #1196	; 0x4ac
 8001328:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800132c:	681b      	ldr	r3, [r3, #0]
 800132e:	4618      	mov	r0, r3
 8001330:	6879      	ldr	r1, [r7, #4]
 8001332:	f003 f87b 	bl	800442c <list_push>
 8001336:	e016      	b.n	8001366 <shell_register_command+0x8e>
  } else if(i == NULL) {
 8001338:	68fb      	ldr	r3, [r7, #12]
 800133a:	2b00      	cmp	r3, #0
 800133c:	d109      	bne.n	8001352 <shell_register_command+0x7a>
    list_add(commands, c);
 800133e:	f240 43ac 	movw	r3, #1196	; 0x4ac
 8001342:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001346:	681b      	ldr	r3, [r3, #0]
 8001348:	4618      	mov	r0, r3
 800134a:	6879      	ldr	r1, [r7, #4]
 800134c:	f003 f850 	bl	80043f0 <list_add>
 8001350:	e009      	b.n	8001366 <shell_register_command+0x8e>
  } else {
    list_insert(commands, p, c);
 8001352:	f240 43ac 	movw	r3, #1196	; 0x4ac
 8001356:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800135a:	681b      	ldr	r3, [r3, #0]
 800135c:	4618      	mov	r0, r3
 800135e:	68b9      	ldr	r1, [r7, #8]
 8001360:	687a      	ldr	r2, [r7, #4]
 8001362:	f003 f8a9 	bl	80044b8 <list_insert>
  }
}
 8001366:	f107 0710 	add.w	r7, r7, #16
 800136a:	46bd      	mov	sp, r7
 800136c:	bd80      	pop	{r7, pc}
 800136e:	bf00      	nop

08001370 <process_thread_shell_process>:
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_process, ev, data)
{
 8001370:	b580      	push	{r7, lr}
 8001372:	b088      	sub	sp, #32
 8001374:	af00      	add	r7, sp, #0
 8001376:	60f8      	str	r0, [r7, #12]
 8001378:	460b      	mov	r3, r1
 800137a:	607a      	str	r2, [r7, #4]
 800137c:	72fb      	strb	r3, [r7, #11]
  static struct process *started_process;
  struct shell_input *input;
  int ret;
  PROCESS_BEGIN();
 800137e:	2301      	movs	r3, #1
 8001380:	77fb      	strb	r3, [r7, #31]
 8001382:	68fb      	ldr	r3, [r7, #12]
 8001384:	881b      	ldrh	r3, [r3, #0]
 8001386:	f5b3 7fdd 	cmp.w	r3, #442	; 0x1ba
 800138a:	d01d      	beq.n	80013c8 <process_thread_shell_process+0x58>
 800138c:	f5b3 7fdd 	cmp.w	r3, #442	; 0x1ba
 8001390:	dc02      	bgt.n	8001398 <process_thread_shell_process+0x28>
 8001392:	2b00      	cmp	r3, #0
 8001394:	d008      	beq.n	80013a8 <process_thread_shell_process+0x38>
 8001396:	e087      	b.n	80014a8 <process_thread_shell_process+0x138>
 8001398:	f240 12bf 	movw	r2, #447	; 0x1bf
 800139c:	4293      	cmp	r3, r2
 800139e:	d027      	beq.n	80013f0 <process_thread_shell_process+0x80>
 80013a0:	f5b3 7fe5 	cmp.w	r3, #458	; 0x1ca
 80013a4:	d066      	beq.n	8001474 <process_thread_shell_process+0x104>
 80013a6:	e07f      	b.n	80014a8 <process_thread_shell_process+0x138>

  /* Let the system start up before showing the prompt. */
  PROCESS_PAUSE();
 80013a8:	f241 33c4 	movw	r3, #5060	; 0x13c4
 80013ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80013b0:	681b      	ldr	r3, [r3, #0]
 80013b2:	4618      	mov	r0, r3
 80013b4:	2185      	movs	r1, #133	; 0x85
 80013b6:	2200      	movs	r2, #0
 80013b8:	f002 ff0e 	bl	80041d8 <process_post>
 80013bc:	2300      	movs	r3, #0
 80013be:	77fb      	strb	r3, [r7, #31]
 80013c0:	68fb      	ldr	r3, [r7, #12]
 80013c2:	f44f 72dd 	mov.w	r2, #442	; 0x1ba
 80013c6:	801a      	strh	r2, [r3, #0]
 80013c8:	7ffb      	ldrb	r3, [r7, #31]
 80013ca:	2b00      	cmp	r3, #0
 80013cc:	d002      	beq.n	80013d4 <process_thread_shell_process+0x64>
 80013ce:	7afb      	ldrb	r3, [r7, #11]
 80013d0:	2b85      	cmp	r3, #133	; 0x85
 80013d2:	d001      	beq.n	80013d8 <process_thread_shell_process+0x68>
 80013d4:	2301      	movs	r3, #1
 80013d6:	e06d      	b.n	80014b4 <process_thread_shell_process+0x144>
  
  while(1) {
    shell_prompt(shell_prompt_text);
 80013d8:	f240 4088 	movw	r0, #1160	; 0x488
 80013dc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80013e0:	f7ff f8b0 	bl	8000544 <shell_prompt>
    
    PROCESS_WAIT_EVENT_UNTIL(ev == shell_event_input);
 80013e4:	2300      	movs	r3, #0
 80013e6:	77fb      	strb	r3, [r7, #31]
 80013e8:	68fb      	ldr	r3, [r7, #12]
 80013ea:	f240 12bf 	movw	r2, #447	; 0x1bf
 80013ee:	801a      	strh	r2, [r3, #0]
 80013f0:	7ffb      	ldrb	r3, [r7, #31]
 80013f2:	2b00      	cmp	r3, #0
 80013f4:	d007      	beq.n	8001406 <process_thread_shell_process+0x96>
 80013f6:	7afa      	ldrb	r2, [r7, #11]
 80013f8:	f241 63f8 	movw	r3, #5880	; 0x16f8
 80013fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001400:	681b      	ldr	r3, [r3, #0]
 8001402:	429a      	cmp	r2, r3
 8001404:	d001      	beq.n	800140a <process_thread_shell_process+0x9a>
 8001406:	2301      	movs	r3, #1
 8001408:	e054      	b.n	80014b4 <process_thread_shell_process+0x144>
    {
      input = data;
 800140a:	687b      	ldr	r3, [r7, #4]
 800140c:	61bb      	str	r3, [r7, #24]
      ret = shell_start_command(input->data1, input->len1, NULL,
 800140e:	69bb      	ldr	r3, [r7, #24]
 8001410:	681a      	ldr	r2, [r3, #0]
 8001412:	69bb      	ldr	r3, [r7, #24]
 8001414:	689b      	ldr	r3, [r3, #8]
 8001416:	4610      	mov	r0, r2
 8001418:	4619      	mov	r1, r3
 800141a:	2200      	movs	r2, #0
 800141c:	f241 03ec 	movw	r3, #4332	; 0x10ec
 8001420:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001424:	f7ff fe48 	bl	80010b8 <shell_start_command>
 8001428:	6178      	str	r0, [r7, #20]
				&started_process);

      if(started_process != NULL &&
 800142a:	f241 03ec 	movw	r3, #4332	; 0x10ec
 800142e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001432:	681b      	ldr	r3, [r3, #0]
 8001434:	2b00      	cmp	r3, #0
 8001436:	d02d      	beq.n	8001494 <process_thread_shell_process+0x124>
 8001438:	697b      	ldr	r3, [r7, #20]
 800143a:	2b00      	cmp	r3, #0
 800143c:	d12a      	bne.n	8001494 <process_thread_shell_process+0x124>
	 ret == SHELL_FOREGROUND &&
	 process_is_running(started_process)) {
 800143e:	f241 03ec 	movw	r3, #4332	; 0x10ec
 8001442:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001446:	681b      	ldr	r3, [r3, #0]
 8001448:	4618      	mov	r0, r3
 800144a:	f002 ff6d 	bl	8004328 <process_is_running>
 800144e:	4603      	mov	r3, r0
      input = data;
      ret = shell_start_command(input->data1, input->len1, NULL,
				&started_process);

      if(started_process != NULL &&
	 ret == SHELL_FOREGROUND &&
 8001450:	2b00      	cmp	r3, #0
 8001452:	d01f      	beq.n	8001494 <process_thread_shell_process+0x124>
	 process_is_running(started_process)) {
	front_process = started_process;
 8001454:	f241 03ec 	movw	r3, #4332	; 0x10ec
 8001458:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800145c:	681a      	ldr	r2, [r3, #0]
 800145e:	f241 03d4 	movw	r3, #4308	; 0x10d4
 8001462:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001466:	601a      	str	r2, [r3, #0]
	PROCESS_WAIT_EVENT_UNTIL(ev == PROCESS_EVENT_EXITED &&
 8001468:	2300      	movs	r3, #0
 800146a:	77fb      	strb	r3, [r7, #31]
 800146c:	68fb      	ldr	r3, [r7, #12]
 800146e:	f44f 72e5 	mov.w	r2, #458	; 0x1ca
 8001472:	801a      	strh	r2, [r3, #0]
 8001474:	7ffb      	ldrb	r3, [r7, #31]
 8001476:	2b00      	cmp	r3, #0
 8001478:	d00a      	beq.n	8001490 <process_thread_shell_process+0x120>
 800147a:	7afb      	ldrb	r3, [r7, #11]
 800147c:	2b87      	cmp	r3, #135	; 0x87
 800147e:	d107      	bne.n	8001490 <process_thread_shell_process+0x120>
 8001480:	f241 03ec 	movw	r3, #4332	; 0x10ec
 8001484:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001488:	681b      	ldr	r3, [r3, #0]
 800148a:	687a      	ldr	r2, [r7, #4]
 800148c:	429a      	cmp	r2, r3
 800148e:	d001      	beq.n	8001494 <process_thread_shell_process+0x124>
 8001490:	2301      	movs	r3, #1
 8001492:	e00f      	b.n	80014b4 <process_thread_shell_process+0x144>
				 data == started_process);
      }
      front_process = &shell_process;
 8001494:	f241 03d4 	movw	r3, #4308	; 0x10d4
 8001498:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800149c:	f240 42b0 	movw	r2, #1200	; 0x4b0
 80014a0:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80014a4:	601a      	str	r2, [r3, #0]
    }
  }
 80014a6:	e797      	b.n	80013d8 <process_thread_shell_process+0x68>
  
  PROCESS_END();
 80014a8:	2300      	movs	r3, #0
 80014aa:	77fb      	strb	r3, [r7, #31]
 80014ac:	68fb      	ldr	r3, [r7, #12]
 80014ae:	2200      	movs	r2, #0
 80014b0:	801a      	strh	r2, [r3, #0]
 80014b2:	2303      	movs	r3, #3
}
 80014b4:	4618      	mov	r0, r3
 80014b6:	f107 0720 	add.w	r7, r7, #32
 80014ba:	46bd      	mov	sp, r7
 80014bc:	bd80      	pop	{r7, pc}
 80014be:	bf00      	nop

080014c0 <process_thread_shell_server_process>:
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_server_process, ev, data)
{
 80014c0:	b580      	push	{r7, lr}
 80014c2:	b08a      	sub	sp, #40	; 0x28
 80014c4:	af02      	add	r7, sp, #8
 80014c6:	60f8      	str	r0, [r7, #12]
 80014c8:	460b      	mov	r3, r1
 80014ca:	607a      	str	r2, [r7, #4]
 80014cc:	72fb      	strb	r3, [r7, #11]
  struct process *p;
  struct shell_command *c;
  static struct etimer etimer;
  PROCESS_BEGIN();
 80014ce:	2301      	movs	r3, #1
 80014d0:	76fb      	strb	r3, [r7, #27]
 80014d2:	68fb      	ldr	r3, [r7, #12]
 80014d4:	881b      	ldrh	r3, [r3, #0]
 80014d6:	2b00      	cmp	r3, #0
 80014d8:	d003      	beq.n	80014e2 <process_thread_shell_server_process+0x22>
 80014da:	f5b3 7fee 	cmp.w	r3, #476	; 0x1dc
 80014de:	d010      	beq.n	8001502 <process_thread_shell_server_process+0x42>
 80014e0:	e060      	b.n	80015a4 <process_thread_shell_server_process+0xe4>

  etimer_set(&etimer, CLOCK_SECOND * 10);
 80014e2:	f241 00dc 	movw	r0, #4316	; 0x10dc
 80014e6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80014ea:	f242 7110 	movw	r1, #10000	; 0x2710
 80014ee:	f003 f93b 	bl	8004768 <etimer_set>
 80014f2:	e000      	b.n	80014f6 <process_thread_shell_server_process+0x36>
      }
    } else if(ev == PROCESS_EVENT_TIMER) {
      etimer_reset(&etimer);
      shell_set_time(shell_time());
    }
  }
 80014f4:	bf00      	nop
  static struct etimer etimer;
  PROCESS_BEGIN();

  etimer_set(&etimer, CLOCK_SECOND * 10);
  while(1) {
    PROCESS_WAIT_EVENT();
 80014f6:	2300      	movs	r3, #0
 80014f8:	76fb      	strb	r3, [r7, #27]
 80014fa:	68fb      	ldr	r3, [r7, #12]
 80014fc:	f44f 72ee 	mov.w	r2, #476	; 0x1dc
 8001500:	801a      	strh	r2, [r3, #0]
 8001502:	7efb      	ldrb	r3, [r7, #27]
 8001504:	2b00      	cmp	r3, #0
 8001506:	d101      	bne.n	800150c <process_thread_shell_server_process+0x4c>
 8001508:	2301      	movs	r3, #1
 800150a:	e051      	b.n	80015b0 <process_thread_shell_server_process+0xf0>
    if(ev == PROCESS_EVENT_EXITED) {
 800150c:	7afb      	ldrb	r3, [r7, #11]
 800150e:	2b87      	cmp	r3, #135	; 0x87
 8001510:	d137      	bne.n	8001582 <process_thread_shell_server_process+0xc2>
      p = data;
 8001512:	687b      	ldr	r3, [r7, #4]
 8001514:	617b      	str	r3, [r7, #20]
      /*      printf("process exited '%s' (front '%s')\n", p->name,
	      front_process->name);*/
      for(c = list_head(commands);
 8001516:	f240 43ac 	movw	r3, #1196	; 0x4ac
 800151a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800151e:	681b      	ldr	r3, [r3, #0]
 8001520:	4618      	mov	r0, r3
 8001522:	f002 ff3d 	bl	80043a0 <list_head>
 8001526:	61f8      	str	r0, [r7, #28]
 8001528:	e002      	b.n	8001530 <process_thread_shell_server_process+0x70>
	  c != NULL && c->process != p;
	  c = c->next);
 800152a:	69fb      	ldr	r3, [r7, #28]
 800152c:	681b      	ldr	r3, [r3, #0]
 800152e:	61fb      	str	r3, [r7, #28]
    PROCESS_WAIT_EVENT();
    if(ev == PROCESS_EVENT_EXITED) {
      p = data;
      /*      printf("process exited '%s' (front '%s')\n", p->name,
	      front_process->name);*/
      for(c = list_head(commands);
 8001530:	69fb      	ldr	r3, [r7, #28]
 8001532:	2b00      	cmp	r3, #0
 8001534:	d021      	beq.n	800157a <process_thread_shell_server_process+0xba>
	  c != NULL && c->process != p;
 8001536:	69fb      	ldr	r3, [r7, #28]
 8001538:	68da      	ldr	r2, [r3, #12]
 800153a:	697b      	ldr	r3, [r7, #20]
 800153c:	429a      	cmp	r2, r3
 800153e:	d1f4      	bne.n	800152a <process_thread_shell_server_process+0x6a>
	  c = c->next);
      while(c != NULL) {
 8001540:	e01b      	b.n	800157a <process_thread_shell_server_process+0xba>
	if(c->child != NULL && c->child->process != NULL) {
 8001542:	69fb      	ldr	r3, [r7, #28]
 8001544:	691b      	ldr	r3, [r3, #16]
 8001546:	2b00      	cmp	r3, #0
 8001548:	d014      	beq.n	8001574 <process_thread_shell_server_process+0xb4>
 800154a:	69fb      	ldr	r3, [r7, #28]
 800154c:	691b      	ldr	r3, [r3, #16]
 800154e:	68db      	ldr	r3, [r3, #12]
 8001550:	2b00      	cmp	r3, #0
 8001552:	d00f      	beq.n	8001574 <process_thread_shell_server_process+0xb4>
	  /*	  printf("Killing '%s'\n", c->process->name);*/
	  input_to_child_command(c->child, "", 0, "", 0);
 8001554:	69fb      	ldr	r3, [r7, #28]
 8001556:	691b      	ldr	r3, [r3, #16]
 8001558:	2200      	movs	r2, #0
 800155a:	9200      	str	r2, [sp, #0]
 800155c:	4618      	mov	r0, r3
 800155e:	f648 2114 	movw	r1, #35348	; 0x8a14
 8001562:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001566:	2200      	movs	r2, #0
 8001568:	f648 2314 	movw	r3, #35348	; 0x8a14
 800156c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001570:	f7ff fde4 	bl	800113c <input_to_child_command>
	  /*	  process_exit(c->process);*/
	}
	c = c->child;
 8001574:	69fb      	ldr	r3, [r7, #28]
 8001576:	691b      	ldr	r3, [r3, #16]
 8001578:	61fb      	str	r3, [r7, #28]
      /*      printf("process exited '%s' (front '%s')\n", p->name,
	      front_process->name);*/
      for(c = list_head(commands);
	  c != NULL && c->process != p;
	  c = c->next);
      while(c != NULL) {
 800157a:	69fb      	ldr	r3, [r7, #28]
 800157c:	2b00      	cmp	r3, #0
 800157e:	d1e0      	bne.n	8001542 <process_thread_shell_server_process+0x82>
 8001580:	e00f      	b.n	80015a2 <process_thread_shell_server_process+0xe2>
	  input_to_child_command(c->child, "", 0, "", 0);
	  /*	  process_exit(c->process);*/
	}
	c = c->child;
      }
    } else if(ev == PROCESS_EVENT_TIMER) {
 8001582:	7afb      	ldrb	r3, [r7, #11]
 8001584:	2b88      	cmp	r3, #136	; 0x88
 8001586:	d1b5      	bne.n	80014f4 <process_thread_shell_server_process+0x34>
      etimer_reset(&etimer);
 8001588:	f241 00dc 	movw	r0, #4316	; 0x10dc
 800158c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001590:	f003 f8fc 	bl	800478c <etimer_reset>
      shell_set_time(shell_time());
 8001594:	f000 f8bc 	bl	8001710 <shell_time>
 8001598:	4603      	mov	r3, r0
 800159a:	4618      	mov	r0, r3
 800159c:	f000 f8c6 	bl	800172c <shell_set_time>
    }
  }
 80015a0:	e7a8      	b.n	80014f4 <process_thread_shell_server_process+0x34>
 80015a2:	e7a7      	b.n	80014f4 <process_thread_shell_server_process+0x34>
  
  PROCESS_END();
 80015a4:	2300      	movs	r3, #0
 80015a6:	76fb      	strb	r3, [r7, #27]
 80015a8:	68fb      	ldr	r3, [r7, #12]
 80015aa:	2200      	movs	r2, #0
 80015ac:	801a      	strh	r2, [r3, #0]
 80015ae:	2303      	movs	r3, #3
}
 80015b0:	4618      	mov	r0, r3
 80015b2:	f107 0720 	add.w	r7, r7, #32
 80015b6:	46bd      	mov	sp, r7
 80015b8:	bd80      	pop	{r7, pc}
 80015ba:	bf00      	nop

080015bc <shell_init>:
/*---------------------------------------------------------------------------*/
void
shell_init(void)
{
 80015bc:	b580      	push	{r7, lr}
 80015be:	af00      	add	r7, sp, #0
  list_init(commands);
 80015c0:	f240 43ac 	movw	r3, #1196	; 0x4ac
 80015c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80015c8:	681b      	ldr	r3, [r3, #0]
 80015ca:	4618      	mov	r0, r3
 80015cc:	f002 fedc 	bl	8004388 <list_init>
  shell_register_command(&help_command);
 80015d0:	f240 40e0 	movw	r0, #1248	; 0x4e0
 80015d4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80015d8:	f7ff fe7e 	bl	80012d8 <shell_register_command>
  shell_register_command(&question_command);
 80015dc:	f240 40f4 	movw	r0, #1268	; 0x4f4
 80015e0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80015e4:	f7ff fe78 	bl	80012d8 <shell_register_command>
  shell_register_command(&killall_command);
 80015e8:	f240 5018 	movw	r0, #1304	; 0x518
 80015ec:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80015f0:	f7ff fe72 	bl	80012d8 <shell_register_command>
  shell_register_command(&kill_command);
 80015f4:	f240 503c 	movw	r0, #1340	; 0x53c
 80015f8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80015fc:	f7ff fe6c 	bl	80012d8 <shell_register_command>
  shell_register_command(&null_command);
 8001600:	f240 5060 	movw	r0, #1376	; 0x560
 8001604:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001608:	f7ff fe66 	bl	80012d8 <shell_register_command>
  shell_register_command(&exit_command);
 800160c:	f240 5084 	movw	r0, #1412	; 0x584
 8001610:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001614:	f7ff fe60 	bl	80012d8 <shell_register_command>
  shell_register_command(&quit_command);
 8001618:	f240 5098 	movw	r0, #1432	; 0x598
 800161c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001620:	f7ff fe5a 	bl	80012d8 <shell_register_command>
  
  shell_event_input = process_alloc_event();
 8001624:	f002 fb80 	bl	8003d28 <process_alloc_event>
 8001628:	4603      	mov	r3, r0
 800162a:	461a      	mov	r2, r3
 800162c:	f241 63f8 	movw	r3, #5880	; 0x16f8
 8001630:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001634:	601a      	str	r2, [r3, #0]
  
  process_start(&shell_process, NULL);
 8001636:	f240 40b0 	movw	r0, #1200	; 0x4b0
 800163a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800163e:	2100      	movs	r1, #0
 8001640:	f002 fb86 	bl	8003d50 <process_start>
  process_start(&shell_server_process, NULL);
 8001644:	f240 40c0 	movw	r0, #1216	; 0x4c0
 8001648:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800164c:	2100      	movs	r1, #0
 800164e:	f002 fb7f 	bl	8003d50 <process_start>

  front_process = &shell_process;
 8001652:	f241 03d4 	movw	r3, #4308	; 0x10d4
 8001656:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800165a:	f240 42b0 	movw	r2, #1200	; 0x4b0
 800165e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001662:	601a      	str	r2, [r3, #0]
}
 8001664:	bd80      	pop	{r7, pc}
 8001666:	bf00      	nop

08001668 <shell_strtolong>:
/*---------------------------------------------------------------------------*/
unsigned long
shell_strtolong(const char *str, const char **retstr)
{
 8001668:	b480      	push	{r7}
 800166a:	b087      	sub	sp, #28
 800166c:	af00      	add	r7, sp, #0
 800166e:	6078      	str	r0, [r7, #4]
 8001670:	6039      	str	r1, [r7, #0]
  int i;
  unsigned long num = 0;
 8001672:	2300      	movs	r3, #0
 8001674:	613b      	str	r3, [r7, #16]
  const char *strptr = str;
 8001676:	687b      	ldr	r3, [r7, #4]
 8001678:	60fb      	str	r3, [r7, #12]

  if(str == NULL) {
 800167a:	687b      	ldr	r3, [r7, #4]
 800167c:	2b00      	cmp	r3, #0
 800167e:	d105      	bne.n	800168c <shell_strtolong+0x24>
    return 0;
 8001680:	2300      	movs	r3, #0
 8001682:	e03e      	b.n	8001702 <shell_strtolong+0x9a>
  }
  
  while(*strptr == ' ') {
    ++strptr;
 8001684:	68fb      	ldr	r3, [r7, #12]
 8001686:	3301      	adds	r3, #1
 8001688:	60fb      	str	r3, [r7, #12]
 800168a:	e000      	b.n	800168e <shell_strtolong+0x26>

  if(str == NULL) {
    return 0;
  }
  
  while(*strptr == ' ') {
 800168c:	bf00      	nop
 800168e:	68fb      	ldr	r3, [r7, #12]
 8001690:	781b      	ldrb	r3, [r3, #0]
 8001692:	2b20      	cmp	r3, #32
 8001694:	d0f6      	beq.n	8001684 <shell_strtolong+0x1c>
    ++strptr;
  }
  
  for(i = 0; i < 10 && isdigit(strptr[i]); ++i) {
 8001696:	2300      	movs	r3, #0
 8001698:	617b      	str	r3, [r7, #20]
 800169a:	e00f      	b.n	80016bc <shell_strtolong+0x54>
    num = num * 10 + strptr[i] - '0';
 800169c:	693a      	ldr	r2, [r7, #16]
 800169e:	4613      	mov	r3, r2
 80016a0:	009b      	lsls	r3, r3, #2
 80016a2:	189b      	adds	r3, r3, r2
 80016a4:	005b      	lsls	r3, r3, #1
 80016a6:	461a      	mov	r2, r3
 80016a8:	697b      	ldr	r3, [r7, #20]
 80016aa:	68f9      	ldr	r1, [r7, #12]
 80016ac:	18cb      	adds	r3, r1, r3
 80016ae:	781b      	ldrb	r3, [r3, #0]
 80016b0:	18d3      	adds	r3, r2, r3
 80016b2:	3b30      	subs	r3, #48	; 0x30
 80016b4:	613b      	str	r3, [r7, #16]
  
  while(*strptr == ' ') {
    ++strptr;
  }
  
  for(i = 0; i < 10 && isdigit(strptr[i]); ++i) {
 80016b6:	697b      	ldr	r3, [r7, #20]
 80016b8:	3301      	adds	r3, #1
 80016ba:	617b      	str	r3, [r7, #20]
 80016bc:	697b      	ldr	r3, [r7, #20]
 80016be:	2b09      	cmp	r3, #9
 80016c0:	dc0f      	bgt.n	80016e2 <shell_strtolong+0x7a>
 80016c2:	f240 0300 	movw	r3, #0
 80016c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80016ca:	681a      	ldr	r2, [r3, #0]
 80016cc:	697b      	ldr	r3, [r7, #20]
 80016ce:	68f9      	ldr	r1, [r7, #12]
 80016d0:	18cb      	adds	r3, r1, r3
 80016d2:	781b      	ldrb	r3, [r3, #0]
 80016d4:	3301      	adds	r3, #1
 80016d6:	18d3      	adds	r3, r2, r3
 80016d8:	781b      	ldrb	r3, [r3, #0]
 80016da:	f003 0304 	and.w	r3, r3, #4
 80016de:	2b00      	cmp	r3, #0
 80016e0:	d1dc      	bne.n	800169c <shell_strtolong+0x34>
    num = num * 10 + strptr[i] - '0';
  }
  if(retstr != NULL) {
 80016e2:	683b      	ldr	r3, [r7, #0]
 80016e4:	2b00      	cmp	r3, #0
 80016e6:	d00b      	beq.n	8001700 <shell_strtolong+0x98>
    if(i == 0) {
 80016e8:	697b      	ldr	r3, [r7, #20]
 80016ea:	2b00      	cmp	r3, #0
 80016ec:	d103      	bne.n	80016f6 <shell_strtolong+0x8e>
      *retstr = str;
 80016ee:	683b      	ldr	r3, [r7, #0]
 80016f0:	687a      	ldr	r2, [r7, #4]
 80016f2:	601a      	str	r2, [r3, #0]
 80016f4:	e004      	b.n	8001700 <shell_strtolong+0x98>
    } else {
      *retstr = strptr + i;
 80016f6:	697b      	ldr	r3, [r7, #20]
 80016f8:	68fa      	ldr	r2, [r7, #12]
 80016fa:	18d2      	adds	r2, r2, r3
 80016fc:	683b      	ldr	r3, [r7, #0]
 80016fe:	601a      	str	r2, [r3, #0]
    }
  }
  
  return num;
 8001700:	693b      	ldr	r3, [r7, #16]
}
 8001702:	4618      	mov	r0, r3
 8001704:	f107 071c 	add.w	r7, r7, #28
 8001708:	46bd      	mov	sp, r7
 800170a:	bc80      	pop	{r7}
 800170c:	4770      	bx	lr
 800170e:	bf00      	nop

08001710 <shell_time>:
/*---------------------------------------------------------------------------*/
unsigned long
shell_time(void)
{
 8001710:	b580      	push	{r7, lr}
 8001712:	af00      	add	r7, sp, #0
  return clock_seconds() + time_offset;
 8001714:	f001 fde2 	bl	80032dc <clock_seconds>
 8001718:	4602      	mov	r2, r0
 800171a:	f241 03d8 	movw	r3, #4312	; 0x10d8
 800171e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001722:	681b      	ldr	r3, [r3, #0]
 8001724:	18d3      	adds	r3, r2, r3
}
 8001726:	4618      	mov	r0, r3
 8001728:	bd80      	pop	{r7, pc}
 800172a:	bf00      	nop

0800172c <shell_set_time>:
/*---------------------------------------------------------------------------*/
void
shell_set_time(unsigned long seconds)
{
 800172c:	b580      	push	{r7, lr}
 800172e:	b082      	sub	sp, #8
 8001730:	af00      	add	r7, sp, #0
 8001732:	6078      	str	r0, [r7, #4]
  time_offset = seconds - clock_seconds();
 8001734:	f001 fdd2 	bl	80032dc <clock_seconds>
 8001738:	4603      	mov	r3, r0
 800173a:	687a      	ldr	r2, [r7, #4]
 800173c:	1ad2      	subs	r2, r2, r3
 800173e:	f241 03d8 	movw	r3, #4312	; 0x10d8
 8001742:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001746:	601a      	str	r2, [r3, #0]
}
 8001748:	f107 0708 	add.w	r7, r7, #8
 800174c:	46bd      	mov	sp, r7
 800174e:	bd80      	pop	{r7, pc}

08001750 <shell_start>:
/*---------------------------------------------------------------------------*/
void
shell_start(void)
{
 8001750:	b580      	push	{r7, lr}
 8001752:	af00      	add	r7, sp, #0
  shell_output_str(NULL, shell_banner_text, "");
 8001754:	2000      	movs	r0, #0
 8001756:	f240 4194 	movw	r1, #1172	; 0x494
 800175a:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800175e:	f648 2214 	movw	r2, #35348	; 0x8a14
 8001762:	f6c0 0200 	movt	r2, #2048	; 0x800
 8001766:	f7ff fd61 	bl	800122c <shell_output_str>
  shell_output_str(NULL, "Type '?' and return for help", "");
 800176a:	2000      	movs	r0, #0
 800176c:	f648 2180 	movw	r1, #35456	; 0x8a80
 8001770:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001774:	f648 2214 	movw	r2, #35348	; 0x8a14
 8001778:	f6c0 0200 	movt	r2, #2048	; 0x800
 800177c:	f7ff fd56 	bl	800122c <shell_output_str>
  shell_prompt(shell_prompt_text);
 8001780:	f240 4088 	movw	r0, #1160	; 0x488
 8001784:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001788:	f7fe fedc 	bl	8000544 <shell_prompt>
}
 800178c:	bd80      	pop	{r7, pc}
 800178e:	bf00      	nop

08001790 <shell_stop>:
/*---------------------------------------------------------------------------*/
void
shell_stop(void)
{
 8001790:	b580      	push	{r7, lr}
 8001792:	af00      	add	r7, sp, #0
  killall();
 8001794:	f7ff fa70 	bl	8000c78 <killall>
}
 8001798:	bd80      	pop	{r7, pc}
 800179a:	bf00      	nop

0800179c <shell_quit>:
/*---------------------------------------------------------------------------*/
void
shell_quit(void)
{
 800179c:	b580      	push	{r7, lr}
 800179e:	af00      	add	r7, sp, #0
  shell_stop();
 80017a0:	f7ff fff6 	bl	8001790 <shell_stop>
  process_exit(&shell_process);
 80017a4:	f240 40b0 	movw	r0, #1200	; 0x4b0
 80017a8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80017ac:	f002 fbbe 	bl	8003f2c <process_exit>
  process_exit(&shell_server_process);
 80017b0:	f240 40c0 	movw	r0, #1216	; 0x4c0
 80017b4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80017b8:	f002 fbb8 	bl	8003f2c <process_exit>
}
 80017bc:	bd80      	pop	{r7, pc}
 80017be:	bf00      	nop

080017c0 <process_thread_shell_ps_process>:
	      "ps",
	      "ps: list all running processes",
	      &shell_ps_process);
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_ps_process, ev, data)
{
 80017c0:	b580      	push	{r7, lr}
 80017c2:	b08e      	sub	sp, #56	; 0x38
 80017c4:	af00      	add	r7, sp, #0
 80017c6:	60f8      	str	r0, [r7, #12]
 80017c8:	460b      	mov	r3, r1
 80017ca:	607a      	str	r2, [r7, #4]
 80017cc:	72fb      	strb	r3, [r7, #11]
  struct process *p;
  PROCESS_BEGIN();
 80017ce:	2301      	movs	r3, #1
 80017d0:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80017d4:	68fb      	ldr	r3, [r7, #12]
 80017d6:	881b      	ldrh	r3, [r3, #0]
 80017d8:	2b00      	cmp	r3, #0
 80017da:	d130      	bne.n	800183e <process_thread_shell_ps_process+0x7e>

  shell_output_str(&ps_command, "Processes:", "");
 80017dc:	f240 50bc 	movw	r0, #1468	; 0x5bc
 80017e0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80017e4:	f648 21c4 	movw	r1, #35524	; 0x8ac4
 80017e8:	f6c0 0100 	movt	r1, #2048	; 0x800
 80017ec:	f648 22d0 	movw	r2, #35536	; 0x8ad0
 80017f0:	f6c0 0200 	movt	r2, #2048	; 0x800
 80017f4:	f7ff fd1a 	bl	800122c <shell_output_str>
  for(p = PROCESS_LIST(); p != NULL; p = p->next) {
 80017f8:	f241 33c0 	movw	r3, #5056	; 0x13c0
 80017fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001800:	681b      	ldr	r3, [r3, #0]
 8001802:	637b      	str	r3, [r7, #52]	; 0x34
 8001804:	e018      	b.n	8001838 <process_thread_shell_ps_process+0x78>
    char namebuf[30];
    strncpy(namebuf, PROCESS_NAME_STRING(p), sizeof(namebuf));
 8001806:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8001808:	685b      	ldr	r3, [r3, #4]
 800180a:	f107 0214 	add.w	r2, r7, #20
 800180e:	4610      	mov	r0, r2
 8001810:	4619      	mov	r1, r3
 8001812:	221e      	movs	r2, #30
 8001814:	f7fe fdc4 	bl	80003a0 <strncpy>
    shell_output_str(&ps_command, namebuf, "");
 8001818:	f107 0314 	add.w	r3, r7, #20
 800181c:	f240 50bc 	movw	r0, #1468	; 0x5bc
 8001820:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001824:	4619      	mov	r1, r3
 8001826:	f648 22d0 	movw	r2, #35536	; 0x8ad0
 800182a:	f6c0 0200 	movt	r2, #2048	; 0x800
 800182e:	f7ff fcfd 	bl	800122c <shell_output_str>
{
  struct process *p;
  PROCESS_BEGIN();

  shell_output_str(&ps_command, "Processes:", "");
  for(p = PROCESS_LIST(); p != NULL; p = p->next) {
 8001832:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8001834:	681b      	ldr	r3, [r3, #0]
 8001836:	637b      	str	r3, [r7, #52]	; 0x34
 8001838:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800183a:	2b00      	cmp	r3, #0
 800183c:	d1e3      	bne.n	8001806 <process_thread_shell_ps_process+0x46>
    char namebuf[30];
    strncpy(namebuf, PROCESS_NAME_STRING(p), sizeof(namebuf));
    shell_output_str(&ps_command, namebuf, "");
  }

  PROCESS_END();
 800183e:	2300      	movs	r3, #0
 8001840:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8001844:	68fb      	ldr	r3, [r7, #12]
 8001846:	2200      	movs	r2, #0
 8001848:	801a      	strh	r2, [r3, #0]
 800184a:	2303      	movs	r3, #3
}
 800184c:	4618      	mov	r0, r3
 800184e:	f107 0738 	add.w	r7, r7, #56	; 0x38
 8001852:	46bd      	mov	sp, r7
 8001854:	bd80      	pop	{r7, pc}
 8001856:	bf00      	nop

08001858 <shell_ps_init>:
/*---------------------------------------------------------------------------*/
void
shell_ps_init(void)
{
 8001858:	b580      	push	{r7, lr}
 800185a:	af00      	add	r7, sp, #0
  shell_register_command(&ps_command);
 800185c:	f240 50bc 	movw	r0, #1468	; 0x5bc
 8001860:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001864:	f7ff fd38 	bl	80012d8 <shell_register_command>
}
 8001868:	bd80      	pop	{r7, pc}
 800186a:	bf00      	nop

0800186c <process_thread_shell_blink_process>:
	      "blink",
	      "blink [num]: blink LEDs ([num] times)",
	      &shell_blink_process);
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_blink_process, ev, data)
{
 800186c:	b580      	push	{r7, lr}
 800186e:	b08a      	sub	sp, #40	; 0x28
 8001870:	af02      	add	r7, sp, #8
 8001872:	60f8      	str	r0, [r7, #12]
 8001874:	460b      	mov	r3, r1
 8001876:	607a      	str	r2, [r7, #4]
 8001878:	72fb      	strb	r3, [r7, #11]
  static struct etimer etimer;
  static int i, num, on = 0;
  const char *nextptr;

  PROCESS_EXITHANDLER(if(on) { leds_toggle(LEDS_ALL); } );
 800187a:	7afb      	ldrb	r3, [r7, #11]
 800187c:	2b83      	cmp	r3, #131	; 0x83
 800187e:	d109      	bne.n	8001894 <process_thread_shell_blink_process+0x28>
 8001880:	f241 03f0 	movw	r3, #4336	; 0x10f0
 8001884:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001888:	681b      	ldr	r3, [r3, #0]
 800188a:	2b00      	cmp	r3, #0
 800188c:	d002      	beq.n	8001894 <process_thread_shell_blink_process+0x28>
 800188e:	2007      	movs	r0, #7
 8001890:	f001 fe62 	bl	8003558 <leds_toggle>

  PROCESS_BEGIN();
 8001894:	2301      	movs	r3, #1
 8001896:	77fb      	strb	r3, [r7, #31]
 8001898:	68fb      	ldr	r3, [r7, #12]
 800189a:	881b      	ldrh	r3, [r3, #0]
 800189c:	2b4d      	cmp	r3, #77	; 0x4d
 800189e:	d055      	beq.n	800194c <process_thread_shell_blink_process+0xe0>
 80018a0:	2b4d      	cmp	r3, #77	; 0x4d
 80018a2:	dc04      	bgt.n	80018ae <process_thread_shell_blink_process+0x42>
 80018a4:	2b00      	cmp	r3, #0
 80018a6:	d005      	beq.n	80018b4 <process_thread_shell_blink_process+0x48>
 80018a8:	2b48      	cmp	r3, #72	; 0x48
 80018aa:	d032      	beq.n	8001912 <process_thread_shell_blink_process+0xa6>
 80018ac:	e0ef      	b.n	8001a8e <process_thread_shell_blink_process+0x222>
 80018ae:	2b56      	cmp	r3, #86	; 0x56
 80018b0:	d07f      	beq.n	80019b2 <process_thread_shell_blink_process+0x146>
 80018b2:	e0ec      	b.n	8001a8e <process_thread_shell_blink_process+0x222>

  if(data != NULL) {
 80018b4:	687b      	ldr	r3, [r7, #4]
 80018b6:	2b00      	cmp	r3, #0
 80018b8:	d076      	beq.n	80019a8 <process_thread_shell_blink_process+0x13c>
    num = shell_strtolong(data, &nextptr);
 80018ba:	f107 0314 	add.w	r3, r7, #20
 80018be:	6878      	ldr	r0, [r7, #4]
 80018c0:	4619      	mov	r1, r3
 80018c2:	f7ff fed1 	bl	8001668 <shell_strtolong>
 80018c6:	4603      	mov	r3, r0
 80018c8:	461a      	mov	r2, r3
 80018ca:	f241 03f4 	movw	r3, #4340	; 0x10f4
 80018ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80018d2:	601a      	str	r2, [r3, #0]
    if(nextptr != data) {
 80018d4:	697a      	ldr	r2, [r7, #20]
 80018d6:	687b      	ldr	r3, [r7, #4]
 80018d8:	429a      	cmp	r2, r3
 80018da:	d065      	beq.n	80019a8 <process_thread_shell_blink_process+0x13c>
      etimer_set(&etimer, CLOCK_SECOND / 2);
 80018dc:	f241 00f8 	movw	r0, #4344	; 0x10f8
 80018e0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80018e4:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 80018e8:	f002 ff3e 	bl	8004768 <etimer_set>
      for(i = 0; i < num; ++i) {
 80018ec:	f241 1308 	movw	r3, #4360	; 0x1108
 80018f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80018f4:	2200      	movs	r2, #0
 80018f6:	601a      	str	r2, [r3, #0]
 80018f8:	e044      	b.n	8001984 <process_thread_shell_blink_process+0x118>
	leds_toggle(LEDS_ALL);
 80018fa:	2007      	movs	r0, #7
 80018fc:	f001 fe2c 	bl	8003558 <leds_toggle>
	on = 1;
 8001900:	f241 03f0 	movw	r3, #4336	; 0x10f0
 8001904:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001908:	2201      	movs	r2, #1
 800190a:	601a      	str	r2, [r3, #0]
	PROCESS_WAIT_UNTIL(etimer_expired(&etimer));
 800190c:	68fb      	ldr	r3, [r7, #12]
 800190e:	2248      	movs	r2, #72	; 0x48
 8001910:	801a      	strh	r2, [r3, #0]
 8001912:	f241 00f8 	movw	r0, #4344	; 0x10f8
 8001916:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800191a:	f002 ff57 	bl	80047cc <etimer_expired>
 800191e:	4603      	mov	r3, r0
 8001920:	2b00      	cmp	r3, #0
 8001922:	d101      	bne.n	8001928 <process_thread_shell_blink_process+0xbc>
 8001924:	2300      	movs	r3, #0
 8001926:	e0b8      	b.n	8001a9a <process_thread_shell_blink_process+0x22e>
	etimer_reset(&etimer);
 8001928:	f241 00f8 	movw	r0, #4344	; 0x10f8
 800192c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001930:	f002 ff2c 	bl	800478c <etimer_reset>
	
	leds_toggle(LEDS_ALL);
 8001934:	2007      	movs	r0, #7
 8001936:	f001 fe0f 	bl	8003558 <leds_toggle>
	on = 0;
 800193a:	f241 03f0 	movw	r3, #4336	; 0x10f0
 800193e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001942:	2200      	movs	r2, #0
 8001944:	601a      	str	r2, [r3, #0]
	PROCESS_WAIT_UNTIL(etimer_expired(&etimer));
 8001946:	68fb      	ldr	r3, [r7, #12]
 8001948:	224d      	movs	r2, #77	; 0x4d
 800194a:	801a      	strh	r2, [r3, #0]
 800194c:	f241 00f8 	movw	r0, #4344	; 0x10f8
 8001950:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001954:	f002 ff3a 	bl	80047cc <etimer_expired>
 8001958:	4603      	mov	r3, r0
 800195a:	2b00      	cmp	r3, #0
 800195c:	d101      	bne.n	8001962 <process_thread_shell_blink_process+0xf6>
 800195e:	2300      	movs	r3, #0
 8001960:	e09b      	b.n	8001a9a <process_thread_shell_blink_process+0x22e>
	etimer_reset(&etimer);
 8001962:	f241 00f8 	movw	r0, #4344	; 0x10f8
 8001966:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800196a:	f002 ff0f 	bl	800478c <etimer_reset>

  if(data != NULL) {
    num = shell_strtolong(data, &nextptr);
    if(nextptr != data) {
      etimer_set(&etimer, CLOCK_SECOND / 2);
      for(i = 0; i < num; ++i) {
 800196e:	f241 1308 	movw	r3, #4360	; 0x1108
 8001972:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001976:	681b      	ldr	r3, [r3, #0]
 8001978:	1c5a      	adds	r2, r3, #1
 800197a:	f241 1308 	movw	r3, #4360	; 0x1108
 800197e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001982:	601a      	str	r2, [r3, #0]
 8001984:	f241 1308 	movw	r3, #4360	; 0x1108
 8001988:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800198c:	681a      	ldr	r2, [r3, #0]
 800198e:	f241 03f4 	movw	r3, #4340	; 0x10f4
 8001992:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001996:	681b      	ldr	r3, [r3, #0]
 8001998:	429a      	cmp	r2, r3
 800199a:	dbae      	blt.n	80018fa <process_thread_shell_blink_process+0x8e>
	leds_toggle(LEDS_ALL);
	on = 0;
	PROCESS_WAIT_UNTIL(etimer_expired(&etimer));
	etimer_reset(&etimer);
      }
      PROCESS_EXIT();
 800199c:	68fb      	ldr	r3, [r7, #12]
 800199e:	2200      	movs	r2, #0
 80019a0:	801a      	strh	r2, [r3, #0]
 80019a2:	2302      	movs	r3, #2
 80019a4:	e079      	b.n	8001a9a <process_thread_shell_blink_process+0x22e>
	leds_toggle(LEDS_ALL);
	on = 1;
      }
      etimer_set(&etimer, CLOCK_SECOND / 16);
    }
  }
 80019a6:	bf00      	nop
    }
  }

  while(1) {
    struct shell_input *input;
    PROCESS_WAIT_EVENT();
 80019a8:	2300      	movs	r3, #0
 80019aa:	77fb      	strb	r3, [r7, #31]
 80019ac:	68fb      	ldr	r3, [r7, #12]
 80019ae:	2256      	movs	r2, #86	; 0x56
 80019b0:	801a      	strh	r2, [r3, #0]
 80019b2:	7ffb      	ldrb	r3, [r7, #31]
 80019b4:	2b00      	cmp	r3, #0
 80019b6:	d101      	bne.n	80019bc <process_thread_shell_blink_process+0x150>
 80019b8:	2301      	movs	r3, #1
 80019ba:	e06e      	b.n	8001a9a <process_thread_shell_blink_process+0x22e>
    if(ev == PROCESS_EVENT_TIMER && data == &etimer) {
 80019bc:	7afb      	ldrb	r3, [r7, #11]
 80019be:	2b88      	cmp	r3, #136	; 0x88
 80019c0:	d117      	bne.n	80019f2 <process_thread_shell_blink_process+0x186>
 80019c2:	687a      	ldr	r2, [r7, #4]
 80019c4:	f241 03f8 	movw	r3, #4344	; 0x10f8
 80019c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019cc:	429a      	cmp	r2, r3
 80019ce:	d110      	bne.n	80019f2 <process_thread_shell_blink_process+0x186>
      if(on) {
 80019d0:	f241 03f0 	movw	r3, #4336	; 0x10f0
 80019d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019d8:	681b      	ldr	r3, [r3, #0]
 80019da:	2b00      	cmp	r3, #0
 80019dc:	d056      	beq.n	8001a8c <process_thread_shell_blink_process+0x220>
	leds_toggle(LEDS_ALL);
 80019de:	2007      	movs	r0, #7
 80019e0:	f001 fdba 	bl	8003558 <leds_toggle>
	on = 0;
 80019e4:	f241 03f0 	movw	r3, #4336	; 0x10f0
 80019e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019ec:	2200      	movs	r2, #0
 80019ee:	601a      	str	r2, [r3, #0]

  while(1) {
    struct shell_input *input;
    PROCESS_WAIT_EVENT();
    if(ev == PROCESS_EVENT_TIMER && data == &etimer) {
      if(on) {
 80019f0:	e04c      	b.n	8001a8c <process_thread_shell_blink_process+0x220>
	leds_toggle(LEDS_ALL);
	on = 0;
      }
    } else if(ev == shell_event_input) {
 80019f2:	7afa      	ldrb	r2, [r7, #11]
 80019f4:	f241 63f8 	movw	r3, #5880	; 0x16f8
 80019f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019fc:	681b      	ldr	r3, [r3, #0]
 80019fe:	429a      	cmp	r2, r3
 8001a00:	d1d1      	bne.n	80019a6 <process_thread_shell_blink_process+0x13a>
      input = data;
 8001a02:	687b      	ldr	r3, [r7, #4]
 8001a04:	61bb      	str	r3, [r7, #24]
      if(input->len1 + input->len2 == 0) {
 8001a06:	69bb      	ldr	r3, [r7, #24]
 8001a08:	689a      	ldr	r2, [r3, #8]
 8001a0a:	69bb      	ldr	r3, [r7, #24]
 8001a0c:	68db      	ldr	r3, [r3, #12]
 8001a0e:	18d3      	adds	r3, r2, r3
 8001a10:	2b00      	cmp	r3, #0
 8001a12:	d114      	bne.n	8001a3e <process_thread_shell_blink_process+0x1d2>
	if(on) {
 8001a14:	f241 03f0 	movw	r3, #4336	; 0x10f0
 8001a18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a1c:	681b      	ldr	r3, [r3, #0]
 8001a1e:	2b00      	cmp	r3, #0
 8001a20:	d008      	beq.n	8001a34 <process_thread_shell_blink_process+0x1c8>
	  leds_toggle(LEDS_ALL);
 8001a22:	2007      	movs	r0, #7
 8001a24:	f001 fd98 	bl	8003558 <leds_toggle>
	  on = 0;
 8001a28:	f241 03f0 	movw	r3, #4336	; 0x10f0
 8001a2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a30:	2200      	movs	r2, #0
 8001a32:	601a      	str	r2, [r3, #0]
	}
	PROCESS_EXIT();
 8001a34:	68fb      	ldr	r3, [r7, #12]
 8001a36:	2200      	movs	r2, #0
 8001a38:	801a      	strh	r2, [r3, #0]
 8001a3a:	2302      	movs	r3, #2
 8001a3c:	e02d      	b.n	8001a9a <process_thread_shell_blink_process+0x22e>
      }
      shell_output(&blink_command,
		   input->data1, input->len1,
 8001a3e:	69bb      	ldr	r3, [r7, #24]
 8001a40:	6819      	ldr	r1, [r3, #0]
 8001a42:	69bb      	ldr	r3, [r7, #24]
	  leds_toggle(LEDS_ALL);
	  on = 0;
	}
	PROCESS_EXIT();
      }
      shell_output(&blink_command,
 8001a44:	689a      	ldr	r2, [r3, #8]
		   input->data1, input->len1,
		   input->data2, input->len2);
 8001a46:	69bb      	ldr	r3, [r7, #24]
 8001a48:	685b      	ldr	r3, [r3, #4]
 8001a4a:	69b8      	ldr	r0, [r7, #24]
	  leds_toggle(LEDS_ALL);
	  on = 0;
	}
	PROCESS_EXIT();
      }
      shell_output(&blink_command,
 8001a4c:	68c0      	ldr	r0, [r0, #12]
 8001a4e:	9000      	str	r0, [sp, #0]
 8001a50:	f240 50e0 	movw	r0, #1504	; 0x5e0
 8001a54:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001a58:	f7ff fc1a 	bl	8001290 <shell_output>
		   input->data1, input->len1,
		   input->data2, input->len2);

      if(on == 0) {
 8001a5c:	f241 03f0 	movw	r3, #4336	; 0x10f0
 8001a60:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a64:	681b      	ldr	r3, [r3, #0]
 8001a66:	2b00      	cmp	r3, #0
 8001a68:	d108      	bne.n	8001a7c <process_thread_shell_blink_process+0x210>
	leds_toggle(LEDS_ALL);
 8001a6a:	2007      	movs	r0, #7
 8001a6c:	f001 fd74 	bl	8003558 <leds_toggle>
	on = 1;
 8001a70:	f241 03f0 	movw	r3, #4336	; 0x10f0
 8001a74:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a78:	2201      	movs	r2, #1
 8001a7a:	601a      	str	r2, [r3, #0]
      }
      etimer_set(&etimer, CLOCK_SECOND / 16);
 8001a7c:	f241 00f8 	movw	r0, #4344	; 0x10f8
 8001a80:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001a84:	213e      	movs	r1, #62	; 0x3e
 8001a86:	f002 fe6f 	bl	8004768 <etimer_set>
    }
  }
 8001a8a:	e78c      	b.n	80019a6 <process_thread_shell_blink_process+0x13a>
 8001a8c:	e78b      	b.n	80019a6 <process_thread_shell_blink_process+0x13a>
  

  PROCESS_END();
 8001a8e:	2300      	movs	r3, #0
 8001a90:	77fb      	strb	r3, [r7, #31]
 8001a92:	68fb      	ldr	r3, [r7, #12]
 8001a94:	2200      	movs	r2, #0
 8001a96:	801a      	strh	r2, [r3, #0]
 8001a98:	2303      	movs	r3, #3
}
 8001a9a:	4618      	mov	r0, r3
 8001a9c:	f107 0720 	add.w	r7, r7, #32
 8001aa0:	46bd      	mov	sp, r7
 8001aa2:	bd80      	pop	{r7, pc}

08001aa4 <shell_blink_init>:
/*---------------------------------------------------------------------------*/
void
shell_blink_init(void)
{
 8001aa4:	b580      	push	{r7, lr}
 8001aa6:	af00      	add	r7, sp, #0
  shell_register_command(&blink_command);
 8001aa8:	f240 50e0 	movw	r0, #1504	; 0x5e0
 8001aac:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001ab0:	f7ff fc12 	bl	80012d8 <shell_register_command>
}
 8001ab4:	bd80      	pop	{r7, pc}
 8001ab6:	bf00      	nop

08001ab8 <process_thread_shell_echo_process>:
	      "size",
	      "size: print the size of the input",
	      &shell_size_process);
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_echo_process, ev, data)
{
 8001ab8:	b580      	push	{r7, lr}
 8001aba:	b088      	sub	sp, #32
 8001abc:	af02      	add	r7, sp, #8
 8001abe:	60f8      	str	r0, [r7, #12]
 8001ac0:	460b      	mov	r3, r1
 8001ac2:	607a      	str	r2, [r7, #4]
 8001ac4:	72fb      	strb	r3, [r7, #11]
  PROCESS_BEGIN();
 8001ac6:	2301      	movs	r3, #1
 8001ac8:	75fb      	strb	r3, [r7, #23]
 8001aca:	68fb      	ldr	r3, [r7, #12]
 8001acc:	881b      	ldrh	r3, [r3, #0]
 8001ace:	2b00      	cmp	r3, #0
 8001ad0:	d111      	bne.n	8001af6 <process_thread_shell_echo_process+0x3e>

  shell_output(&echo_command, data, (int)strlen(data), "", 0);
 8001ad2:	6878      	ldr	r0, [r7, #4]
 8001ad4:	f7fe fc42 	bl	800035c <strlen>
 8001ad8:	4603      	mov	r3, r0
 8001ada:	2200      	movs	r2, #0
 8001adc:	9200      	str	r2, [sp, #0]
 8001ade:	f240 6004 	movw	r0, #1540	; 0x604
 8001ae2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001ae6:	6879      	ldr	r1, [r7, #4]
 8001ae8:	461a      	mov	r2, r3
 8001aea:	f648 33c0 	movw	r3, #35776	; 0x8bc0
 8001aee:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001af2:	f7ff fbcd 	bl	8001290 <shell_output>
  
  PROCESS_END();
 8001af6:	2300      	movs	r3, #0
 8001af8:	75fb      	strb	r3, [r7, #23]
 8001afa:	68fb      	ldr	r3, [r7, #12]
 8001afc:	2200      	movs	r2, #0
 8001afe:	801a      	strh	r2, [r3, #0]
 8001b00:	2303      	movs	r3, #3
}
 8001b02:	4618      	mov	r0, r3
 8001b04:	f107 0718 	add.w	r7, r7, #24
 8001b08:	46bd      	mov	sp, r7
 8001b0a:	bd80      	pop	{r7, pc}

08001b0c <process_thread_shell_hd_process>:
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_hd_process, ev, data)
{
 8001b0c:	b580      	push	{r7, lr}
 8001b0e:	b098      	sub	sp, #96	; 0x60
 8001b10:	af00      	add	r7, sp, #0
 8001b12:	60f8      	str	r0, [r7, #12]
 8001b14:	460b      	mov	r3, r1
 8001b16:	607a      	str	r2, [r7, #4]
 8001b18:	72fb      	strb	r3, [r7, #11]
  struct shell_input *input;
  uint16_t *ptr;
  int i;
  char buf[57], *bufptr;

  PROCESS_BEGIN();
 8001b1a:	2301      	movs	r3, #1
 8001b1c:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53
 8001b20:	68fb      	ldr	r3, [r7, #12]
 8001b22:	881b      	ldrh	r3, [r3, #0]
 8001b24:	2b00      	cmp	r3, #0
 8001b26:	d003      	beq.n	8001b30 <process_thread_shell_hd_process+0x24>
 8001b28:	2b5d      	cmp	r3, #93	; 0x5d
 8001b2a:	d007      	beq.n	8001b3c <process_thread_shell_hd_process+0x30>
 8001b2c:	e0af      	b.n	8001c8e <process_thread_shell_hd_process+0x182>
    }
    if(bufptr != buf) {
      shell_output_str(&hd_command, buf, "");
    }
    
  }
 8001b2e:	bf00      	nop
  char buf[57], *bufptr;

  PROCESS_BEGIN();

  while(1) {
    PROCESS_WAIT_EVENT_UNTIL(ev == shell_event_input);
 8001b30:	2300      	movs	r3, #0
 8001b32:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53
 8001b36:	68fb      	ldr	r3, [r7, #12]
 8001b38:	225d      	movs	r2, #93	; 0x5d
 8001b3a:	801a      	strh	r2, [r3, #0]
 8001b3c:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 8001b40:	2b00      	cmp	r3, #0
 8001b42:	d007      	beq.n	8001b54 <process_thread_shell_hd_process+0x48>
 8001b44:	7afa      	ldrb	r2, [r7, #11]
 8001b46:	f241 63f8 	movw	r3, #5880	; 0x16f8
 8001b4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b4e:	681b      	ldr	r3, [r3, #0]
 8001b50:	429a      	cmp	r2, r3
 8001b52:	d001      	beq.n	8001b58 <process_thread_shell_hd_process+0x4c>
 8001b54:	2301      	movs	r3, #1
 8001b56:	e0a1      	b.n	8001c9c <process_thread_shell_hd_process+0x190>
    input = data;
 8001b58:	687b      	ldr	r3, [r7, #4]
 8001b5a:	64fb      	str	r3, [r7, #76]	; 0x4c

    if(input->len1 + input->len2 == 0) {
 8001b5c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8001b5e:	689a      	ldr	r2, [r3, #8]
 8001b60:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8001b62:	68db      	ldr	r3, [r3, #12]
 8001b64:	18d3      	adds	r3, r2, r3
 8001b66:	2b00      	cmp	r3, #0
 8001b68:	d104      	bne.n	8001b74 <process_thread_shell_hd_process+0x68>
      PROCESS_EXIT();
 8001b6a:	68fb      	ldr	r3, [r7, #12]
 8001b6c:	2200      	movs	r2, #0
 8001b6e:	801a      	strh	r2, [r3, #0]
 8001b70:	2302      	movs	r3, #2
 8001b72:	e093      	b.n	8001c9c <process_thread_shell_hd_process+0x190>
    }

    bufptr = buf;
 8001b74:	f107 0310 	add.w	r3, r7, #16
 8001b78:	657b      	str	r3, [r7, #84]	; 0x54
    ptr = (uint16_t *)input->data1;
 8001b7a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8001b7c:	681b      	ldr	r3, [r3, #0]
 8001b7e:	65fb      	str	r3, [r7, #92]	; 0x5c
    for(i = 0; i < input->len1 && i < input->len1 - 1; i += 2) {
 8001b80:	2300      	movs	r3, #0
 8001b82:	65bb      	str	r3, [r7, #88]	; 0x58
 8001b84:	e029      	b.n	8001bda <process_thread_shell_hd_process+0xce>
      bufptr += sprintf(bufptr, "0x%04x ", *ptr);
 8001b86:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001b88:	881b      	ldrh	r3, [r3, #0]
 8001b8a:	6d78      	ldr	r0, [r7, #84]	; 0x54
 8001b8c:	f648 31c4 	movw	r1, #35780	; 0x8bc4
 8001b90:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001b94:	461a      	mov	r2, r3
 8001b96:	f006 fe09 	bl	80087ac <sprintf>
 8001b9a:	4603      	mov	r3, r0
 8001b9c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8001b9e:	18d3      	adds	r3, r2, r3
 8001ba0:	657b      	str	r3, [r7, #84]	; 0x54
      if(bufptr - buf >= sizeof(buf) - 7) {
 8001ba2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8001ba4:	f107 0310 	add.w	r3, r7, #16
 8001ba8:	1ad3      	subs	r3, r2, r3
 8001baa:	2b31      	cmp	r3, #49	; 0x31
 8001bac:	d90f      	bls.n	8001bce <process_thread_shell_hd_process+0xc2>
	shell_output_str(&hd_command, buf, "");
 8001bae:	f107 0310 	add.w	r3, r7, #16
 8001bb2:	f240 604c 	movw	r0, #1612	; 0x64c
 8001bb6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001bba:	4619      	mov	r1, r3
 8001bbc:	f648 32c0 	movw	r2, #35776	; 0x8bc0
 8001bc0:	f6c0 0200 	movt	r2, #2048	; 0x800
 8001bc4:	f7ff fb32 	bl	800122c <shell_output_str>
	bufptr = buf;
 8001bc8:	f107 0310 	add.w	r3, r7, #16
 8001bcc:	657b      	str	r3, [r7, #84]	; 0x54
      }
      ptr++;
 8001bce:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001bd0:	3302      	adds	r3, #2
 8001bd2:	65fb      	str	r3, [r7, #92]	; 0x5c
      PROCESS_EXIT();
    }

    bufptr = buf;
    ptr = (uint16_t *)input->data1;
    for(i = 0; i < input->len1 && i < input->len1 - 1; i += 2) {
 8001bd4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8001bd6:	3302      	adds	r3, #2
 8001bd8:	65bb      	str	r3, [r7, #88]	; 0x58
 8001bda:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8001bdc:	689a      	ldr	r2, [r3, #8]
 8001bde:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8001be0:	429a      	cmp	r2, r3
 8001be2:	dd05      	ble.n	8001bf0 <process_thread_shell_hd_process+0xe4>
 8001be4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8001be6:	689b      	ldr	r3, [r3, #8]
 8001be8:	1e5a      	subs	r2, r3, #1
 8001bea:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8001bec:	429a      	cmp	r2, r3
 8001bee:	dcca      	bgt.n	8001b86 <process_thread_shell_hd_process+0x7a>
	bufptr = buf;
      }
      ptr++;
    }

    ptr = (uint16_t *)input->data2;
 8001bf0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8001bf2:	685b      	ldr	r3, [r3, #4]
 8001bf4:	65fb      	str	r3, [r7, #92]	; 0x5c
    for(i = 0; i < input->len2 && i < input->len2 - 1; i += 2) {
 8001bf6:	2300      	movs	r3, #0
 8001bf8:	65bb      	str	r3, [r7, #88]	; 0x58
 8001bfa:	e029      	b.n	8001c50 <process_thread_shell_hd_process+0x144>
      bufptr += sprintf(bufptr, "0x%04x ", *ptr);
 8001bfc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001bfe:	881b      	ldrh	r3, [r3, #0]
 8001c00:	6d78      	ldr	r0, [r7, #84]	; 0x54
 8001c02:	f648 31c4 	movw	r1, #35780	; 0x8bc4
 8001c06:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001c0a:	461a      	mov	r2, r3
 8001c0c:	f006 fdce 	bl	80087ac <sprintf>
 8001c10:	4603      	mov	r3, r0
 8001c12:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8001c14:	18d3      	adds	r3, r2, r3
 8001c16:	657b      	str	r3, [r7, #84]	; 0x54
      if(bufptr - buf >= sizeof(buf) - 7) {
 8001c18:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8001c1a:	f107 0310 	add.w	r3, r7, #16
 8001c1e:	1ad3      	subs	r3, r2, r3
 8001c20:	2b31      	cmp	r3, #49	; 0x31
 8001c22:	d90f      	bls.n	8001c44 <process_thread_shell_hd_process+0x138>
	shell_output_str(&hd_command, buf, "");
 8001c24:	f107 0310 	add.w	r3, r7, #16
 8001c28:	f240 604c 	movw	r0, #1612	; 0x64c
 8001c2c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001c30:	4619      	mov	r1, r3
 8001c32:	f648 32c0 	movw	r2, #35776	; 0x8bc0
 8001c36:	f6c0 0200 	movt	r2, #2048	; 0x800
 8001c3a:	f7ff faf7 	bl	800122c <shell_output_str>
	bufptr = buf;
 8001c3e:	f107 0310 	add.w	r3, r7, #16
 8001c42:	657b      	str	r3, [r7, #84]	; 0x54
      }
      ptr++;
 8001c44:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001c46:	3302      	adds	r3, #2
 8001c48:	65fb      	str	r3, [r7, #92]	; 0x5c
      }
      ptr++;
    }

    ptr = (uint16_t *)input->data2;
    for(i = 0; i < input->len2 && i < input->len2 - 1; i += 2) {
 8001c4a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8001c4c:	3302      	adds	r3, #2
 8001c4e:	65bb      	str	r3, [r7, #88]	; 0x58
 8001c50:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8001c52:	68da      	ldr	r2, [r3, #12]
 8001c54:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8001c56:	429a      	cmp	r2, r3
 8001c58:	dd05      	ble.n	8001c66 <process_thread_shell_hd_process+0x15a>
 8001c5a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8001c5c:	68db      	ldr	r3, [r3, #12]
 8001c5e:	1e5a      	subs	r2, r3, #1
 8001c60:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8001c62:	429a      	cmp	r2, r3
 8001c64:	dcca      	bgt.n	8001bfc <process_thread_shell_hd_process+0xf0>
	shell_output_str(&hd_command, buf, "");
	bufptr = buf;
      }
      ptr++;
    }
    if(bufptr != buf) {
 8001c66:	f107 0310 	add.w	r3, r7, #16
 8001c6a:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8001c6c:	429a      	cmp	r2, r3
 8001c6e:	f43f af5e 	beq.w	8001b2e <process_thread_shell_hd_process+0x22>
      shell_output_str(&hd_command, buf, "");
 8001c72:	f107 0310 	add.w	r3, r7, #16
 8001c76:	f240 604c 	movw	r0, #1612	; 0x64c
 8001c7a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001c7e:	4619      	mov	r1, r3
 8001c80:	f648 32c0 	movw	r2, #35776	; 0x8bc0
 8001c84:	f6c0 0200 	movt	r2, #2048	; 0x800
 8001c88:	f7ff fad0 	bl	800122c <shell_output_str>
    }
    
  }
 8001c8c:	e74f      	b.n	8001b2e <process_thread_shell_hd_process+0x22>
  PROCESS_END();
 8001c8e:	2300      	movs	r3, #0
 8001c90:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53
 8001c94:	68fb      	ldr	r3, [r7, #12]
 8001c96:	2200      	movs	r2, #0
 8001c98:	801a      	strh	r2, [r3, #0]
 8001c9a:	2303      	movs	r3, #3
}
 8001c9c:	4618      	mov	r0, r3
 8001c9e:	f107 0760 	add.w	r7, r7, #96	; 0x60
 8001ca2:	46bd      	mov	sp, r7
 8001ca4:	bd80      	pop	{r7, pc}
 8001ca6:	bf00      	nop

08001ca8 <process_thread_shell_binprint_process>:
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_binprint_process, ev, data)
{
 8001ca8:	b580      	push	{r7, lr}
 8001caa:	b0aa      	sub	sp, #168	; 0xa8
 8001cac:	af00      	add	r7, sp, #0
 8001cae:	60f8      	str	r0, [r7, #12]
 8001cb0:	460b      	mov	r3, r1
 8001cb2:	607a      	str	r2, [r7, #4]
 8001cb4:	72fb      	strb	r3, [r7, #11]
  uint16_t *ptr;
  int i;
  char buf[2*64], *bufptr;
  uint16_t val;

  PROCESS_BEGIN();
 8001cb6:	2301      	movs	r3, #1
 8001cb8:	f887 309b 	strb.w	r3, [r7, #155]	; 0x9b
 8001cbc:	68fb      	ldr	r3, [r7, #12]
 8001cbe:	881b      	ldrh	r3, [r3, #0]
 8001cc0:	2b00      	cmp	r3, #0
 8001cc2:	d003      	beq.n	8001ccc <process_thread_shell_binprint_process+0x24>
 8001cc4:	2b8b      	cmp	r3, #139	; 0x8b
 8001cc6:	d007      	beq.n	8001cd8 <process_thread_shell_binprint_process+0x30>
 8001cc8:	e0e2      	b.n	8001e90 <process_thread_shell_binprint_process+0x1e8>
    
    if(bufptr != buf) {
      shell_output_str(&binprint_command, buf, "");
    }
    
  }
 8001cca:	bf00      	nop
  uint16_t val;

  PROCESS_BEGIN();

  while(1) {
    PROCESS_WAIT_EVENT_UNTIL(ev == shell_event_input);
 8001ccc:	2300      	movs	r3, #0
 8001cce:	f887 309b 	strb.w	r3, [r7, #155]	; 0x9b
 8001cd2:	68fb      	ldr	r3, [r7, #12]
 8001cd4:	228b      	movs	r2, #139	; 0x8b
 8001cd6:	801a      	strh	r2, [r3, #0]
 8001cd8:	f897 309b 	ldrb.w	r3, [r7, #155]	; 0x9b
 8001cdc:	2b00      	cmp	r3, #0
 8001cde:	d007      	beq.n	8001cf0 <process_thread_shell_binprint_process+0x48>
 8001ce0:	7afa      	ldrb	r2, [r7, #11]
 8001ce2:	f241 63f8 	movw	r3, #5880	; 0x16f8
 8001ce6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001cea:	681b      	ldr	r3, [r3, #0]
 8001cec:	429a      	cmp	r2, r3
 8001cee:	d001      	beq.n	8001cf4 <process_thread_shell_binprint_process+0x4c>
 8001cf0:	2301      	movs	r3, #1
 8001cf2:	e0d4      	b.n	8001e9e <process_thread_shell_binprint_process+0x1f6>
    input = data;
 8001cf4:	687b      	ldr	r3, [r7, #4]
 8001cf6:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

    if(input->len1 + input->len2 == 0) {
 8001cfa:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8001cfe:	689a      	ldr	r2, [r3, #8]
 8001d00:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8001d04:	68db      	ldr	r3, [r3, #12]
 8001d06:	18d3      	adds	r3, r2, r3
 8001d08:	2b00      	cmp	r3, #0
 8001d0a:	d104      	bne.n	8001d16 <process_thread_shell_binprint_process+0x6e>
      PROCESS_EXIT();
 8001d0c:	68fb      	ldr	r3, [r7, #12]
 8001d0e:	2200      	movs	r2, #0
 8001d10:	801a      	strh	r2, [r3, #0]
 8001d12:	2302      	movs	r3, #2
 8001d14:	e0c3      	b.n	8001e9e <process_thread_shell_binprint_process+0x1f6>
    }

    bufptr = buf;
 8001d16:	f107 0314 	add.w	r3, r7, #20
 8001d1a:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    ptr = (uint16_t *)input->data1;
 8001d1e:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8001d22:	681b      	ldr	r3, [r3, #0]
 8001d24:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    for(i = 0; i < input->len1 && i < input->len1 - 1; i += 2) {
 8001d28:	2300      	movs	r3, #0
 8001d2a:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8001d2e:	e039      	b.n	8001da4 <process_thread_shell_binprint_process+0xfc>
      memcpy(&val, ptr, sizeof(val));
 8001d30:	f107 0312 	add.w	r3, r7, #18
 8001d34:	4618      	mov	r0, r3
 8001d36:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
 8001d3a:	2202      	movs	r2, #2
 8001d3c:	f7fe fabd 	bl	80002ba <memcpy>
      bufptr += sprintf(bufptr, "%u ", val);
 8001d40:	8a7b      	ldrh	r3, [r7, #18]
 8001d42:	f8d7 009c 	ldr.w	r0, [r7, #156]	; 0x9c
 8001d46:	f648 31cc 	movw	r1, #35788	; 0x8bcc
 8001d4a:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001d4e:	461a      	mov	r2, r3
 8001d50:	f006 fd2c 	bl	80087ac <sprintf>
 8001d54:	4603      	mov	r3, r0
 8001d56:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8001d5a:	18d3      	adds	r3, r2, r3
 8001d5c:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
      if(bufptr - buf >= sizeof(buf) - 6) {
 8001d60:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8001d64:	f107 0314 	add.w	r3, r7, #20
 8001d68:	1ad3      	subs	r3, r2, r3
 8001d6a:	2b79      	cmp	r3, #121	; 0x79
 8001d6c:	d910      	bls.n	8001d90 <process_thread_shell_binprint_process+0xe8>
	shell_output_str(&binprint_command, buf, "");
 8001d6e:	f107 0314 	add.w	r3, r7, #20
 8001d72:	f240 6028 	movw	r0, #1576	; 0x628
 8001d76:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001d7a:	4619      	mov	r1, r3
 8001d7c:	f648 32c0 	movw	r2, #35776	; 0x8bc0
 8001d80:	f6c0 0200 	movt	r2, #2048	; 0x800
 8001d84:	f7ff fa52 	bl	800122c <shell_output_str>
	bufptr = buf;
 8001d88:	f107 0314 	add.w	r3, r7, #20
 8001d8c:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
      }
      ptr++;
 8001d90:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8001d94:	3302      	adds	r3, #2
 8001d96:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
      PROCESS_EXIT();
    }

    bufptr = buf;
    ptr = (uint16_t *)input->data1;
    for(i = 0; i < input->len1 && i < input->len1 - 1; i += 2) {
 8001d9a:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8001d9e:	3302      	adds	r3, #2
 8001da0:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8001da4:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8001da8:	689a      	ldr	r2, [r3, #8]
 8001daa:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8001dae:	429a      	cmp	r2, r3
 8001db0:	dd07      	ble.n	8001dc2 <process_thread_shell_binprint_process+0x11a>
 8001db2:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8001db6:	689b      	ldr	r3, [r3, #8]
 8001db8:	1e5a      	subs	r2, r3, #1
 8001dba:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8001dbe:	429a      	cmp	r2, r3
 8001dc0:	dcb6      	bgt.n	8001d30 <process_thread_shell_binprint_process+0x88>
    }

    /* XXX need to check if input->len1 == 1 here, and then shift this
       byte into the sequence of 16-bitters below. */
    
    ptr = (uint16_t *)input->data2;
 8001dc2:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8001dc6:	685b      	ldr	r3, [r3, #4]
 8001dc8:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    for(i = 0; i < input->len2 && i < input->len2 - 1; i += 2) {
 8001dcc:	2300      	movs	r3, #0
 8001dce:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8001dd2:	e039      	b.n	8001e48 <process_thread_shell_binprint_process+0x1a0>
      memcpy(&val, ptr, sizeof(val));
 8001dd4:	f107 0312 	add.w	r3, r7, #18
 8001dd8:	4618      	mov	r0, r3
 8001dda:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
 8001dde:	2202      	movs	r2, #2
 8001de0:	f7fe fa6b 	bl	80002ba <memcpy>
      bufptr += sprintf(bufptr, "%u ", val);
 8001de4:	8a7b      	ldrh	r3, [r7, #18]
 8001de6:	f8d7 009c 	ldr.w	r0, [r7, #156]	; 0x9c
 8001dea:	f648 31cc 	movw	r1, #35788	; 0x8bcc
 8001dee:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001df2:	461a      	mov	r2, r3
 8001df4:	f006 fcda 	bl	80087ac <sprintf>
 8001df8:	4603      	mov	r3, r0
 8001dfa:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8001dfe:	18d3      	adds	r3, r2, r3
 8001e00:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
      if(bufptr - buf >= sizeof(buf) - 6) {
 8001e04:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8001e08:	f107 0314 	add.w	r3, r7, #20
 8001e0c:	1ad3      	subs	r3, r2, r3
 8001e0e:	2b79      	cmp	r3, #121	; 0x79
 8001e10:	d910      	bls.n	8001e34 <process_thread_shell_binprint_process+0x18c>
	shell_output_str(&binprint_command, buf, "");
 8001e12:	f107 0314 	add.w	r3, r7, #20
 8001e16:	f240 6028 	movw	r0, #1576	; 0x628
 8001e1a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001e1e:	4619      	mov	r1, r3
 8001e20:	f648 32c0 	movw	r2, #35776	; 0x8bc0
 8001e24:	f6c0 0200 	movt	r2, #2048	; 0x800
 8001e28:	f7ff fa00 	bl	800122c <shell_output_str>
	bufptr = buf;
 8001e2c:	f107 0314 	add.w	r3, r7, #20
 8001e30:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
      }
      ptr++;
 8001e34:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8001e38:	3302      	adds	r3, #2
 8001e3a:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4

    /* XXX need to check if input->len1 == 1 here, and then shift this
       byte into the sequence of 16-bitters below. */
    
    ptr = (uint16_t *)input->data2;
    for(i = 0; i < input->len2 && i < input->len2 - 1; i += 2) {
 8001e3e:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8001e42:	3302      	adds	r3, #2
 8001e44:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8001e48:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8001e4c:	68da      	ldr	r2, [r3, #12]
 8001e4e:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8001e52:	429a      	cmp	r2, r3
 8001e54:	dd07      	ble.n	8001e66 <process_thread_shell_binprint_process+0x1be>
 8001e56:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8001e5a:	68db      	ldr	r3, [r3, #12]
 8001e5c:	1e5a      	subs	r2, r3, #1
 8001e5e:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8001e62:	429a      	cmp	r2, r3
 8001e64:	dcb6      	bgt.n	8001dd4 <process_thread_shell_binprint_process+0x12c>
	bufptr = buf;
      }
      ptr++;
    }
    
    if(bufptr != buf) {
 8001e66:	f107 0314 	add.w	r3, r7, #20
 8001e6a:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8001e6e:	429a      	cmp	r2, r3
 8001e70:	f43f af2b 	beq.w	8001cca <process_thread_shell_binprint_process+0x22>
      shell_output_str(&binprint_command, buf, "");
 8001e74:	f107 0314 	add.w	r3, r7, #20
 8001e78:	f240 6028 	movw	r0, #1576	; 0x628
 8001e7c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001e80:	4619      	mov	r1, r3
 8001e82:	f648 32c0 	movw	r2, #35776	; 0x8bc0
 8001e86:	f6c0 0200 	movt	r2, #2048	; 0x800
 8001e8a:	f7ff f9cf 	bl	800122c <shell_output_str>
    }
    
  }
 8001e8e:	e71c      	b.n	8001cca <process_thread_shell_binprint_process+0x22>
  PROCESS_END();
 8001e90:	2300      	movs	r3, #0
 8001e92:	f887 309b 	strb.w	r3, [r7, #155]	; 0x9b
 8001e96:	68fb      	ldr	r3, [r7, #12]
 8001e98:	2200      	movs	r2, #0
 8001e9a:	801a      	strh	r2, [r3, #0]
 8001e9c:	2303      	movs	r3, #3
}
 8001e9e:	4618      	mov	r0, r3
 8001ea0:	f107 07a8 	add.w	r7, r7, #168	; 0xa8
 8001ea4:	46bd      	mov	sp, r7
 8001ea6:	bd80      	pop	{r7, pc}

08001ea8 <process_thread_shell_size_process>:
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_size_process, ev, data)
{
 8001ea8:	b580      	push	{r7, lr}
 8001eaa:	b08a      	sub	sp, #40	; 0x28
 8001eac:	af00      	add	r7, sp, #0
 8001eae:	60f8      	str	r0, [r7, #12]
 8001eb0:	460b      	mov	r3, r1
 8001eb2:	607a      	str	r2, [r7, #4]
 8001eb4:	72fb      	strb	r3, [r7, #11]
  static unsigned long size;
  struct shell_input *input;
  char buf[10];
  
  PROCESS_BEGIN();
 8001eb6:	2301      	movs	r3, #1
 8001eb8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8001ebc:	68fb      	ldr	r3, [r7, #12]
 8001ebe:	881b      	ldrh	r3, [r3, #0]
 8001ec0:	2b00      	cmp	r3, #0
 8001ec2:	d002      	beq.n	8001eca <process_thread_shell_size_process+0x22>
 8001ec4:	2bbe      	cmp	r3, #190	; 0xbe
 8001ec6:	d00e      	beq.n	8001ee6 <process_thread_shell_size_process+0x3e>
 8001ec8:	e056      	b.n	8001f78 <process_thread_shell_size_process+0xd0>
  size = 0;
 8001eca:	f241 130c 	movw	r3, #4364	; 0x110c
 8001ece:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001ed2:	2200      	movs	r2, #0
 8001ed4:	601a      	str	r2, [r3, #0]
 8001ed6:	e000      	b.n	8001eda <process_thread_shell_size_process+0x32>
    if(input->len1 + input->len2 == 0) {
      snprintf(buf, sizeof(buf), "%lu", size);
      shell_output_str(&size_command, buf, "");
      PROCESS_EXIT();
    }
  }
 8001ed8:	bf00      	nop
  
  PROCESS_BEGIN();
  size = 0;
  
  while(1) {
    PROCESS_WAIT_EVENT_UNTIL(ev == shell_event_input);
 8001eda:	2300      	movs	r3, #0
 8001edc:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8001ee0:	68fb      	ldr	r3, [r7, #12]
 8001ee2:	22be      	movs	r2, #190	; 0xbe
 8001ee4:	801a      	strh	r2, [r3, #0]
 8001ee6:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8001eea:	2b00      	cmp	r3, #0
 8001eec:	d007      	beq.n	8001efe <process_thread_shell_size_process+0x56>
 8001eee:	7afa      	ldrb	r2, [r7, #11]
 8001ef0:	f241 63f8 	movw	r3, #5880	; 0x16f8
 8001ef4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001ef8:	681b      	ldr	r3, [r3, #0]
 8001efa:	429a      	cmp	r2, r3
 8001efc:	d001      	beq.n	8001f02 <process_thread_shell_size_process+0x5a>
 8001efe:	2301      	movs	r3, #1
 8001f00:	e041      	b.n	8001f86 <process_thread_shell_size_process+0xde>
    input = data;
 8001f02:	687b      	ldr	r3, [r7, #4]
 8001f04:	623b      	str	r3, [r7, #32]

    size += input->len1 + input->len2;
 8001f06:	6a3b      	ldr	r3, [r7, #32]
 8001f08:	689a      	ldr	r2, [r3, #8]
 8001f0a:	6a3b      	ldr	r3, [r7, #32]
 8001f0c:	68db      	ldr	r3, [r3, #12]
 8001f0e:	18d3      	adds	r3, r2, r3
 8001f10:	461a      	mov	r2, r3
 8001f12:	f241 130c 	movw	r3, #4364	; 0x110c
 8001f16:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001f1a:	681b      	ldr	r3, [r3, #0]
 8001f1c:	18d2      	adds	r2, r2, r3
 8001f1e:	f241 130c 	movw	r3, #4364	; 0x110c
 8001f22:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001f26:	601a      	str	r2, [r3, #0]
    
    if(input->len1 + input->len2 == 0) {
 8001f28:	6a3b      	ldr	r3, [r7, #32]
 8001f2a:	689a      	ldr	r2, [r3, #8]
 8001f2c:	6a3b      	ldr	r3, [r7, #32]
 8001f2e:	68db      	ldr	r3, [r3, #12]
 8001f30:	18d3      	adds	r3, r2, r3
 8001f32:	2b00      	cmp	r3, #0
 8001f34:	d1d0      	bne.n	8001ed8 <process_thread_shell_size_process+0x30>
      snprintf(buf, sizeof(buf), "%lu", size);
 8001f36:	f241 130c 	movw	r3, #4364	; 0x110c
 8001f3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001f3e:	681b      	ldr	r3, [r3, #0]
 8001f40:	f107 0214 	add.w	r2, r7, #20
 8001f44:	4610      	mov	r0, r2
 8001f46:	210a      	movs	r1, #10
 8001f48:	f648 32d0 	movw	r2, #35792	; 0x8bd0
 8001f4c:	f6c0 0200 	movt	r2, #2048	; 0x800
 8001f50:	f006 fc50 	bl	80087f4 <snprintf>
      shell_output_str(&size_command, buf, "");
 8001f54:	f107 0314 	add.w	r3, r7, #20
 8001f58:	f240 6070 	movw	r0, #1648	; 0x670
 8001f5c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001f60:	4619      	mov	r1, r3
 8001f62:	f648 32c0 	movw	r2, #35776	; 0x8bc0
 8001f66:	f6c0 0200 	movt	r2, #2048	; 0x800
 8001f6a:	f7ff f95f 	bl	800122c <shell_output_str>
      PROCESS_EXIT();
 8001f6e:	68fb      	ldr	r3, [r7, #12]
 8001f70:	2200      	movs	r2, #0
 8001f72:	801a      	strh	r2, [r3, #0]
 8001f74:	2302      	movs	r3, #2
 8001f76:	e006      	b.n	8001f86 <process_thread_shell_size_process+0xde>
    }
  }
  PROCESS_END();
 8001f78:	2300      	movs	r3, #0
 8001f7a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8001f7e:	68fb      	ldr	r3, [r7, #12]
 8001f80:	2200      	movs	r2, #0
 8001f82:	801a      	strh	r2, [r3, #0]
 8001f84:	2303      	movs	r3, #3
}
 8001f86:	4618      	mov	r0, r3
 8001f88:	f107 0728 	add.w	r7, r7, #40	; 0x28
 8001f8c:	46bd      	mov	sp, r7
 8001f8e:	bd80      	pop	{r7, pc}

08001f90 <shell_text_init>:
/*---------------------------------------------------------------------------*/
void
shell_text_init(void)
{
 8001f90:	b580      	push	{r7, lr}
 8001f92:	af00      	add	r7, sp, #0
  shell_register_command(&binprint_command);
 8001f94:	f240 6028 	movw	r0, #1576	; 0x628
 8001f98:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001f9c:	f7ff f99c 	bl	80012d8 <shell_register_command>
  shell_register_command(&hd_command);
 8001fa0:	f240 604c 	movw	r0, #1612	; 0x64c
 8001fa4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001fa8:	f7ff f996 	bl	80012d8 <shell_register_command>
  shell_register_command(&echo_command);
 8001fac:	f240 6004 	movw	r0, #1540	; 0x604
 8001fb0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001fb4:	f7ff f990 	bl	80012d8 <shell_register_command>
  shell_register_command(&size_command);
 8001fb8:	f240 6070 	movw	r0, #1648	; 0x670
 8001fbc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001fc0:	f7ff f98a 	bl	80012d8 <shell_register_command>
}
 8001fc4:	bd80      	pop	{r7, pc}
 8001fc6:	bf00      	nop

08001fc8 <process_thread_shell_time_process>:
	      "randwait",
	      "randwait <maxtime> <command>: wait for a random time before running a command",
	      &shell_randwait_process);
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_time_process, ev, data)
{
 8001fc8:	b580      	push	{r7, lr}
 8001fca:	b08e      	sub	sp, #56	; 0x38
 8001fcc:	af02      	add	r7, sp, #8
 8001fce:	60f8      	str	r0, [r7, #12]
 8001fd0:	460b      	mov	r3, r1
 8001fd2:	607a      	str	r2, [r7, #4]
 8001fd4:	72fb      	strb	r3, [r7, #11]
    uint16_t time[2];
  } msg;
  unsigned long newtime;
  const char *nextptr;
  
  PROCESS_BEGIN();
 8001fd6:	2301      	movs	r3, #1
 8001fd8:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8001fdc:	68fb      	ldr	r3, [r7, #12]
 8001fde:	881b      	ldrh	r3, [r3, #0]
 8001fe0:	2b00      	cmp	r3, #0
 8001fe2:	d13c      	bne.n	800205e <process_thread_shell_time_process+0x96>

  if(data != NULL) {
 8001fe4:	687b      	ldr	r3, [r7, #4]
 8001fe6:	2b00      	cmp	r3, #0
 8001fe8:	d00d      	beq.n	8002006 <process_thread_shell_time_process+0x3e>
    newtime = shell_strtolong(data, &nextptr);
 8001fea:	f107 0314 	add.w	r3, r7, #20
 8001fee:	6878      	ldr	r0, [r7, #4]
 8001ff0:	4619      	mov	r1, r3
 8001ff2:	f7ff fb39 	bl	8001668 <shell_strtolong>
 8001ff6:	62b8      	str	r0, [r7, #40]	; 0x28
    if(data != nextptr) {
 8001ff8:	697b      	ldr	r3, [r7, #20]
 8001ffa:	687a      	ldr	r2, [r7, #4]
 8001ffc:	429a      	cmp	r2, r3
 8001ffe:	d002      	beq.n	8002006 <process_thread_shell_time_process+0x3e>
      shell_set_time(newtime);
 8002000:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8002002:	f7ff fb93 	bl	800172c <shell_set_time>
    }
  }
  
  msg.clock = (uint16_t)clock_time();
 8002006:	f001 f91f 	bl	8003248 <clock_time>
 800200a:	4603      	mov	r3, r0
 800200c:	b29b      	uxth	r3, r3
 800200e:	837b      	strh	r3, [r7, #26]
  msg.rtimer = (uint16_t)RTIMER_NOW();
 8002010:	f001 f91a 	bl	8003248 <clock_time>
 8002014:	4603      	mov	r3, r0
 8002016:	b29b      	uxth	r3, r3
 8002018:	83bb      	strh	r3, [r7, #28]
#if TIMESYNCH_CONF_ENABLED
  msg.timesynch = timesynch_time();
  msg.timesynch_authority = timesynch_authority_level();
#else
  msg.timesynch = 0;
 800201a:	2300      	movs	r3, #0
 800201c:	83fb      	strh	r3, [r7, #30]
  msg.timesynch_authority = -1;
 800201e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8002022:	843b      	strh	r3, [r7, #32]
#endif
  msg.time[0] = (uint16_t)(shell_time() >> 16);
 8002024:	f7ff fb74 	bl	8001710 <shell_time>
 8002028:	4603      	mov	r3, r0
 800202a:	0c1b      	lsrs	r3, r3, #16
 800202c:	b29b      	uxth	r3, r3
 800202e:	847b      	strh	r3, [r7, #34]	; 0x22
  msg.time[1] = (uint16_t)(shell_time());
 8002030:	f7ff fb6e 	bl	8001710 <shell_time>
 8002034:	4603      	mov	r3, r0
 8002036:	b29b      	uxth	r3, r3
 8002038:	84bb      	strh	r3, [r7, #36]	; 0x24
  msg.len = 6;
 800203a:	2306      	movs	r3, #6
 800203c:	833b      	strh	r3, [r7, #24]

  shell_output(&time_command, &msg, sizeof(msg), "", 0);
 800203e:	f107 0318 	add.w	r3, r7, #24
 8002042:	2200      	movs	r2, #0
 8002044:	9200      	str	r2, [sp, #0]
 8002046:	f240 6094 	movw	r0, #1684	; 0x694
 800204a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800204e:	4619      	mov	r1, r3
 8002050:	220e      	movs	r2, #14
 8002052:	f648 5318 	movw	r3, #36120	; 0x8d18
 8002056:	f6c0 0300 	movt	r3, #2048	; 0x800
 800205a:	f7ff f919 	bl	8001290 <shell_output>

  PROCESS_END();
 800205e:	2300      	movs	r3, #0
 8002060:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8002064:	68fb      	ldr	r3, [r7, #12]
 8002066:	2200      	movs	r2, #0
 8002068:	801a      	strh	r2, [r3, #0]
 800206a:	2303      	movs	r3, #3
}
 800206c:	4618      	mov	r0, r3
 800206e:	f107 0730 	add.w	r7, r7, #48	; 0x30
 8002072:	46bd      	mov	sp, r7
 8002074:	bd80      	pop	{r7, pc}
 8002076:	bf00      	nop

08002078 <process_thread_shell_timestamp_process>:
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_timestamp_process, ev, data)
{
 8002078:	b580      	push	{r7, lr}
 800207a:	b09a      	sub	sp, #104	; 0x68
 800207c:	af02      	add	r7, sp, #8
 800207e:	60f8      	str	r0, [r7, #12]
 8002080:	460b      	mov	r3, r1
 8002082:	607a      	str	r2, [r7, #4]
 8002084:	72fb      	strb	r3, [r7, #11]
    uint16_t time[2];
    uint16_t timesynch;
    uint8_t data[MAX_COMMANDLENGTH];
  } msg;
  
  PROCESS_BEGIN();
 8002086:	2301      	movs	r3, #1
 8002088:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
 800208c:	68fb      	ldr	r3, [r7, #12]
 800208e:	881b      	ldrh	r3, [r3, #0]
 8002090:	2b00      	cmp	r3, #0
 8002092:	d002      	beq.n	800209a <process_thread_shell_timestamp_process+0x22>
 8002094:	2b88      	cmp	r3, #136	; 0x88
 8002096:	d006      	beq.n	80020a6 <process_thread_shell_timestamp_process+0x2e>
 8002098:	e056      	b.n	8002148 <process_thread_shell_timestamp_process+0xd0>

  while(1) {
    PROCESS_WAIT_EVENT_UNTIL(ev == shell_event_input);
 800209a:	2300      	movs	r3, #0
 800209c:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
 80020a0:	68fb      	ldr	r3, [r7, #12]
 80020a2:	2288      	movs	r2, #136	; 0x88
 80020a4:	801a      	strh	r2, [r3, #0]
 80020a6:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 80020aa:	2b00      	cmp	r3, #0
 80020ac:	d007      	beq.n	80020be <process_thread_shell_timestamp_process+0x46>
 80020ae:	7afa      	ldrb	r2, [r7, #11]
 80020b0:	f241 63f8 	movw	r3, #5880	; 0x16f8
 80020b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80020b8:	681b      	ldr	r3, [r3, #0]
 80020ba:	429a      	cmp	r2, r3
 80020bc:	d001      	beq.n	80020c2 <process_thread_shell_timestamp_process+0x4a>
 80020be:	2301      	movs	r3, #1
 80020c0:	e049      	b.n	8002156 <process_thread_shell_timestamp_process+0xde>
    input = data;
 80020c2:	687b      	ldr	r3, [r7, #4]
 80020c4:	65bb      	str	r3, [r7, #88]	; 0x58
    if(input->len1 + input->len2 == 0) {
 80020c6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80020c8:	689a      	ldr	r2, [r3, #8]
 80020ca:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80020cc:	68db      	ldr	r3, [r3, #12]
 80020ce:	18d3      	adds	r3, r2, r3
 80020d0:	2b00      	cmp	r3, #0
 80020d2:	d104      	bne.n	80020de <process_thread_shell_timestamp_process+0x66>
      PROCESS_EXIT();
 80020d4:	68fb      	ldr	r3, [r7, #12]
 80020d6:	2200      	movs	r2, #0
 80020d8:	801a      	strh	r2, [r3, #0]
 80020da:	2302      	movs	r3, #2
 80020dc:	e03b      	b.n	8002156 <process_thread_shell_timestamp_process+0xde>
    }
    
    msg.len = 3 + *(uint16_t *)input->data1;
 80020de:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80020e0:	681b      	ldr	r3, [r3, #0]
 80020e2:	881b      	ldrh	r3, [r3, #0]
 80020e4:	3303      	adds	r3, #3
 80020e6:	b29b      	uxth	r3, r3
 80020e8:	823b      	strh	r3, [r7, #16]
    msg.time[0] = (uint16_t)(shell_time() >> 16);
 80020ea:	f7ff fb11 	bl	8001710 <shell_time>
 80020ee:	4603      	mov	r3, r0
 80020f0:	0c1b      	lsrs	r3, r3, #16
 80020f2:	b29b      	uxth	r3, r3
 80020f4:	827b      	strh	r3, [r7, #18]
    msg.time[1] = (uint16_t)(shell_time());
 80020f6:	f7ff fb0b 	bl	8001710 <shell_time>
 80020fa:	4603      	mov	r3, r0
 80020fc:	b29b      	uxth	r3, r3
 80020fe:	82bb      	strh	r3, [r7, #20]
#if TIMESYNCH_CONF_ENABLED
    msg.timesynch = timesynch_time();
#else /* TIMESYNCH_CONF_ENABLED */
    msg.timesynch = 0;
 8002100:	2300      	movs	r3, #0
 8002102:	82fb      	strh	r3, [r7, #22]
#endif /* TIMESYNCH_CONF_ENABLED */
    memcpy(msg.data, input->data1 + 2,
 8002104:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002106:	681b      	ldr	r3, [r3, #0]
 8002108:	1c9a      	adds	r2, r3, #2
	   input->len1 - 2 > MAX_COMMANDLENGTH?
	   MAX_COMMANDLENGTH: input->len1 - 2);
 800210a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800210c:	689b      	ldr	r3, [r3, #8]
 800210e:	3b02      	subs	r3, #2
 8002110:	2b40      	cmp	r3, #64	; 0x40
 8002112:	bfa8      	it	ge
 8002114:	2340      	movge	r3, #64	; 0x40
#if TIMESYNCH_CONF_ENABLED
    msg.timesynch = timesynch_time();
#else /* TIMESYNCH_CONF_ENABLED */
    msg.timesynch = 0;
#endif /* TIMESYNCH_CONF_ENABLED */
    memcpy(msg.data, input->data1 + 2,
 8002116:	f107 0110 	add.w	r1, r7, #16
 800211a:	3108      	adds	r1, #8
 800211c:	4608      	mov	r0, r1
 800211e:	4611      	mov	r1, r2
 8002120:	461a      	mov	r2, r3
 8002122:	f7fe f8ca 	bl	80002ba <memcpy>
	   input->len1 - 2 > MAX_COMMANDLENGTH?
	   MAX_COMMANDLENGTH: input->len1 - 2);
    
    shell_output(&timestamp_command, &msg, 6 + input->len1,
 8002126:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002128:	689b      	ldr	r3, [r3, #8]
 800212a:	1d9a      	adds	r2, r3, #6
		 input->data2, input->len2);
 800212c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800212e:	685b      	ldr	r3, [r3, #4]
 8002130:	6db9      	ldr	r1, [r7, #88]	; 0x58
#endif /* TIMESYNCH_CONF_ENABLED */
    memcpy(msg.data, input->data1 + 2,
	   input->len1 - 2 > MAX_COMMANDLENGTH?
	   MAX_COMMANDLENGTH: input->len1 - 2);
    
    shell_output(&timestamp_command, &msg, 6 + input->len1,
 8002132:	68c8      	ldr	r0, [r1, #12]
 8002134:	f107 0110 	add.w	r1, r7, #16
 8002138:	9000      	str	r0, [sp, #0]
 800213a:	f240 60b8 	movw	r0, #1720	; 0x6b8
 800213e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002142:	f7ff f8a5 	bl	8001290 <shell_output>
		 input->data2, input->len2);
  }
 8002146:	e7a8      	b.n	800209a <process_thread_shell_timestamp_process+0x22>

  PROCESS_END();
 8002148:	2300      	movs	r3, #0
 800214a:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
 800214e:	68fb      	ldr	r3, [r7, #12]
 8002150:	2200      	movs	r2, #0
 8002152:	801a      	strh	r2, [r3, #0]
 8002154:	2303      	movs	r3, #3
}
 8002156:	4618      	mov	r0, r3
 8002158:	f107 0760 	add.w	r7, r7, #96	; 0x60
 800215c:	46bd      	mov	sp, r7
 800215e:	bd80      	pop	{r7, pc}

08002160 <process_thread_shell_repeat_server_process>:
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_repeat_server_process, ev, data)
{
 8002160:	b580      	push	{r7, lr}
 8002162:	b096      	sub	sp, #88	; 0x58
 8002164:	af00      	add	r7, sp, #0
 8002166:	60f8      	str	r0, [r7, #12]
 8002168:	460b      	mov	r3, r1
 800216a:	607a      	str	r2, [r7, #4]
 800216c:	72fb      	strb	r3, [r7, #11]
  static char *command;
  static struct process *started_process;
  char command_copy[MAX_COMMANDLENGTH];
  int ret;

  if(ev == shell_event_input) {
 800216e:	7afa      	ldrb	r2, [r7, #11]
 8002170:	f241 63f8 	movw	r3, #5880	; 0x16f8
 8002174:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002178:	681b      	ldr	r3, [r3, #0]
 800217a:	429a      	cmp	r2, r3
 800217c:	d070      	beq.n	8002260 <process_thread_shell_repeat_server_process+0x100>
    goto exit;
  }
  
  PROCESS_BEGIN();
 800217e:	2301      	movs	r3, #1
 8002180:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
 8002184:	68fb      	ldr	r3, [r7, #12]
 8002186:	881b      	ldrh	r3, [r3, #0]
 8002188:	2bb1      	cmp	r3, #177	; 0xb1
 800218a:	d00f      	beq.n	80021ac <process_thread_shell_repeat_server_process+0x4c>
 800218c:	2bba      	cmp	r3, #186	; 0xba
 800218e:	d056      	beq.n	800223e <process_thread_shell_repeat_server_process+0xde>
 8002190:	2b00      	cmp	r3, #0
 8002192:	d166      	bne.n	8002262 <process_thread_shell_repeat_server_process+0x102>

  command = data;
 8002194:	f241 13c8 	movw	r3, #4552	; 0x11c8
 8002198:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800219c:	687a      	ldr	r2, [r7, #4]
 800219e:	601a      	str	r2, [r3, #0]
  
  PROCESS_WAIT_EVENT_UNTIL(ev == PROCESS_EVENT_CONTINUE &&
 80021a0:	2300      	movs	r3, #0
 80021a2:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
 80021a6:	68fb      	ldr	r3, [r7, #12]
 80021a8:	22b1      	movs	r2, #177	; 0xb1
 80021aa:	801a      	strh	r2, [r3, #0]
 80021ac:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 80021b0:	2b00      	cmp	r3, #0
 80021b2:	d009      	beq.n	80021c8 <process_thread_shell_repeat_server_process+0x68>
 80021b4:	7afb      	ldrb	r3, [r7, #11]
 80021b6:	2b85      	cmp	r3, #133	; 0x85
 80021b8:	d106      	bne.n	80021c8 <process_thread_shell_repeat_server_process+0x68>
 80021ba:	687a      	ldr	r2, [r7, #4]
 80021bc:	f240 63cc 	movw	r3, #1740	; 0x6cc
 80021c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80021c4:	429a      	cmp	r2, r3
 80021c6:	d001      	beq.n	80021cc <process_thread_shell_repeat_server_process+0x6c>
 80021c8:	2301      	movs	r3, #1
 80021ca:	e051      	b.n	8002270 <process_thread_shell_repeat_server_process+0x110>
			   data == &shell_repeat_process);
  {
    strncpy(command_copy, command, MAX_COMMANDLENGTH);
 80021cc:	f241 13c8 	movw	r3, #4552	; 0x11c8
 80021d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80021d4:	681b      	ldr	r3, [r3, #0]
 80021d6:	f107 0210 	add.w	r2, r7, #16
 80021da:	4610      	mov	r0, r2
 80021dc:	4619      	mov	r1, r3
 80021de:	2240      	movs	r2, #64	; 0x40
 80021e0:	f7fe f8de 	bl	80003a0 <strncpy>
    ret = shell_start_command(command_copy, (int)strlen(command_copy),
 80021e4:	f107 0310 	add.w	r3, r7, #16
 80021e8:	4618      	mov	r0, r3
 80021ea:	f7fe f8b7 	bl	800035c <strlen>
 80021ee:	4603      	mov	r3, r0
 80021f0:	f107 0210 	add.w	r2, r7, #16
 80021f4:	4610      	mov	r0, r2
 80021f6:	4619      	mov	r1, r3
 80021f8:	f240 62ec 	movw	r2, #1772	; 0x6ec
 80021fc:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8002200:	f241 13cc 	movw	r3, #4556	; 0x11cc
 8002204:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002208:	f7fe ff56 	bl	80010b8 <shell_start_command>
 800220c:	6538      	str	r0, [r7, #80]	; 0x50
			      &repeat_command, &started_process);
    
    if(started_process != NULL &&
 800220e:	f241 13cc 	movw	r3, #4556	; 0x11cc
 8002212:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002216:	681b      	ldr	r3, [r3, #0]
 8002218:	2b00      	cmp	r3, #0
 800221a:	d022      	beq.n	8002262 <process_thread_shell_repeat_server_process+0x102>
       process_is_running(started_process)) {
 800221c:	f241 13cc 	movw	r3, #4556	; 0x11cc
 8002220:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002224:	681b      	ldr	r3, [r3, #0]
 8002226:	4618      	mov	r0, r3
 8002228:	f002 f87e 	bl	8004328 <process_is_running>
 800222c:	4603      	mov	r3, r0
  {
    strncpy(command_copy, command, MAX_COMMANDLENGTH);
    ret = shell_start_command(command_copy, (int)strlen(command_copy),
			      &repeat_command, &started_process);
    
    if(started_process != NULL &&
 800222e:	2b00      	cmp	r3, #0
 8002230:	d017      	beq.n	8002262 <process_thread_shell_repeat_server_process+0x102>
       process_is_running(started_process)) {
      PROCESS_WAIT_EVENT_UNTIL(ev == PROCESS_EVENT_EXITED &&
 8002232:	2300      	movs	r3, #0
 8002234:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
 8002238:	68fb      	ldr	r3, [r7, #12]
 800223a:	22ba      	movs	r2, #186	; 0xba
 800223c:	801a      	strh	r2, [r3, #0]
 800223e:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8002242:	2b00      	cmp	r3, #0
 8002244:	d00a      	beq.n	800225c <process_thread_shell_repeat_server_process+0xfc>
 8002246:	7afb      	ldrb	r3, [r7, #11]
 8002248:	2b87      	cmp	r3, #135	; 0x87
 800224a:	d107      	bne.n	800225c <process_thread_shell_repeat_server_process+0xfc>
 800224c:	f241 13cc 	movw	r3, #4556	; 0x11cc
 8002250:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002254:	681b      	ldr	r3, [r3, #0]
 8002256:	687a      	ldr	r2, [r7, #4]
 8002258:	429a      	cmp	r2, r3
 800225a:	d002      	beq.n	8002262 <process_thread_shell_repeat_server_process+0x102>
 800225c:	2301      	movs	r3, #1
 800225e:	e007      	b.n	8002270 <process_thread_shell_repeat_server_process+0x110>
  static struct process *started_process;
  char command_copy[MAX_COMMANDLENGTH];
  int ret;

  if(ev == shell_event_input) {
    goto exit;
 8002260:	bf00      	nop
     process_is_running(repeat_command.child->process)) {
    process_post_synch(repeat_command.child->process, ev, data);
    }*/
 exit:
  ;
  PROCESS_END();
 8002262:	2300      	movs	r3, #0
 8002264:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
 8002268:	68fb      	ldr	r3, [r7, #12]
 800226a:	2200      	movs	r2, #0
 800226c:	801a      	strh	r2, [r3, #0]
 800226e:	2303      	movs	r3, #3
}
 8002270:	4618      	mov	r0, r3
 8002272:	f107 0758 	add.w	r7, r7, #88	; 0x58
 8002276:	46bd      	mov	sp, r7
 8002278:	bd80      	pop	{r7, pc}
 800227a:	bf00      	nop

0800227c <repeat_print_usage>:
/*---------------------------------------------------------------------------*/
static void
repeat_print_usage(void)
{
 800227c:	b580      	push	{r7, lr}
 800227e:	af00      	add	r7, sp, #0
  shell_output_str(&repeat_command, "usage: ", repeat_command.description);
 8002280:	f240 63ec 	movw	r3, #1772	; 0x6ec
 8002284:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002288:	689b      	ldr	r3, [r3, #8]
 800228a:	f240 60ec 	movw	r0, #1772	; 0x6ec
 800228e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002292:	f648 511c 	movw	r1, #36124	; 0x8d1c
 8002296:	f6c0 0100 	movt	r1, #2048	; 0x800
 800229a:	461a      	mov	r2, r3
 800229c:	f7fe ffc6 	bl	800122c <shell_output_str>
}
 80022a0:	bd80      	pop	{r7, pc}
 80022a2:	bf00      	nop

080022a4 <process_thread_shell_repeat_process>:
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_repeat_process, ev, data)
{
 80022a4:	b580      	push	{r7, lr}
 80022a6:	b08a      	sub	sp, #40	; 0x28
 80022a8:	af02      	add	r7, sp, #8
 80022aa:	60f8      	str	r0, [r7, #12]
 80022ac:	460b      	mov	r3, r1
 80022ae:	607a      	str	r2, [r7, #4]
 80022b0:	72fb      	strb	r3, [r7, #11]
  static struct etimer etimer;
  static int i;
  static clock_time_t start_time;
  const char *args, *next;

  if(ev == shell_event_input) {
 80022b2:	7afa      	ldrb	r2, [r7, #11]
 80022b4:	f241 63f8 	movw	r3, #5880	; 0x16f8
 80022b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80022bc:	681b      	ldr	r3, [r3, #0]
 80022be:	429a      	cmp	r2, r3
 80022c0:	d117      	bne.n	80022f2 <process_thread_shell_repeat_process+0x4e>
    struct shell_input *input;
    input = data;
 80022c2:	687b      	ldr	r3, [r7, #4]
 80022c4:	61bb      	str	r3, [r7, #24]
    /*    printf("shell repeat input %d %d\n", input->len1, input->len2);*/
    if(input->len1 + input->len2 != 0) {
 80022c6:	69bb      	ldr	r3, [r7, #24]
 80022c8:	689a      	ldr	r2, [r3, #8]
 80022ca:	69bb      	ldr	r3, [r7, #24]
 80022cc:	68db      	ldr	r3, [r3, #12]
 80022ce:	18d3      	adds	r3, r2, r3
 80022d0:	2b00      	cmp	r3, #0
 80022d2:	d00e      	beq.n	80022f2 <process_thread_shell_repeat_process+0x4e>
      shell_output(&repeat_command, input->data1, input->len1,
 80022d4:	69bb      	ldr	r3, [r7, #24]
 80022d6:	6819      	ldr	r1, [r3, #0]
 80022d8:	69bb      	ldr	r3, [r7, #24]
 80022da:	689a      	ldr	r2, [r3, #8]
		   input->data2, input->len2);
 80022dc:	69bb      	ldr	r3, [r7, #24]
 80022de:	685b      	ldr	r3, [r3, #4]
 80022e0:	69b8      	ldr	r0, [r7, #24]
  if(ev == shell_event_input) {
    struct shell_input *input;
    input = data;
    /*    printf("shell repeat input %d %d\n", input->len1, input->len2);*/
    if(input->len1 + input->len2 != 0) {
      shell_output(&repeat_command, input->data1, input->len1,
 80022e2:	68c0      	ldr	r0, [r0, #12]
 80022e4:	9000      	str	r0, [sp, #0]
 80022e6:	f240 60ec 	movw	r0, #1772	; 0x6ec
 80022ea:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80022ee:	f7fe ffcf 	bl	8001290 <shell_output>
		   input->data2, input->len2);
    }
  }

  PROCESS_BEGIN();
 80022f2:	2301      	movs	r3, #1
 80022f4:	75fb      	strb	r3, [r7, #23]
 80022f6:	68fb      	ldr	r3, [r7, #12]
 80022f8:	881b      	ldrh	r3, [r3, #0]
 80022fa:	f240 1213 	movw	r2, #275	; 0x113
 80022fe:	4293      	cmp	r3, r2
 8002300:	f000 809d 	beq.w	800243e <process_thread_shell_repeat_process+0x19a>
 8002304:	f5b3 7f8a 	cmp.w	r3, #276	; 0x114
 8002308:	f000 80a9 	beq.w	800245e <process_thread_shell_repeat_process+0x1ba>
 800230c:	2b00      	cmp	r3, #0
 800230e:	f040 80d5 	bne.w	80024bc <process_thread_shell_repeat_process+0x218>

  /*  printf("data '%s'\n", data);*/

  args = data;
 8002312:	687b      	ldr	r3, [r7, #4]
 8002314:	61fb      	str	r3, [r7, #28]

  if(args == NULL) {
 8002316:	69fb      	ldr	r3, [r7, #28]
 8002318:	2b00      	cmp	r3, #0
 800231a:	d106      	bne.n	800232a <process_thread_shell_repeat_process+0x86>
    repeat_print_usage();
 800231c:	f7ff ffae 	bl	800227c <repeat_print_usage>
    PROCESS_EXIT();
 8002320:	68fb      	ldr	r3, [r7, #12]
 8002322:	2200      	movs	r2, #0
 8002324:	801a      	strh	r2, [r3, #0]
 8002326:	2302      	movs	r3, #2
 8002328:	e0ce      	b.n	80024c8 <process_thread_shell_repeat_process+0x224>
  }

  reps = shell_strtolong(args, &next);
 800232a:	f107 0310 	add.w	r3, r7, #16
 800232e:	69f8      	ldr	r0, [r7, #28]
 8002330:	4619      	mov	r1, r3
 8002332:	f7ff f999 	bl	8001668 <shell_strtolong>
 8002336:	4603      	mov	r3, r0
 8002338:	461a      	mov	r2, r3
 800233a:	f241 1368 	movw	r3, #4456	; 0x1168
 800233e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002342:	601a      	str	r2, [r3, #0]
  if(next == args) {
 8002344:	693a      	ldr	r2, [r7, #16]
 8002346:	69fb      	ldr	r3, [r7, #28]
 8002348:	429a      	cmp	r2, r3
 800234a:	d106      	bne.n	800235a <process_thread_shell_repeat_process+0xb6>
    repeat_print_usage();
 800234c:	f7ff ff96 	bl	800227c <repeat_print_usage>
    PROCESS_EXIT();
 8002350:	68fb      	ldr	r3, [r7, #12]
 8002352:	2200      	movs	r2, #0
 8002354:	801a      	strh	r2, [r3, #0]
 8002356:	2302      	movs	r3, #2
 8002358:	e0b6      	b.n	80024c8 <process_thread_shell_repeat_process+0x224>
  }

  args = next;
 800235a:	693b      	ldr	r3, [r7, #16]
 800235c:	61fb      	str	r3, [r7, #28]
  period = shell_strtolong(args, &next);
 800235e:	f107 0310 	add.w	r3, r7, #16
 8002362:	69f8      	ldr	r0, [r7, #28]
 8002364:	4619      	mov	r1, r3
 8002366:	f7ff f97f 	bl	8001668 <shell_strtolong>
 800236a:	4603      	mov	r3, r0
 800236c:	461a      	mov	r2, r3
 800236e:	f241 136c 	movw	r3, #4460	; 0x116c
 8002372:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002376:	601a      	str	r2, [r3, #0]
  if(next == args) {
 8002378:	693a      	ldr	r2, [r7, #16]
 800237a:	69fb      	ldr	r3, [r7, #28]
 800237c:	429a      	cmp	r2, r3
 800237e:	d106      	bne.n	800238e <process_thread_shell_repeat_process+0xea>
    repeat_print_usage();
 8002380:	f7ff ff7c 	bl	800227c <repeat_print_usage>
    PROCESS_EXIT();
 8002384:	68fb      	ldr	r3, [r7, #12]
 8002386:	2200      	movs	r2, #0
 8002388:	801a      	strh	r2, [r3, #0]
 800238a:	2302      	movs	r3, #2
 800238c:	e09c      	b.n	80024c8 <process_thread_shell_repeat_process+0x224>
  }

  args = next;
 800238e:	693b      	ldr	r3, [r7, #16]
 8002390:	61fb      	str	r3, [r7, #28]

  while(*args == ' ') {
 8002392:	e002      	b.n	800239a <process_thread_shell_repeat_process+0xf6>
    args++;
 8002394:	69fb      	ldr	r3, [r7, #28]
 8002396:	3301      	adds	r3, #1
 8002398:	61fb      	str	r3, [r7, #28]
    PROCESS_EXIT();
  }

  args = next;

  while(*args == ' ') {
 800239a:	69fb      	ldr	r3, [r7, #28]
 800239c:	781b      	ldrb	r3, [r3, #0]
 800239e:	2b20      	cmp	r3, #32
 80023a0:	d0f8      	beq.n	8002394 <process_thread_shell_repeat_process+0xf0>
    args++;
  }

  strncpy(command, args, MAX_COMMANDLENGTH);
 80023a2:	f241 1070 	movw	r0, #4464	; 0x1170
 80023a6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80023aa:	69f9      	ldr	r1, [r7, #28]
 80023ac:	2240      	movs	r2, #64	; 0x40
 80023ae:	f7fd fff7 	bl	80003a0 <strncpy>
  if(strlen(command) == 0) {
 80023b2:	f241 1370 	movw	r3, #4464	; 0x1170
 80023b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80023ba:	781b      	ldrb	r3, [r3, #0]
 80023bc:	2b00      	cmp	r3, #0
 80023be:	d106      	bne.n	80023ce <process_thread_shell_repeat_process+0x12a>
    repeat_print_usage();
 80023c0:	f7ff ff5c 	bl	800227c <repeat_print_usage>
    PROCESS_EXIT();
 80023c4:	68fb      	ldr	r3, [r7, #12]
 80023c6:	2200      	movs	r2, #0
 80023c8:	801a      	strh	r2, [r3, #0]
 80023ca:	2302      	movs	r3, #2
 80023cc:	e07c      	b.n	80024c8 <process_thread_shell_repeat_process+0x224>
  }

  /*  printf("repeats %d period %d command '%s'\n",
      reps, period, command);*/

  start_time = clock_time();
 80023ce:	f000 ff3b 	bl	8003248 <clock_time>
 80023d2:	4602      	mov	r2, r0
 80023d4:	f241 13b0 	movw	r3, #4528	; 0x11b0
 80023d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80023dc:	601a      	str	r2, [r3, #0]
  etimer_set(&etimer, CLOCK_SECOND * period);
 80023de:	f241 136c 	movw	r3, #4460	; 0x116c
 80023e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80023e6:	681b      	ldr	r3, [r3, #0]
 80023e8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80023ec:	fb02 f303 	mul.w	r3, r2, r3
 80023f0:	f241 10b4 	movw	r0, #4532	; 0x11b4
 80023f4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80023f8:	4619      	mov	r1, r3
 80023fa:	f002 f9b5 	bl	8004768 <etimer_set>
  for(i = 0; reps == 0 || i < reps; ++i) {
 80023fe:	f241 13c4 	movw	r3, #4548	; 0x11c4
 8002402:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002406:	2200      	movs	r2, #0
 8002408:	601a      	str	r2, [r3, #0]
 800240a:	e044      	b.n	8002496 <process_thread_shell_repeat_process+0x1f2>

    process_start(&shell_repeat_server_process, command);
 800240c:	f240 60dc 	movw	r0, #1756	; 0x6dc
 8002410:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002414:	f241 1170 	movw	r1, #4464	; 0x1170
 8002418:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800241c:	f001 fc98 	bl	8003d50 <process_start>
    process_post(&shell_repeat_server_process,
 8002420:	f240 60dc 	movw	r0, #1756	; 0x6dc
 8002424:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002428:	2185      	movs	r1, #133	; 0x85
 800242a:	f240 62cc 	movw	r2, #1740	; 0x6cc
 800242e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8002432:	f001 fed1 	bl	80041d8 <process_post>
		 PROCESS_EVENT_CONTINUE,
		 &shell_repeat_process);
    PROCESS_WAIT_UNTIL(ev == PROCESS_EVENT_EXITED &&
 8002436:	68fb      	ldr	r3, [r7, #12]
 8002438:	f240 1213 	movw	r2, #275	; 0x113
 800243c:	801a      	strh	r2, [r3, #0]
 800243e:	7afb      	ldrb	r3, [r7, #11]
 8002440:	2b87      	cmp	r3, #135	; 0x87
 8002442:	d106      	bne.n	8002452 <process_thread_shell_repeat_process+0x1ae>
 8002444:	687a      	ldr	r2, [r7, #4]
 8002446:	f240 63dc 	movw	r3, #1756	; 0x6dc
 800244a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800244e:	429a      	cmp	r2, r3
 8002450:	d001      	beq.n	8002456 <process_thread_shell_repeat_process+0x1b2>
 8002452:	2300      	movs	r3, #0
 8002454:	e038      	b.n	80024c8 <process_thread_shell_repeat_process+0x224>
		       data == &shell_repeat_server_process);
    PROCESS_WAIT_UNTIL(etimer_expired(&etimer));
 8002456:	68fb      	ldr	r3, [r7, #12]
 8002458:	f44f 728a 	mov.w	r2, #276	; 0x114
 800245c:	801a      	strh	r2, [r3, #0]
 800245e:	f241 10b4 	movw	r0, #4532	; 0x11b4
 8002462:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002466:	f002 f9b1 	bl	80047cc <etimer_expired>
 800246a:	4603      	mov	r3, r0
 800246c:	2b00      	cmp	r3, #0
 800246e:	d101      	bne.n	8002474 <process_thread_shell_repeat_process+0x1d0>
 8002470:	2300      	movs	r3, #0
 8002472:	e029      	b.n	80024c8 <process_thread_shell_repeat_process+0x224>
    etimer_reset(&etimer);
 8002474:	f241 10b4 	movw	r0, #4532	; 0x11b4
 8002478:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800247c:	f002 f986 	bl	800478c <etimer_reset>
  /*  printf("repeats %d period %d command '%s'\n",
      reps, period, command);*/

  start_time = clock_time();
  etimer_set(&etimer, CLOCK_SECOND * period);
  for(i = 0; reps == 0 || i < reps; ++i) {
 8002480:	f241 13c4 	movw	r3, #4548	; 0x11c4
 8002484:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002488:	681b      	ldr	r3, [r3, #0]
 800248a:	1c5a      	adds	r2, r3, #1
 800248c:	f241 13c4 	movw	r3, #4548	; 0x11c4
 8002490:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002494:	601a      	str	r2, [r3, #0]
 8002496:	f241 1368 	movw	r3, #4456	; 0x1168
 800249a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800249e:	681b      	ldr	r3, [r3, #0]
 80024a0:	2b00      	cmp	r3, #0
 80024a2:	d0b3      	beq.n	800240c <process_thread_shell_repeat_process+0x168>
 80024a4:	f241 13c4 	movw	r3, #4548	; 0x11c4
 80024a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80024ac:	681a      	ldr	r2, [r3, #0]
 80024ae:	f241 1368 	movw	r3, #4456	; 0x1168
 80024b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80024b6:	681b      	ldr	r3, [r3, #0]
 80024b8:	429a      	cmp	r2, r3
 80024ba:	dba7      	blt.n	800240c <process_thread_shell_repeat_process+0x168>
      PROCESS_WAIT_UNTIL(etimer_expired(&etimer));
      }*/
  }
  

  PROCESS_END();
 80024bc:	2300      	movs	r3, #0
 80024be:	75fb      	strb	r3, [r7, #23]
 80024c0:	68fb      	ldr	r3, [r7, #12]
 80024c2:	2200      	movs	r2, #0
 80024c4:	801a      	strh	r2, [r3, #0]
 80024c6:	2303      	movs	r3, #3
}
 80024c8:	4618      	mov	r0, r3
 80024ca:	f107 0720 	add.w	r7, r7, #32
 80024ce:	46bd      	mov	sp, r7
 80024d0:	bd80      	pop	{r7, pc}
 80024d2:	bf00      	nop

080024d4 <process_thread_shell_randwait_process>:
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_randwait_process, ev, data)
{
 80024d4:	b580      	push	{r7, lr}
 80024d6:	b088      	sub	sp, #32
 80024d8:	af00      	add	r7, sp, #0
 80024da:	60f8      	str	r0, [r7, #12]
 80024dc:	460b      	mov	r3, r1
 80024de:	607a      	str	r2, [r7, #4]
 80024e0:	72fb      	strb	r3, [r7, #11]
		   input->data2, input->len2);
    }
    }*/

  
  PROCESS_BEGIN();
 80024e2:	2301      	movs	r3, #1
 80024e4:	76fb      	strb	r3, [r7, #27]
 80024e6:	68fb      	ldr	r3, [r7, #12]
 80024e8:	881b      	ldrh	r3, [r3, #0]
 80024ea:	f5b3 7fab 	cmp.w	r3, #342	; 0x156
 80024ee:	f000 808d 	beq.w	800260c <process_thread_shell_randwait_process+0x138>
 80024f2:	f240 1261 	movw	r2, #353	; 0x161
 80024f6:	4293      	cmp	r3, r2
 80024f8:	f000 80c5 	beq.w	8002686 <process_thread_shell_randwait_process+0x1b2>
 80024fc:	2b00      	cmp	r3, #0
 80024fe:	f040 80d2 	bne.w	80026a6 <process_thread_shell_randwait_process+0x1d2>

  args = data;
 8002502:	687b      	ldr	r3, [r7, #4]
 8002504:	61fb      	str	r3, [r7, #28]

  if(args == NULL) {
 8002506:	69fb      	ldr	r3, [r7, #28]
 8002508:	2b00      	cmp	r3, #0
 800250a:	d112      	bne.n	8002532 <process_thread_shell_randwait_process+0x5e>
    shell_output_str(&randwait_command, "usage 0", "");
 800250c:	f240 7010 	movw	r0, #1808	; 0x710
 8002510:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002514:	f648 5124 	movw	r1, #36132	; 0x8d24
 8002518:	f6c0 0100 	movt	r1, #2048	; 0x800
 800251c:	f648 5218 	movw	r2, #36120	; 0x8d18
 8002520:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002524:	f7fe fe82 	bl	800122c <shell_output_str>
    PROCESS_EXIT();
 8002528:	68fb      	ldr	r3, [r7, #12]
 800252a:	2200      	movs	r2, #0
 800252c:	801a      	strh	r2, [r3, #0]
 800252e:	2302      	movs	r3, #2
 8002530:	e0bf      	b.n	80026b2 <process_thread_shell_randwait_process+0x1de>
  }
  
  maxwait = shell_strtolong(args, &next);
 8002532:	f107 0310 	add.w	r3, r7, #16
 8002536:	69f8      	ldr	r0, [r7, #28]
 8002538:	4619      	mov	r1, r3
 800253a:	f7ff f895 	bl	8001668 <shell_strtolong>
 800253e:	4603      	mov	r3, r0
 8002540:	461a      	mov	r2, r3
 8002542:	f241 1310 	movw	r3, #4368	; 0x1110
 8002546:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800254a:	601a      	str	r2, [r3, #0]
  if(next == args) {
 800254c:	693a      	ldr	r2, [r7, #16]
 800254e:	69fb      	ldr	r3, [r7, #28]
 8002550:	429a      	cmp	r2, r3
 8002552:	d112      	bne.n	800257a <process_thread_shell_randwait_process+0xa6>
    shell_output_str(&randwait_command, "usage 1", "");
 8002554:	f240 7010 	movw	r0, #1808	; 0x710
 8002558:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800255c:	f648 512c 	movw	r1, #36140	; 0x8d2c
 8002560:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002564:	f648 5218 	movw	r2, #36120	; 0x8d18
 8002568:	f6c0 0200 	movt	r2, #2048	; 0x800
 800256c:	f7fe fe5e 	bl	800122c <shell_output_str>
    PROCESS_EXIT();
 8002570:	68fb      	ldr	r3, [r7, #12]
 8002572:	2200      	movs	r2, #0
 8002574:	801a      	strh	r2, [r3, #0]
 8002576:	2302      	movs	r3, #2
 8002578:	e09b      	b.n	80026b2 <process_thread_shell_randwait_process+0x1de>
  }
  args = next;
 800257a:	693b      	ldr	r3, [r7, #16]
 800257c:	61fb      	str	r3, [r7, #28]

  while(*args == ' ') {
 800257e:	e002      	b.n	8002586 <process_thread_shell_randwait_process+0xb2>
    args++;
 8002580:	69fb      	ldr	r3, [r7, #28]
 8002582:	3301      	adds	r3, #1
 8002584:	61fb      	str	r3, [r7, #28]
    shell_output_str(&randwait_command, "usage 1", "");
    PROCESS_EXIT();
  }
  args = next;

  while(*args == ' ') {
 8002586:	69fb      	ldr	r3, [r7, #28]
 8002588:	781b      	ldrb	r3, [r3, #0]
 800258a:	2b20      	cmp	r3, #32
 800258c:	d0f8      	beq.n	8002580 <process_thread_shell_randwait_process+0xac>
    args++;
  }
  
  strncpy(command, args, MAX_COMMANDLENGTH);
 800258e:	f241 1014 	movw	r0, #4372	; 0x1114
 8002592:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002596:	69f9      	ldr	r1, [r7, #28]
 8002598:	2240      	movs	r2, #64	; 0x40
 800259a:	f7fd ff01 	bl	80003a0 <strncpy>
  if(strlen(command) == 0) {
 800259e:	f241 1314 	movw	r3, #4372	; 0x1114
 80025a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80025a6:	781b      	ldrb	r3, [r3, #0]
 80025a8:	2b00      	cmp	r3, #0
 80025aa:	d112      	bne.n	80025d2 <process_thread_shell_randwait_process+0xfe>
    shell_output_str(&repeat_command, "usage 3", "");
 80025ac:	f240 60ec 	movw	r0, #1772	; 0x6ec
 80025b0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80025b4:	f648 5134 	movw	r1, #36148	; 0x8d34
 80025b8:	f6c0 0100 	movt	r1, #2048	; 0x800
 80025bc:	f648 5218 	movw	r2, #36120	; 0x8d18
 80025c0:	f6c0 0200 	movt	r2, #2048	; 0x800
 80025c4:	f7fe fe32 	bl	800122c <shell_output_str>
    PROCESS_EXIT();
 80025c8:	68fb      	ldr	r3, [r7, #12]
 80025ca:	2200      	movs	r2, #0
 80025cc:	801a      	strh	r2, [r3, #0]
 80025ce:	2302      	movs	r3, #2
 80025d0:	e06f      	b.n	80026b2 <process_thread_shell_randwait_process+0x1de>
  }

  /*  printf("randwait %d command '%s'\n",
      maxwait, command);*/

  etimer_set(&etimer, random_rand() % (CLOCK_SECOND * maxwait));
 80025d2:	f002 f9b9 	bl	8004948 <random_rand>
 80025d6:	4603      	mov	r3, r0
 80025d8:	461a      	mov	r2, r3
 80025da:	f241 1310 	movw	r3, #4368	; 0x1110
 80025de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80025e2:	681b      	ldr	r3, [r3, #0]
 80025e4:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80025e8:	fb01 f303 	mul.w	r3, r1, r3
 80025ec:	fb92 f1f3 	sdiv	r1, r2, r3
 80025f0:	fb03 f301 	mul.w	r3, r3, r1
 80025f4:	1ad3      	subs	r3, r2, r3
 80025f6:	f241 1054 	movw	r0, #4436	; 0x1154
 80025fa:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80025fe:	4619      	mov	r1, r3
 8002600:	f002 f8b2 	bl	8004768 <etimer_set>
  PROCESS_WAIT_UNTIL(etimer_expired(&etimer));
 8002604:	68fb      	ldr	r3, [r7, #12]
 8002606:	f44f 72ab 	mov.w	r2, #342	; 0x156
 800260a:	801a      	strh	r2, [r3, #0]
 800260c:	f241 1054 	movw	r0, #4436	; 0x1154
 8002610:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002614:	f002 f8da 	bl	80047cc <etimer_expired>
 8002618:	4603      	mov	r3, r0
 800261a:	2b00      	cmp	r3, #0
 800261c:	d101      	bne.n	8002622 <process_thread_shell_randwait_process+0x14e>
 800261e:	2300      	movs	r3, #0
 8002620:	e047      	b.n	80026b2 <process_thread_shell_randwait_process+0x1de>

/*   printf("Starting '%s' child %p (%s)\n", command, randwait_command.child, */
/* 	 randwait_command.child == NULL? "null": randwait_command.child->command); */
  
  ret = shell_start_command(command, (int)strlen(command),
 8002622:	f241 1014 	movw	r0, #4372	; 0x1114
 8002626:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800262a:	f7fd fe97 	bl	800035c <strlen>
 800262e:	4603      	mov	r3, r0
 8002630:	461a      	mov	r2, r3
 8002632:	f240 7310 	movw	r3, #1808	; 0x710
 8002636:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800263a:	691b      	ldr	r3, [r3, #16]
 800263c:	f241 1014 	movw	r0, #4372	; 0x1114
 8002640:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002644:	4611      	mov	r1, r2
 8002646:	461a      	mov	r2, r3
 8002648:	f241 1364 	movw	r3, #4452	; 0x1164
 800264c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002650:	f7fe fd32 	bl	80010b8 <shell_start_command>
 8002654:	6178      	str	r0, [r7, #20]
			    randwait_command.child, &started_process);
  
  if(started_process != NULL &&
 8002656:	f241 1364 	movw	r3, #4452	; 0x1164
 800265a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800265e:	681b      	ldr	r3, [r3, #0]
 8002660:	2b00      	cmp	r3, #0
 8002662:	d020      	beq.n	80026a6 <process_thread_shell_randwait_process+0x1d2>
     process_is_running(started_process)) {
 8002664:	f241 1364 	movw	r3, #4452	; 0x1164
 8002668:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800266c:	681b      	ldr	r3, [r3, #0]
 800266e:	4618      	mov	r0, r3
 8002670:	f001 fe5a 	bl	8004328 <process_is_running>
 8002674:	4603      	mov	r3, r0
/* 	 randwait_command.child == NULL? "null": randwait_command.child->command); */
  
  ret = shell_start_command(command, (int)strlen(command),
			    randwait_command.child, &started_process);
  
  if(started_process != NULL &&
 8002676:	2b00      	cmp	r3, #0
 8002678:	d015      	beq.n	80026a6 <process_thread_shell_randwait_process+0x1d2>
     process_is_running(started_process)) {
    PROCESS_WAIT_EVENT_UNTIL(ev == PROCESS_EVENT_EXITED &&
 800267a:	2300      	movs	r3, #0
 800267c:	76fb      	strb	r3, [r7, #27]
 800267e:	68fb      	ldr	r3, [r7, #12]
 8002680:	f240 1261 	movw	r2, #353	; 0x161
 8002684:	801a      	strh	r2, [r3, #0]
 8002686:	7efb      	ldrb	r3, [r7, #27]
 8002688:	2b00      	cmp	r3, #0
 800268a:	d00a      	beq.n	80026a2 <process_thread_shell_randwait_process+0x1ce>
 800268c:	7afb      	ldrb	r3, [r7, #11]
 800268e:	2b87      	cmp	r3, #135	; 0x87
 8002690:	d107      	bne.n	80026a2 <process_thread_shell_randwait_process+0x1ce>
 8002692:	f241 1364 	movw	r3, #4452	; 0x1164
 8002696:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800269a:	681b      	ldr	r3, [r3, #0]
 800269c:	687a      	ldr	r2, [r7, #4]
 800269e:	429a      	cmp	r2, r3
 80026a0:	d001      	beq.n	80026a6 <process_thread_shell_randwait_process+0x1d2>
 80026a2:	2301      	movs	r3, #1
 80026a4:	e005      	b.n	80026b2 <process_thread_shell_randwait_process+0x1de>
			     data == started_process);
  }

  PROCESS_END();
 80026a6:	2300      	movs	r3, #0
 80026a8:	76fb      	strb	r3, [r7, #27]
 80026aa:	68fb      	ldr	r3, [r7, #12]
 80026ac:	2200      	movs	r2, #0
 80026ae:	801a      	strh	r2, [r3, #0]
 80026b0:	2303      	movs	r3, #3
}
 80026b2:	4618      	mov	r0, r3
 80026b4:	f107 0720 	add.w	r7, r7, #32
 80026b8:	46bd      	mov	sp, r7
 80026ba:	bd80      	pop	{r7, pc}

080026bc <shell_time_init>:
/*---------------------------------------------------------------------------*/
void
shell_time_init(void)
{
 80026bc:	b580      	push	{r7, lr}
 80026be:	af00      	add	r7, sp, #0
  shell_register_command(&time_command);
 80026c0:	f240 6094 	movw	r0, #1684	; 0x694
 80026c4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80026c8:	f7fe fe06 	bl	80012d8 <shell_register_command>
  shell_register_command(&timestamp_command);
 80026cc:	f240 60b8 	movw	r0, #1720	; 0x6b8
 80026d0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80026d4:	f7fe fe00 	bl	80012d8 <shell_register_command>
  shell_register_command(&repeat_command);
 80026d8:	f240 60ec 	movw	r0, #1772	; 0x6ec
 80026dc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80026e0:	f7fe fdfa 	bl	80012d8 <shell_register_command>
  shell_register_command(&randwait_command);
 80026e4:	f240 7010 	movw	r0, #1808	; 0x710
 80026e8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80026ec:	f7fe fdf4 	bl	80012d8 <shell_register_command>
}
 80026f0:	bd80      	pop	{r7, pc}
 80026f2:	bf00      	nop

080026f4 <process_thread_shell_run_process>:
	      "run",
	      "run: load and run a PRG file",
	      &shell_run_process);
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_run_process, ev, data)
{
 80026f4:	b580      	push	{r7, lr}
 80026f6:	b088      	sub	sp, #32
 80026f8:	af00      	add	r7, sp, #0
 80026fa:	60f8      	str	r0, [r7, #12]
 80026fc:	460b      	mov	r3, r1
 80026fe:	607a      	str	r2, [r7, #4]
 8002700:	72fb      	strb	r3, [r7, #11]
  char *name, *print;

  PROCESS_BEGIN();
 8002702:	2301      	movs	r3, #1
 8002704:	77fb      	strb	r3, [r7, #31]
 8002706:	68fb      	ldr	r3, [r7, #12]
 8002708:	881b      	ldrh	r3, [r3, #0]
 800270a:	2b00      	cmp	r3, #0
 800270c:	d12c      	bne.n	8002768 <process_thread_shell_run_process+0x74>

  name = data;
 800270e:	687b      	ldr	r3, [r7, #4]
 8002710:	61bb      	str	r3, [r7, #24]
  if(name == NULL || strlen(name) == 0) {
 8002712:	69bb      	ldr	r3, [r7, #24]
 8002714:	2b00      	cmp	r3, #0
 8002716:	d003      	beq.n	8002720 <process_thread_shell_run_process+0x2c>
 8002718:	69bb      	ldr	r3, [r7, #24]
 800271a:	781b      	ldrb	r3, [r3, #0]
 800271c:	2b00      	cmp	r3, #0
 800271e:	d112      	bne.n	8002746 <process_thread_shell_run_process+0x52>
    shell_output_str(&run_command,
 8002720:	f240 7034 	movw	r0, #1844	; 0x734
 8002724:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002728:	f648 5160 	movw	r1, #36192	; 0x8d60
 800272c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002730:	f648 5284 	movw	r2, #36228	; 0x8d84
 8002734:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002738:	f7fe fd78 	bl	800122c <shell_output_str>
		     "run <file>: filename must be given", "");
    PROCESS_EXIT();
 800273c:	68fb      	ldr	r3, [r7, #12]
 800273e:	2200      	movs	r2, #0
 8002740:	801a      	strh	r2, [r3, #0]
 8002742:	2302      	movs	r3, #2
 8002744:	e016      	b.n	8002774 <process_thread_shell_run_process+0x80>
    break;
  case LOADER_ERR_VERSION:
    print = "Wrong OS version";
    break;
  case LOADER_ERR_NOLOADER:
    print = "Program loading not supported";
 8002746:	f648 5388 	movw	r3, #36232	; 0x8d88
 800274a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800274e:	617b      	str	r3, [r7, #20]
    break;
 8002750:	bf00      	nop
  default:
    print = "Unknown return code from the loader (internal bug)";
    break;
  }
  shell_output_str(&run_command, print, ".");
 8002752:	f240 7034 	movw	r0, #1844	; 0x734
 8002756:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800275a:	6979      	ldr	r1, [r7, #20]
 800275c:	f648 52a8 	movw	r2, #36264	; 0x8da8
 8002760:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002764:	f7fe fd62 	bl	800122c <shell_output_str>
  
  PROCESS_END();
 8002768:	2300      	movs	r3, #0
 800276a:	77fb      	strb	r3, [r7, #31]
 800276c:	68fb      	ldr	r3, [r7, #12]
 800276e:	2200      	movs	r2, #0
 8002770:	801a      	strh	r2, [r3, #0]
 8002772:	2303      	movs	r3, #3
}
 8002774:	4618      	mov	r0, r3
 8002776:	f107 0720 	add.w	r7, r7, #32
 800277a:	46bd      	mov	sp, r7
 800277c:	bd80      	pop	{r7, pc}
 800277e:	bf00      	nop

08002780 <shell_run_init>:
/*---------------------------------------------------------------------------*/
void
shell_run_init(void)
{
 8002780:	b580      	push	{r7, lr}
 8002782:	af00      	add	r7, sp, #0
  shell_register_command(&run_command);
 8002784:	f240 7034 	movw	r0, #1844	; 0x734
 8002788:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800278c:	f7fe fda4 	bl	80012d8 <shell_register_command>
}
 8002790:	bd80      	pop	{r7, pc}
 8002792:	bf00      	nop

08002794 <send_ping>:
  UIP_ICMP_BUF->icmpchksum = ~uip_icmp6chksum();
  
  tcpip_ipv6_output();
}
#else /* UIP_CONF_IPV6 */
{
 8002794:	b590      	push	{r4, r7, lr}
 8002796:	b083      	sub	sp, #12
 8002798:	af00      	add	r7, sp, #0
 800279a:	6078      	str	r0, [r7, #4]
  static uint16_t ipid = 0;
  static uint16_t seqno = 0;
  
  UIP_IP_BUF->vhl = 0x45;
 800279c:	f241 7318 	movw	r3, #5912	; 0x1718
 80027a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80027a4:	2245      	movs	r2, #69	; 0x45
 80027a6:	701a      	strb	r2, [r3, #0]
  UIP_IP_BUF->tos = 0;
 80027a8:	f241 7318 	movw	r3, #5912	; 0x1718
 80027ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80027b0:	2200      	movs	r2, #0
 80027b2:	705a      	strb	r2, [r3, #1]
  UIP_IP_BUF->ipoffset[0] = UIP_IP_BUF->ipoffset[1] = 0;
 80027b4:	f241 7218 	movw	r2, #5912	; 0x1718
 80027b8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80027bc:	f241 7318 	movw	r3, #5912	; 0x1718
 80027c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80027c4:	2100      	movs	r1, #0
 80027c6:	71d9      	strb	r1, [r3, #7]
 80027c8:	79db      	ldrb	r3, [r3, #7]
 80027ca:	7193      	strb	r3, [r2, #6]
  ++ipid;
 80027cc:	f241 13e8 	movw	r3, #4584	; 0x11e8
 80027d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80027d4:	881b      	ldrh	r3, [r3, #0]
 80027d6:	3301      	adds	r3, #1
 80027d8:	b29a      	uxth	r2, r3
 80027da:	f241 13e8 	movw	r3, #4584	; 0x11e8
 80027de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80027e2:	801a      	strh	r2, [r3, #0]
  UIP_IP_BUF->ipid[0] = ipid >> 8;
 80027e4:	f241 7318 	movw	r3, #5912	; 0x1718
 80027e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80027ec:	f241 12e8 	movw	r2, #4584	; 0x11e8
 80027f0:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80027f4:	8812      	ldrh	r2, [r2, #0]
 80027f6:	0a12      	lsrs	r2, r2, #8
 80027f8:	b292      	uxth	r2, r2
 80027fa:	b2d2      	uxtb	r2, r2
 80027fc:	711a      	strb	r2, [r3, #4]
  UIP_IP_BUF->ipid[1] = ipid & 0xff;
 80027fe:	f241 7318 	movw	r3, #5912	; 0x1718
 8002802:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002806:	f241 12e8 	movw	r2, #4584	; 0x11e8
 800280a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800280e:	8812      	ldrh	r2, [r2, #0]
 8002810:	b2d2      	uxtb	r2, r2
 8002812:	715a      	strb	r2, [r3, #5]
  UIP_IP_BUF->proto = UIP_PROTO_ICMP;
 8002814:	f241 7318 	movw	r3, #5912	; 0x1718
 8002818:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800281c:	2201      	movs	r2, #1
 800281e:	725a      	strb	r2, [r3, #9]
  UIP_IP_BUF->ttl = UIP_TTL;
 8002820:	f241 7318 	movw	r3, #5912	; 0x1718
 8002824:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002828:	2240      	movs	r2, #64	; 0x40
 800282a:	721a      	strb	r2, [r3, #8]

  uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, dest_addr);
 800282c:	4b33      	ldr	r3, [pc, #204]	; (80028fc <send_ping+0x168>)
 800282e:	687a      	ldr	r2, [r7, #4]
 8002830:	6812      	ldr	r2, [r2, #0]
 8002832:	601a      	str	r2, [r3, #0]
  uip_ipaddr_copy(&UIP_IP_BUF->srcipaddr, &uip_hostaddr);
 8002834:	4a32      	ldr	r2, [pc, #200]	; (8002900 <send_ping+0x16c>)
 8002836:	f641 63c4 	movw	r3, #7876	; 0x1ec4
 800283a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800283e:	681b      	ldr	r3, [r3, #0]
 8002840:	6013      	str	r3, [r2, #0]
  
  UIP_ICMP_BUF->type = ICMP_ECHO;
 8002842:	4b30      	ldr	r3, [pc, #192]	; (8002904 <send_ping+0x170>)
 8002844:	2208      	movs	r2, #8
 8002846:	701a      	strb	r2, [r3, #0]
  UIP_ICMP_BUF->icode = 0;
 8002848:	4b2e      	ldr	r3, [pc, #184]	; (8002904 <send_ping+0x170>)
 800284a:	2200      	movs	r2, #0
 800284c:	705a      	strb	r2, [r3, #1]
  UIP_ICMP_BUF->id = 0xadad;
 800284e:	4b2d      	ldr	r3, [pc, #180]	; (8002904 <send_ping+0x170>)
 8002850:	f64a 52ad 	movw	r2, #44461	; 0xadad
 8002854:	809a      	strh	r2, [r3, #4]
  UIP_ICMP_BUF->seqno = uip_htons(seqno++);
 8002856:	4c2b      	ldr	r4, [pc, #172]	; (8002904 <send_ping+0x170>)
 8002858:	f241 13ea 	movw	r3, #4586	; 0x11ea
 800285c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002860:	881b      	ldrh	r3, [r3, #0]
 8002862:	461a      	mov	r2, r3
 8002864:	3301      	adds	r3, #1
 8002866:	b299      	uxth	r1, r3
 8002868:	f241 13ea 	movw	r3, #4586	; 0x11ea
 800286c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002870:	8019      	strh	r1, [r3, #0]
 8002872:	4610      	mov	r0, r2
 8002874:	f004 f8bc 	bl	80069f0 <uip_htons>
 8002878:	4603      	mov	r3, r0
 800287a:	80e3      	strh	r3, [r4, #6]
  
  uip_len = UIP_ICMPH_LEN + UIP_IPH_LEN + PING_DATALEN;
 800287c:	f241 730c 	movw	r3, #5900	; 0x170c
 8002880:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002884:	2228      	movs	r2, #40	; 0x28
 8002886:	801a      	strh	r2, [r3, #0]
  UIP_IP_BUF->len[0] = (uint8_t)((uip_len) >> 8);
 8002888:	f241 7318 	movw	r3, #5912	; 0x1718
 800288c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002890:	f241 720c 	movw	r2, #5900	; 0x170c
 8002894:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8002898:	8812      	ldrh	r2, [r2, #0]
 800289a:	0a12      	lsrs	r2, r2, #8
 800289c:	b292      	uxth	r2, r2
 800289e:	b2d2      	uxtb	r2, r2
 80028a0:	709a      	strb	r2, [r3, #2]
  UIP_IP_BUF->len[1] = (uint8_t)((uip_len) & 0x00ff);
 80028a2:	f241 7318 	movw	r3, #5912	; 0x1718
 80028a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80028aa:	f241 720c 	movw	r2, #5900	; 0x170c
 80028ae:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80028b2:	8812      	ldrh	r2, [r2, #0]
 80028b4:	b2d2      	uxtb	r2, r2
 80028b6:	70da      	strb	r2, [r3, #3]
  
  UIP_ICMP_BUF->icmpchksum = 0;
 80028b8:	4b12      	ldr	r3, [pc, #72]	; (8002904 <send_ping+0x170>)
 80028ba:	2200      	movs	r2, #0
 80028bc:	805a      	strh	r2, [r3, #2]
  UIP_ICMP_BUF->icmpchksum = ~uip_chksum((uint16_t *)&(UIP_ICMP_BUF->type),
 80028be:	4c11      	ldr	r4, [pc, #68]	; (8002904 <send_ping+0x170>)
 80028c0:	4810      	ldr	r0, [pc, #64]	; (8002904 <send_ping+0x170>)
 80028c2:	2114      	movs	r1, #20
 80028c4:	f002 f928 	bl	8004b18 <uip_chksum>
 80028c8:	4603      	mov	r3, r0
 80028ca:	43db      	mvns	r3, r3
 80028cc:	b29b      	uxth	r3, r3
 80028ce:	8063      	strh	r3, [r4, #2]
					 UIP_ICMPH_LEN + PING_DATALEN);

  /* Calculate IP checksum. */
  UIP_IP_BUF->ipchksum = 0;
 80028d0:	f241 7318 	movw	r3, #5912	; 0x1718
 80028d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80028d8:	2200      	movs	r2, #0
 80028da:	815a      	strh	r2, [r3, #10]
  UIP_IP_BUF->ipchksum = ~(uip_ipchksum());
 80028dc:	f241 7418 	movw	r4, #5912	; 0x1718
 80028e0:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80028e4:	f002 f92e 	bl	8004b44 <uip_ipchksum>
 80028e8:	4603      	mov	r3, r0
 80028ea:	43db      	mvns	r3, r3
 80028ec:	b29b      	uxth	r3, r3
 80028ee:	8163      	strh	r3, [r4, #10]

  tcpip_output();
 80028f0:	f004 f91c 	bl	8006b2c <tcpip_output>
}
 80028f4:	f107 070c 	add.w	r7, r7, #12
 80028f8:	46bd      	mov	sp, r7
 80028fa:	bd90      	pop	{r4, r7, pc}
 80028fc:	20001728 	.word	0x20001728
 8002900:	20001724 	.word	0x20001724
 8002904:	2000172c 	.word	0x2000172c

08002908 <process_thread_shell_ping_process>:
#endif /* UIP_CONF_IPV6 */
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_ping_process, ev, data)
{
 8002908:	b580      	push	{r7, lr}
 800290a:	b086      	sub	sp, #24
 800290c:	af00      	add	r7, sp, #0
 800290e:	60f8      	str	r0, [r7, #12]
 8002910:	460b      	mov	r3, r1
 8002912:	607a      	str	r2, [r7, #4]
 8002914:	72fb      	strb	r3, [r7, #11]
  static struct etimer e;
  struct shell_input *input;

  PROCESS_BEGIN();
 8002916:	2301      	movs	r3, #1
 8002918:	75fb      	strb	r3, [r7, #23]
 800291a:	68fb      	ldr	r3, [r7, #12]
 800291c:	881b      	ldrh	r3, [r3, #0]
 800291e:	2b00      	cmp	r3, #0
 8002920:	d002      	beq.n	8002928 <process_thread_shell_ping_process+0x20>
 8002922:	2b9b      	cmp	r3, #155	; 0x9b
 8002924:	d037      	beq.n	8002996 <process_thread_shell_ping_process+0x8e>
 8002926:	e066      	b.n	80029f6 <process_thread_shell_ping_process+0xee>

  if(data == NULL) {
 8002928:	687b      	ldr	r3, [r7, #4]
 800292a:	2b00      	cmp	r3, #0
 800292c:	d112      	bne.n	8002954 <process_thread_shell_ping_process+0x4c>
    shell_output_str(&ping_command,
 800292e:	f240 7058 	movw	r0, #1880	; 0x758
 8002932:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002936:	f648 51d4 	movw	r1, #36308	; 0x8dd4
 800293a:	f6c0 0100 	movt	r1, #2048	; 0x800
 800293e:	f648 52f8 	movw	r2, #36344	; 0x8df8
 8002942:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002946:	f7fe fc71 	bl	800122c <shell_output_str>
		     "ping <server>: server as address", "");
    PROCESS_EXIT();
 800294a:	68fb      	ldr	r3, [r7, #12]
 800294c:	2200      	movs	r2, #0
 800294e:	801a      	strh	r2, [r3, #0]
 8002950:	2302      	movs	r3, #2
 8002952:	e056      	b.n	8002a02 <process_thread_shell_ping_process+0xfa>
  }
  uiplib_ipaddrconv(data, &remoteaddr);
 8002954:	6878      	ldr	r0, [r7, #4]
 8002956:	f241 11d0 	movw	r1, #4560	; 0x11d0
 800295a:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800295e:	f004 f897 	bl	8006a90 <uiplib_ipaddrconv>

  send_ping(&remoteaddr);
 8002962:	f241 10d0 	movw	r0, #4560	; 0x11d0
 8002966:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800296a:	f7ff ff13 	bl	8002794 <send_ping>
  
  running = 1;
 800296e:	f241 13d4 	movw	r3, #4564	; 0x11d4
 8002972:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002976:	2201      	movs	r2, #1
 8002978:	701a      	strb	r2, [r3, #0]

  while(running) {
 800297a:	e035      	b.n	80029e8 <process_thread_shell_ping_process+0xe0>
    etimer_set(&e, CLOCK_SECOND * 10);
 800297c:	f241 10d8 	movw	r0, #4568	; 0x11d8
 8002980:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002984:	f242 7110 	movw	r1, #10000	; 0x2710
 8002988:	f001 feee 	bl	8004768 <etimer_set>
    
    PROCESS_WAIT_EVENT();
 800298c:	2300      	movs	r3, #0
 800298e:	75fb      	strb	r3, [r7, #23]
 8002990:	68fb      	ldr	r3, [r7, #12]
 8002992:	229b      	movs	r2, #155	; 0x9b
 8002994:	801a      	strh	r2, [r3, #0]
 8002996:	7dfb      	ldrb	r3, [r7, #23]
 8002998:	2b00      	cmp	r3, #0
 800299a:	d101      	bne.n	80029a0 <process_thread_shell_ping_process+0x98>
 800299c:	2301      	movs	r3, #1
 800299e:	e030      	b.n	8002a02 <process_thread_shell_ping_process+0xfa>

    if(etimer_expired(&e)) {
 80029a0:	f241 10d8 	movw	r0, #4568	; 0x11d8
 80029a4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80029a8:	f001 ff10 	bl	80047cc <etimer_expired>
 80029ac:	4603      	mov	r3, r0
 80029ae:	2b00      	cmp	r3, #0
 80029b0:	d004      	beq.n	80029bc <process_thread_shell_ping_process+0xb4>
      PROCESS_EXIT();      
 80029b2:	68fb      	ldr	r3, [r7, #12]
 80029b4:	2200      	movs	r2, #0
 80029b6:	801a      	strh	r2, [r3, #0]
 80029b8:	2302      	movs	r3, #2
 80029ba:	e022      	b.n	8002a02 <process_thread_shell_ping_process+0xfa>
    }
    
    if(ev == shell_event_input) {
 80029bc:	7afa      	ldrb	r2, [r7, #11]
 80029be:	f241 63f8 	movw	r3, #5880	; 0x16f8
 80029c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80029c6:	681b      	ldr	r3, [r3, #0]
 80029c8:	429a      	cmp	r2, r3
 80029ca:	d10d      	bne.n	80029e8 <process_thread_shell_ping_process+0xe0>
      input = data;
 80029cc:	687b      	ldr	r3, [r7, #4]
 80029ce:	613b      	str	r3, [r7, #16]
      if(input->len1 + input->len2 == 0) {
 80029d0:	693b      	ldr	r3, [r7, #16]
 80029d2:	689a      	ldr	r2, [r3, #8]
 80029d4:	693b      	ldr	r3, [r7, #16]
 80029d6:	68db      	ldr	r3, [r3, #12]
 80029d8:	18d3      	adds	r3, r2, r3
 80029da:	2b00      	cmp	r3, #0
 80029dc:	d104      	bne.n	80029e8 <process_thread_shell_ping_process+0xe0>
	PROCESS_EXIT();
 80029de:	68fb      	ldr	r3, [r7, #12]
 80029e0:	2200      	movs	r2, #0
 80029e2:	801a      	strh	r2, [r3, #0]
 80029e4:	2302      	movs	r3, #2
 80029e6:	e00c      	b.n	8002a02 <process_thread_shell_ping_process+0xfa>

  send_ping(&remoteaddr);
  
  running = 1;

  while(running) {
 80029e8:	f241 13d4 	movw	r3, #4564	; 0x11d4
 80029ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80029f0:	781b      	ldrb	r3, [r3, #0]
 80029f2:	2b00      	cmp	r3, #0
 80029f4:	d1c2      	bne.n	800297c <process_thread_shell_ping_process+0x74>
      }
#endif /* 0 */
    }
  }

  PROCESS_END();
 80029f6:	2300      	movs	r3, #0
 80029f8:	75fb      	strb	r3, [r7, #23]
 80029fa:	68fb      	ldr	r3, [r7, #12]
 80029fc:	2200      	movs	r2, #0
 80029fe:	801a      	strh	r2, [r3, #0]
 8002a00:	2303      	movs	r3, #3
}
 8002a02:	4618      	mov	r0, r3
 8002a04:	f107 0718 	add.w	r7, r7, #24
 8002a08:	46bd      	mov	sp, r7
 8002a0a:	bd80      	pop	{r7, pc}

08002a0c <shell_ping_init>:
/*---------------------------------------------------------------------------*/
void
shell_ping_init(void)
{
 8002a0c:	b580      	push	{r7, lr}
 8002a0e:	af00      	add	r7, sp, #0
  shell_register_command(&ping_command);
 8002a10:	f240 7058 	movw	r0, #1880	; 0x758
 8002a14:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002a18:	f7fe fc5e 	bl	80012d8 <shell_register_command>
}
 8002a1c:	bd80      	pop	{r7, pc}
 8002a1e:	bf00      	nop

08002a20 <process_thread_shell_netstat_process>:
	      "netstat",
	      "netstat: show UDP and TCP connections",
	      &shell_netstat_process);
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_netstat_process, ev, data)
{
 8002a20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002a24:	b0ab      	sub	sp, #172	; 0xac
 8002a26:	af0a      	add	r7, sp, #40	; 0x28
 8002a28:	60f8      	str	r0, [r7, #12]
 8002a2a:	460b      	mov	r3, r1
 8002a2c:	607a      	str	r2, [r7, #4]
 8002a2e:	72fb      	strb	r3, [r7, #11]
  char buf[BUFLEN];
  int i;
  struct uip_conn *conn;
  PROCESS_BEGIN();
 8002a30:	2301      	movs	r3, #1
 8002a32:	f887 307b 	strb.w	r3, [r7, #123]	; 0x7b
 8002a36:	68fb      	ldr	r3, [r7, #12]
 8002a38:	881b      	ldrh	r3, [r3, #0]
 8002a3a:	2b00      	cmp	r3, #0
 8002a3c:	d174      	bne.n	8002b28 <process_thread_shell_netstat_process+0x108>

  for(i = 0; i < UIP_CONNS; ++i) {
 8002a3e:	2300      	movs	r3, #0
 8002a40:	67fb      	str	r3, [r7, #124]	; 0x7c
 8002a42:	e06e      	b.n	8002b22 <process_thread_shell_netstat_process+0x102>
    conn = &uip_conns[i];
 8002a44:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8002a46:	4613      	mov	r3, r2
 8002a48:	00db      	lsls	r3, r3, #3
 8002a4a:	189b      	adds	r3, r3, r2
 8002a4c:	009b      	lsls	r3, r3, #2
 8002a4e:	f641 02cc 	movw	r2, #6348	; 0x18cc
 8002a52:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8002a56:	189b      	adds	r3, r3, r2
 8002a58:	677b      	str	r3, [r7, #116]	; 0x74
    snprintf(buf, BUFLEN,
	     "%d, %u.%u.%u.%u:%u, %s, %u, %u, %c %c",
	     uip_htons(conn->lport),
 8002a5a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8002a5c:	889b      	ldrh	r3, [r3, #4]
 8002a5e:	4618      	mov	r0, r3
 8002a60:	f003 ffc6 	bl	80069f0 <uip_htons>
 8002a64:	4603      	mov	r3, r0
  struct uip_conn *conn;
  PROCESS_BEGIN();

  for(i = 0; i < UIP_CONNS; ++i) {
    conn = &uip_conns[i];
    snprintf(buf, BUFLEN,
 8002a66:	461c      	mov	r4, r3
	     "%d, %u.%u.%u.%u:%u, %s, %u, %u, %c %c",
	     uip_htons(conn->lport),
	     conn->ripaddr.u8[0],
 8002a68:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8002a6a:	781b      	ldrb	r3, [r3, #0]
  struct uip_conn *conn;
  PROCESS_BEGIN();

  for(i = 0; i < UIP_CONNS; ++i) {
    conn = &uip_conns[i];
    snprintf(buf, BUFLEN,
 8002a6c:	469b      	mov	fp, r3
	     "%d, %u.%u.%u.%u:%u, %s, %u, %u, %c %c",
	     uip_htons(conn->lport),
	     conn->ripaddr.u8[0],
	     conn->ripaddr.u8[1],
 8002a6e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8002a70:	785b      	ldrb	r3, [r3, #1]
  struct uip_conn *conn;
  PROCESS_BEGIN();

  for(i = 0; i < UIP_CONNS; ++i) {
    conn = &uip_conns[i];
    snprintf(buf, BUFLEN,
 8002a72:	469a      	mov	sl, r3
	     "%d, %u.%u.%u.%u:%u, %s, %u, %u, %c %c",
	     uip_htons(conn->lport),
	     conn->ripaddr.u8[0],
	     conn->ripaddr.u8[1],
	     conn->ripaddr.u8[2],
 8002a74:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8002a76:	789b      	ldrb	r3, [r3, #2]
  struct uip_conn *conn;
  PROCESS_BEGIN();

  for(i = 0; i < UIP_CONNS; ++i) {
    conn = &uip_conns[i];
    snprintf(buf, BUFLEN,
 8002a78:	4699      	mov	r9, r3
	     "%d, %u.%u.%u.%u:%u, %s, %u, %u, %c %c",
	     uip_htons(conn->lport),
	     conn->ripaddr.u8[0],
	     conn->ripaddr.u8[1],
	     conn->ripaddr.u8[2],
	     conn->ripaddr.u8[3],
 8002a7a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8002a7c:	78db      	ldrb	r3, [r3, #3]
  struct uip_conn *conn;
  PROCESS_BEGIN();

  for(i = 0; i < UIP_CONNS; ++i) {
    conn = &uip_conns[i];
    snprintf(buf, BUFLEN,
 8002a7e:	4698      	mov	r8, r3
	     uip_htons(conn->lport),
	     conn->ripaddr.u8[0],
	     conn->ripaddr.u8[1],
	     conn->ripaddr.u8[2],
	     conn->ripaddr.u8[3],
	     uip_htons(conn->rport),
 8002a80:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8002a82:	88db      	ldrh	r3, [r3, #6]
 8002a84:	4618      	mov	r0, r3
 8002a86:	f003 ffb3 	bl	80069f0 <uip_htons>
 8002a8a:	4603      	mov	r3, r0
  struct uip_conn *conn;
  PROCESS_BEGIN();

  for(i = 0; i < UIP_CONNS; ++i) {
    conn = &uip_conns[i];
    snprintf(buf, BUFLEN,
 8002a8c:	469e      	mov	lr, r3
	     conn->ripaddr.u8[0],
	     conn->ripaddr.u8[1],
	     conn->ripaddr.u8[2],
	     conn->ripaddr.u8[3],
	     uip_htons(conn->rport),
	     states[conn->tcpstateflags & UIP_TS_MASK],
 8002a8e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8002a90:	7e5b      	ldrb	r3, [r3, #25]
 8002a92:	f003 020f 	and.w	r2, r3, #15
  struct uip_conn *conn;
  PROCESS_BEGIN();

  for(i = 0; i < UIP_CONNS; ++i) {
    conn = &uip_conns[i];
    snprintf(buf, BUFLEN,
 8002a96:	f240 736c 	movw	r3, #1900	; 0x76c
 8002a9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002a9e:	f853 6022 	ldr.w	r6, [r3, r2, lsl #2]
	     conn->ripaddr.u8[1],
	     conn->ripaddr.u8[2],
	     conn->ripaddr.u8[3],
	     uip_htons(conn->rport),
	     states[conn->tcpstateflags & UIP_TS_MASK],
	     conn->nrtx,
 8002aa2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8002aa4:	7edb      	ldrb	r3, [r3, #27]
  struct uip_conn *conn;
  PROCESS_BEGIN();

  for(i = 0; i < UIP_CONNS; ++i) {
    conn = &uip_conns[i];
    snprintf(buf, BUFLEN,
 8002aa6:	461d      	mov	r5, r3
	     conn->ripaddr.u8[2],
	     conn->ripaddr.u8[3],
	     uip_htons(conn->rport),
	     states[conn->tcpstateflags & UIP_TS_MASK],
	     conn->nrtx,
	     conn->timer,
 8002aa8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8002aaa:	7e9b      	ldrb	r3, [r3, #26]
  struct uip_conn *conn;
  PROCESS_BEGIN();

  for(i = 0; i < UIP_CONNS; ++i) {
    conn = &uip_conns[i];
    snprintf(buf, BUFLEN,
 8002aac:	4618      	mov	r0, r3
	     conn->ripaddr.u8[3],
	     uip_htons(conn->rport),
	     states[conn->tcpstateflags & UIP_TS_MASK],
	     conn->nrtx,
	     conn->timer,
	     (uip_outstanding(conn))? '*':' ',
 8002aae:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8002ab0:	8a1b      	ldrh	r3, [r3, #16]
  struct uip_conn *conn;
  PROCESS_BEGIN();

  for(i = 0; i < UIP_CONNS; ++i) {
    conn = &uip_conns[i];
    snprintf(buf, BUFLEN,
 8002ab2:	2b00      	cmp	r3, #0
 8002ab4:	d001      	beq.n	8002aba <process_thread_shell_netstat_process+0x9a>
 8002ab6:	222a      	movs	r2, #42	; 0x2a
 8002ab8:	e000      	b.n	8002abc <process_thread_shell_netstat_process+0x9c>
 8002aba:	2220      	movs	r2, #32
	     uip_htons(conn->rport),
	     states[conn->tcpstateflags & UIP_TS_MASK],
	     conn->nrtx,
	     conn->timer,
	     (uip_outstanding(conn))? '*':' ',
	     (uip_stopped(conn))? '!':' ');
 8002abc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8002abe:	7e5b      	ldrb	r3, [r3, #25]
 8002ac0:	f003 0310 	and.w	r3, r3, #16
  struct uip_conn *conn;
  PROCESS_BEGIN();

  for(i = 0; i < UIP_CONNS; ++i) {
    conn = &uip_conns[i];
    snprintf(buf, BUFLEN,
 8002ac4:	2b00      	cmp	r3, #0
 8002ac6:	d001      	beq.n	8002acc <process_thread_shell_netstat_process+0xac>
 8002ac8:	2321      	movs	r3, #33	; 0x21
 8002aca:	e000      	b.n	8002ace <process_thread_shell_netstat_process+0xae>
 8002acc:	2320      	movs	r3, #32
 8002ace:	f107 0110 	add.w	r1, r7, #16
 8002ad2:	f8cd b000 	str.w	fp, [sp]
 8002ad6:	f8cd a004 	str.w	sl, [sp, #4]
 8002ada:	f8cd 9008 	str.w	r9, [sp, #8]
 8002ade:	f8cd 800c 	str.w	r8, [sp, #12]
 8002ae2:	f8cd e010 	str.w	lr, [sp, #16]
 8002ae6:	9605      	str	r6, [sp, #20]
 8002ae8:	9506      	str	r5, [sp, #24]
 8002aea:	9007      	str	r0, [sp, #28]
 8002aec:	9208      	str	r2, [sp, #32]
 8002aee:	9309      	str	r3, [sp, #36]	; 0x24
 8002af0:	4608      	mov	r0, r1
 8002af2:	2164      	movs	r1, #100	; 0x64
 8002af4:	f648 622c 	movw	r2, #36396	; 0x8e2c
 8002af8:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002afc:	4623      	mov	r3, r4
 8002afe:	f005 fe79 	bl	80087f4 <snprintf>
	     states[conn->tcpstateflags & UIP_TS_MASK],
	     conn->nrtx,
	     conn->timer,
	     (uip_outstanding(conn))? '*':' ',
	     (uip_stopped(conn))? '!':' ');
    shell_output_str(&netstat_command, "TCP ", buf);
 8002b02:	f107 0310 	add.w	r3, r7, #16
 8002b06:	f240 70ac 	movw	r0, #1964	; 0x7ac
 8002b0a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002b0e:	f648 6154 	movw	r1, #36436	; 0x8e54
 8002b12:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002b16:	461a      	mov	r2, r3
 8002b18:	f7fe fb88 	bl	800122c <shell_output_str>
  char buf[BUFLEN];
  int i;
  struct uip_conn *conn;
  PROCESS_BEGIN();

  for(i = 0; i < UIP_CONNS; ++i) {
 8002b1c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8002b1e:	3301      	adds	r3, #1
 8002b20:	67fb      	str	r3, [r7, #124]	; 0x7c
 8002b22:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8002b24:	2b27      	cmp	r3, #39	; 0x27
 8002b26:	dd8d      	ble.n	8002a44 <process_thread_shell_netstat_process+0x24>
	     conn->timer,
	     (uip_outstanding(conn))? '*':' ',
	     (uip_stopped(conn))? '!':' ');
    shell_output_str(&netstat_command, "TCP ", buf);
  }
  PROCESS_END();
 8002b28:	2300      	movs	r3, #0
 8002b2a:	f887 307b 	strb.w	r3, [r7, #123]	; 0x7b
 8002b2e:	68fb      	ldr	r3, [r7, #12]
 8002b30:	2200      	movs	r2, #0
 8002b32:	801a      	strh	r2, [r3, #0]
 8002b34:	2303      	movs	r3, #3
}
 8002b36:	4618      	mov	r0, r3
 8002b38:	f107 0784 	add.w	r7, r7, #132	; 0x84
 8002b3c:	46bd      	mov	sp, r7
 8002b3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002b42:	bf00      	nop

08002b44 <shell_netstat_init>:
/*---------------------------------------------------------------------------*/
void
shell_netstat_init(void)
{
 8002b44:	b580      	push	{r7, lr}
 8002b46:	af00      	add	r7, sp, #0
  shell_register_command(&netstat_command);
 8002b48:	f240 70ac 	movw	r0, #1964	; 0x7ac
 8002b4c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002b50:	f7fe fbc2 	bl	80012d8 <shell_register_command>
}
 8002b54:	bd80      	pop	{r7, pc}
 8002b56:	bf00      	nop

08002b58 <process_thread_shell_poke_process>:
	      "peek",
	      "peek <address>: read a byte from address <address>",
	      &shell_peek_process);
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_poke_process, ev, data)
{
 8002b58:	b580      	push	{r7, lr}
 8002b5a:	b08a      	sub	sp, #40	; 0x28
 8002b5c:	af00      	add	r7, sp, #0
 8002b5e:	60f8      	str	r0, [r7, #12]
 8002b60:	460b      	mov	r3, r1
 8002b62:	607a      	str	r2, [r7, #4]
 8002b64:	72fb      	strb	r3, [r7, #11]
  uint8_t *address;
  uint8_t byte;
  const char *args, *next;

  PROCESS_BEGIN();
 8002b66:	2301      	movs	r3, #1
 8002b68:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8002b6c:	68fb      	ldr	r3, [r7, #12]
 8002b6e:	881b      	ldrh	r3, [r3, #0]
 8002b70:	2b00      	cmp	r3, #0
 8002b72:	d163      	bne.n	8002c3c <process_thread_shell_poke_process+0xe4>

  args = data;
 8002b74:	687b      	ldr	r3, [r7, #4]
 8002b76:	623b      	str	r3, [r7, #32]

  if(args == NULL) {
 8002b78:	6a3b      	ldr	r3, [r7, #32]
 8002b7a:	2b00      	cmp	r3, #0
 8002b7c:	d112      	bne.n	8002ba4 <process_thread_shell_poke_process+0x4c>
    shell_output_str(&poke_command, "usage 0", "");
 8002b7e:	f240 70d0 	movw	r0, #2000	; 0x7d0
 8002b82:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002b86:	f648 61e0 	movw	r1, #36576	; 0x8ee0
 8002b8a:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002b8e:	f648 62e8 	movw	r2, #36584	; 0x8ee8
 8002b92:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002b96:	f7fe fb49 	bl	800122c <shell_output_str>
    PROCESS_EXIT();
 8002b9a:	68fb      	ldr	r3, [r7, #12]
 8002b9c:	2200      	movs	r2, #0
 8002b9e:	801a      	strh	r2, [r3, #0]
 8002ba0:	2302      	movs	r3, #2
 8002ba2:	e052      	b.n	8002c4a <process_thread_shell_poke_process+0xf2>
  }
  
  address = (uint8_t *)(int)shell_strtolong(args, &next);
 8002ba4:	f107 0314 	add.w	r3, r7, #20
 8002ba8:	6a38      	ldr	r0, [r7, #32]
 8002baa:	4619      	mov	r1, r3
 8002bac:	f7fe fd5c 	bl	8001668 <shell_strtolong>
 8002bb0:	4603      	mov	r3, r0
 8002bb2:	61fb      	str	r3, [r7, #28]
  if(next == args) {
 8002bb4:	697a      	ldr	r2, [r7, #20]
 8002bb6:	6a3b      	ldr	r3, [r7, #32]
 8002bb8:	429a      	cmp	r2, r3
 8002bba:	d112      	bne.n	8002be2 <process_thread_shell_poke_process+0x8a>
    shell_output_str(&poke_command, "usage 1", "");
 8002bbc:	f240 70d0 	movw	r0, #2000	; 0x7d0
 8002bc0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002bc4:	f648 61ec 	movw	r1, #36588	; 0x8eec
 8002bc8:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002bcc:	f648 62e8 	movw	r2, #36584	; 0x8ee8
 8002bd0:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002bd4:	f7fe fb2a 	bl	800122c <shell_output_str>
    PROCESS_EXIT();
 8002bd8:	68fb      	ldr	r3, [r7, #12]
 8002bda:	2200      	movs	r2, #0
 8002bdc:	801a      	strh	r2, [r3, #0]
 8002bde:	2302      	movs	r3, #2
 8002be0:	e033      	b.n	8002c4a <process_thread_shell_poke_process+0xf2>
  }

  args = next;
 8002be2:	697b      	ldr	r3, [r7, #20]
 8002be4:	623b      	str	r3, [r7, #32]
  byte = shell_strtolong(args, &next);
 8002be6:	f107 0314 	add.w	r3, r7, #20
 8002bea:	6a38      	ldr	r0, [r7, #32]
 8002bec:	4619      	mov	r1, r3
 8002bee:	f7fe fd3b 	bl	8001668 <shell_strtolong>
 8002bf2:	4603      	mov	r3, r0
 8002bf4:	76fb      	strb	r3, [r7, #27]
  if(next == args) {
 8002bf6:	697a      	ldr	r2, [r7, #20]
 8002bf8:	6a3b      	ldr	r3, [r7, #32]
 8002bfa:	429a      	cmp	r2, r3
 8002bfc:	d112      	bne.n	8002c24 <process_thread_shell_poke_process+0xcc>
    shell_output_str(&poke_command, "usage 2", "");
 8002bfe:	f240 70d0 	movw	r0, #2000	; 0x7d0
 8002c02:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002c06:	f648 61f4 	movw	r1, #36596	; 0x8ef4
 8002c0a:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002c0e:	f648 62e8 	movw	r2, #36584	; 0x8ee8
 8002c12:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002c16:	f7fe fb09 	bl	800122c <shell_output_str>
    PROCESS_EXIT();
 8002c1a:	68fb      	ldr	r3, [r7, #12]
 8002c1c:	2200      	movs	r2, #0
 8002c1e:	801a      	strh	r2, [r3, #0]
 8002c20:	2302      	movs	r3, #2
 8002c22:	e012      	b.n	8002c4a <process_thread_shell_poke_process+0xf2>
  }

  printf("address %p byte 0x%02x\n", address, byte);
 8002c24:	7efb      	ldrb	r3, [r7, #27]
 8002c26:	f648 60fc 	movw	r0, #36604	; 0x8efc
 8002c2a:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002c2e:	69f9      	ldr	r1, [r7, #28]
 8002c30:	461a      	mov	r2, r3
 8002c32:	f005 fa87 	bl	8008144 <printf>
  
  *address = byte;
 8002c36:	69fb      	ldr	r3, [r7, #28]
 8002c38:	7efa      	ldrb	r2, [r7, #27]
 8002c3a:	701a      	strb	r2, [r3, #0]
  
  PROCESS_END();
 8002c3c:	2300      	movs	r3, #0
 8002c3e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8002c42:	68fb      	ldr	r3, [r7, #12]
 8002c44:	2200      	movs	r2, #0
 8002c46:	801a      	strh	r2, [r3, #0]
 8002c48:	2303      	movs	r3, #3
}
 8002c4a:	4618      	mov	r0, r3
 8002c4c:	f107 0728 	add.w	r7, r7, #40	; 0x28
 8002c50:	46bd      	mov	sp, r7
 8002c52:	bd80      	pop	{r7, pc}

08002c54 <process_thread_shell_peek_process>:
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(shell_peek_process, ev, data)
{
 8002c54:	b580      	push	{r7, lr}
 8002c56:	b090      	sub	sp, #64	; 0x40
 8002c58:	af00      	add	r7, sp, #0
 8002c5a:	60f8      	str	r0, [r7, #12]
 8002c5c:	460b      	mov	r3, r1
 8002c5e:	607a      	str	r2, [r7, #4]
 8002c60:	72fb      	strb	r3, [r7, #11]
  uint8_t *address;
  const char *args, *next;
  char buf[32];

  PROCESS_BEGIN();
 8002c62:	2301      	movs	r3, #1
 8002c64:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
 8002c68:	68fb      	ldr	r3, [r7, #12]
 8002c6a:	881b      	ldrh	r3, [r3, #0]
 8002c6c:	2b00      	cmp	r3, #0
 8002c6e:	d14f      	bne.n	8002d10 <process_thread_shell_peek_process+0xbc>

  args = data;
 8002c70:	687b      	ldr	r3, [r7, #4]
 8002c72:	63bb      	str	r3, [r7, #56]	; 0x38

  if(args == NULL) {
 8002c74:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8002c76:	2b00      	cmp	r3, #0
 8002c78:	d112      	bne.n	8002ca0 <process_thread_shell_peek_process+0x4c>
    shell_output_str(&peek_command, "usage 0", "");
 8002c7a:	f240 70f4 	movw	r0, #2036	; 0x7f4
 8002c7e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002c82:	f648 61e0 	movw	r1, #36576	; 0x8ee0
 8002c86:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002c8a:	f648 62e8 	movw	r2, #36584	; 0x8ee8
 8002c8e:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002c92:	f7fe facb 	bl	800122c <shell_output_str>
    PROCESS_EXIT();
 8002c96:	68fb      	ldr	r3, [r7, #12]
 8002c98:	2200      	movs	r2, #0
 8002c9a:	801a      	strh	r2, [r3, #0]
 8002c9c:	2302      	movs	r3, #2
 8002c9e:	e03e      	b.n	8002d1e <process_thread_shell_peek_process+0xca>
  }
  
  address = (uint8_t *)(int)shell_strtolong(args, &next);
 8002ca0:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8002ca4:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8002ca6:	4619      	mov	r1, r3
 8002ca8:	f7fe fcde 	bl	8001668 <shell_strtolong>
 8002cac:	4603      	mov	r3, r0
 8002cae:	637b      	str	r3, [r7, #52]	; 0x34
  if(next == args) {
 8002cb0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8002cb2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8002cb4:	429a      	cmp	r2, r3
 8002cb6:	d112      	bne.n	8002cde <process_thread_shell_peek_process+0x8a>
    shell_output_str(&peek_command, "usage 1", "");
 8002cb8:	f240 70f4 	movw	r0, #2036	; 0x7f4
 8002cbc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002cc0:	f648 61ec 	movw	r1, #36588	; 0x8eec
 8002cc4:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002cc8:	f648 62e8 	movw	r2, #36584	; 0x8ee8
 8002ccc:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002cd0:	f7fe faac 	bl	800122c <shell_output_str>
    PROCESS_EXIT();
 8002cd4:	68fb      	ldr	r3, [r7, #12]
 8002cd6:	2200      	movs	r2, #0
 8002cd8:	801a      	strh	r2, [r3, #0]
 8002cda:	2302      	movs	r3, #2
 8002cdc:	e01f      	b.n	8002d1e <process_thread_shell_peek_process+0xca>
  }

  snprintf(buf, sizeof(buf), "0x%02x", *address);
 8002cde:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002ce0:	781b      	ldrb	r3, [r3, #0]
 8002ce2:	f107 0210 	add.w	r2, r7, #16
 8002ce6:	4610      	mov	r0, r2
 8002ce8:	2120      	movs	r1, #32
 8002cea:	f648 7214 	movw	r2, #36628	; 0x8f14
 8002cee:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002cf2:	f005 fd7f 	bl	80087f4 <snprintf>

  shell_output_str(&peek_command, buf, "");
 8002cf6:	f107 0310 	add.w	r3, r7, #16
 8002cfa:	f240 70f4 	movw	r0, #2036	; 0x7f4
 8002cfe:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002d02:	4619      	mov	r1, r3
 8002d04:	f648 62e8 	movw	r2, #36584	; 0x8ee8
 8002d08:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002d0c:	f7fe fa8e 	bl	800122c <shell_output_str>
  
  PROCESS_END();
 8002d10:	2300      	movs	r3, #0
 8002d12:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
 8002d16:	68fb      	ldr	r3, [r7, #12]
 8002d18:	2200      	movs	r2, #0
 8002d1a:	801a      	strh	r2, [r3, #0]
 8002d1c:	2303      	movs	r3, #3
}
 8002d1e:	4618      	mov	r0, r3
 8002d20:	f107 0740 	add.w	r7, r7, #64	; 0x40
 8002d24:	46bd      	mov	sp, r7
 8002d26:	bd80      	pop	{r7, pc}

08002d28 <shell_memdebug_init>:
/*---------------------------------------------------------------------------*/
void
shell_memdebug_init(void)
{
 8002d28:	b580      	push	{r7, lr}
 8002d2a:	af00      	add	r7, sp, #0
  shell_register_command(&poke_command);
 8002d2c:	f240 70d0 	movw	r0, #2000	; 0x7d0
 8002d30:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002d34:	f7fe fad0 	bl	80012d8 <shell_register_command>
  shell_register_command(&peek_command);
 8002d38:	f240 70f4 	movw	r0, #2036	; 0x7f4
 8002d3c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002d40:	f7fe faca 	bl	80012d8 <shell_register_command>
}
 8002d44:	bd80      	pop	{r7, pc}
 8002d46:	bf00      	nop

08002d48 <putchar>:
{UIP_FW_NETIF(172,16,0,0, 255,255,0,0, slip_send)};

#undef putchar

int __attribute__(( weak )) putchar(int c)
{
 8002d48:	b480      	push	{r7}
 8002d4a:	b083      	sub	sp, #12
 8002d4c:	af00      	add	r7, sp, #0
 8002d4e:	6078      	str	r0, [r7, #4]
  //uart3_writeb(c);
  return c;
 8002d50:	687b      	ldr	r3, [r7, #4]
}
 8002d52:	4618      	mov	r0, r3
 8002d54:	f107 070c 	add.w	r7, r7, #12
 8002d58:	46bd      	mov	sp, r7
 8002d5a:	bc80      	pop	{r7}
 8002d5c:	4770      	bx	lr
 8002d5e:	bf00      	nop

08002d60 <__io_putchar>:

void __io_putchar(char c)
{
 8002d60:	b580      	push	{r7, lr}
 8002d62:	b082      	sub	sp, #8
 8002d64:	af00      	add	r7, sp, #0
 8002d66:	4603      	mov	r3, r0
 8002d68:	71fb      	strb	r3, [r7, #7]
  putchar(c);
 8002d6a:	79fb      	ldrb	r3, [r7, #7]
 8002d6c:	4618      	mov	r0, r3
 8002d6e:	f7ff ffeb 	bl	8002d48 <putchar>
}
 8002d72:	f107 0708 	add.w	r7, r7, #8
 8002d76:	46bd      	mov	sp, r7
 8002d78:	bd80      	pop	{r7, pc}
 8002d7a:	bf00      	nop

08002d7c <main>:


/*---------------------------------------------------------------------------*/
int
main(void)
{
 8002d7c:	b580      	push	{r7, lr}
 8002d7e:	af00      	add	r7, sp, #0
	//DBGMCU_Config(DBGMCU_SLEEP | DBGMCU_STOP | DBGMCU_STANDBY, ENABLE);

	uart1_init(0);
 8002d80:	2000      	movs	r0, #0
 8002d82:	f000 fae5 	bl	8003350 <uart1_init>
	slip_arch_init(0);
 8002d86:	2000      	movs	r0, #0
 8002d88:	f000 fb90 	bl	80034ac <slip_arch_init>
	leds_init();
 8002d8c:	f000 fbce 	bl	800352c <leds_init>
	//printf("\rStarting Contiki...\n\r");

	clock_init();
 8002d90:	f000 fa66 	bl	8003260 <clock_init>
	process_init();
 8002d94:	f001 f8dc 	bl	8003f50 <process_init>

	//serial_line_init();
	//uart3_set_input(serial_line_input_byte);

	uip_init();
 8002d98:	f001 ff42 	bl	8004c20 <uip_init>
	uip_fw_init();
 8002d9c:	f004 fa6e 	bl	800727c <uip_fw_init>
	process_start(&tcpip_process, NULL);
 8002da0:	f640 0050 	movw	r0, #2128	; 0x850
 8002da4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002da8:	2100      	movs	r1, #0
 8002daa:	f000 ffd1 	bl	8003d50 <process_start>
	process_start(&slip_process, NULL);
 8002dae:	f640 001c 	movw	r0, #2076	; 0x81c
 8002db2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002db6:	2100      	movs	r1, #0
 8002db8:	f000 ffca 	bl	8003d50 <process_start>
	process_start(&uip_fw_process, NULL);
 8002dbc:	f640 0060 	movw	r0, #2144	; 0x860
 8002dc0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002dc4:	2100      	movs	r1, #0
 8002dc6:	f000 ffc3 	bl	8003d50 <process_start>

	uip_ipaddr(&hostaddr, 172, 16, 0, 1);
 8002dca:	f241 63fc 	movw	r3, #5884	; 0x16fc
 8002dce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002dd2:	22ac      	movs	r2, #172	; 0xac
 8002dd4:	701a      	strb	r2, [r3, #0]
 8002dd6:	f241 63fc 	movw	r3, #5884	; 0x16fc
 8002dda:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002dde:	2210      	movs	r2, #16
 8002de0:	705a      	strb	r2, [r3, #1]
 8002de2:	f241 63fc 	movw	r3, #5884	; 0x16fc
 8002de6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002dea:	2200      	movs	r2, #0
 8002dec:	709a      	strb	r2, [r3, #2]
 8002dee:	f241 63fc 	movw	r3, #5884	; 0x16fc
 8002df2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002df6:	2201      	movs	r2, #1
 8002df8:	70da      	strb	r2, [r3, #3]
	uip_sethostaddr(&hostaddr);
 8002dfa:	f641 62c4 	movw	r2, #7876	; 0x1ec4
 8002dfe:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8002e02:	f241 63fc 	movw	r3, #5884	; 0x16fc
 8002e06:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002e0a:	6818      	ldr	r0, [r3, #0]
 8002e0c:	6010      	str	r0, [r2, #0]
	uip_ipaddr(&netmask, 255, 255, 0, 0);
 8002e0e:	f241 7300 	movw	r3, #5888	; 0x1700
 8002e12:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002e16:	22ff      	movs	r2, #255	; 0xff
 8002e18:	701a      	strb	r2, [r3, #0]
 8002e1a:	f241 7300 	movw	r3, #5888	; 0x1700
 8002e1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002e22:	22ff      	movs	r2, #255	; 0xff
 8002e24:	705a      	strb	r2, [r3, #1]
 8002e26:	f241 7300 	movw	r3, #5888	; 0x1700
 8002e2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002e2e:	2200      	movs	r2, #0
 8002e30:	709a      	strb	r2, [r3, #2]
 8002e32:	f241 7300 	movw	r3, #5888	; 0x1700
 8002e36:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002e3a:	2200      	movs	r2, #0
 8002e3c:	70da      	strb	r2, [r3, #3]
	uip_setnetmask(&netmask);
 8002e3e:	f641 62c0 	movw	r2, #7872	; 0x1ec0
 8002e42:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8002e46:	f241 7300 	movw	r3, #5888	; 0x1700
 8002e4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002e4e:	6818      	ldr	r0, [r3, #0]
 8002e50:	6010      	str	r0, [r2, #0]
	uip_ipaddr(&netmask, 172, 16, 0, 2);
 8002e52:	f241 7300 	movw	r3, #5888	; 0x1700
 8002e56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002e5a:	22ac      	movs	r2, #172	; 0xac
 8002e5c:	701a      	strb	r2, [r3, #0]
 8002e5e:	f241 7300 	movw	r3, #5888	; 0x1700
 8002e62:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002e66:	2210      	movs	r2, #16
 8002e68:	705a      	strb	r2, [r3, #1]
 8002e6a:	f241 7300 	movw	r3, #5888	; 0x1700
 8002e6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002e72:	2200      	movs	r2, #0
 8002e74:	709a      	strb	r2, [r3, #2]
 8002e76:	f241 7300 	movw	r3, #5888	; 0x1700
 8002e7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002e7e:	2202      	movs	r2, #2
 8002e80:	70da      	strb	r2, [r3, #3]
	uip_setdraddr(&draddr);
 8002e82:	f641 62bc 	movw	r2, #7868	; 0x1ebc
 8002e86:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8002e8a:	f241 7304 	movw	r3, #5892	; 0x1704
 8002e8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002e92:	6818      	ldr	r0, [r3, #0]
 8002e94:	6010      	str	r0, [r2, #0]
	uip_fw_register(&slipif);
 8002e96:	f640 0008 	movw	r0, #2056	; 0x808
 8002e9a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002e9e:	f004 fafd 	bl	800749c <uip_fw_register>
	uip_fw_default(&slipif);
 8002ea2:	f640 0008 	movw	r0, #2056	; 0x808
 8002ea6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002eaa:	f004 fb0d 	bl	80074c8 <uip_fw_default>

	process_start(&etimer_process, NULL);
 8002eae:	f640 002c 	movw	r0, #2092	; 0x82c
 8002eb2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002eb6:	2100      	movs	r1, #0
 8002eb8:	f000 ff4a 	bl	8003d50 <process_start>
	ctimer_init();
 8002ebc:	f001 fd2c 	bl	8004918 <ctimer_init>

	autostart_start(autostart_processes);
 8002ec0:	f249 2068 	movw	r0, #37480	; 0x9268
 8002ec4:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002ec8:	f001 fa40 	bl	800434c <autostart_start>

	while (1)
	{
		process_run();
 8002ecc:	f001 f966 	bl	800419c <process_run>
	}
 8002ed0:	e7fc      	b.n	8002ecc <main+0x150>
 8002ed2:	bf00      	nop

08002ed4 <uip_log>:
	shell_output_str(NULL, m1, m2);
}
/*---------------------------------------------------------------------------*/
void
uip_log(char *m)
{
 8002ed4:	b580      	push	{r7, lr}
 8002ed6:	b082      	sub	sp, #8
 8002ed8:	af00      	add	r7, sp, #0
 8002eda:	6078      	str	r0, [r7, #4]
	shell_output_str(NULL, m, "\n\r");
 8002edc:	2000      	movs	r0, #0
 8002ede:	6879      	ldr	r1, [r7, #4]
 8002ee0:	f648 721c 	movw	r2, #36636	; 0x8f1c
 8002ee4:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002ee8:	f7fe f9a0 	bl	800122c <shell_output_str>
}
 8002eec:	f107 0708 	add.w	r7, r7, #8
 8002ef0:	46bd      	mov	sp, r7
 8002ef2:	bd80      	pop	{r7, pc}

08002ef4 <Reset_Handler>:
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8002ef4:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8002ef6:	f000 b804 	b.w	8002f02 <LoopCopyDataInit>

08002efa <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8002efa:	4b0d      	ldr	r3, [pc, #52]	; (8002f30 <LoopFillZerobss+0x16>)
  ldr  r3, [r3, r1]
 8002efc:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8002efe:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8002f00:	3104      	adds	r1, #4

08002f02 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8002f02:	480c      	ldr	r0, [pc, #48]	; (8002f34 <LoopFillZerobss+0x1a>)
  ldr  r3, =_edata
 8002f04:	4b0c      	ldr	r3, [pc, #48]	; (8002f38 <LoopFillZerobss+0x1e>)
  adds  r2, r0, r1
 8002f06:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8002f08:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8002f0a:	f4ff aff6 	bcc.w	8002efa <CopyDataInit>
  ldr  r2, =_sbss
 8002f0e:	4a0b      	ldr	r2, [pc, #44]	; (8002f3c <LoopFillZerobss+0x22>)
  b  LoopFillZerobss
 8002f10:	f000 b803 	b.w	8002f1a <LoopFillZerobss>

08002f14 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8002f14:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8002f16:	f842 3b04 	str.w	r3, [r2], #4

08002f1a <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8002f1a:	4b09      	ldr	r3, [pc, #36]	; (8002f40 <LoopFillZerobss+0x26>)
  cmp  r2, r3
 8002f1c:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8002f1e:	f4ff aff9 	bcc.w	8002f14 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8002f22:	f000 f811 	bl	8002f48 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8002f26:	f7fd f987 	bl	8000238 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8002f2a:	f7ff ff27 	bl	8002d7c <main>
  bx  lr    
 8002f2e:	4770      	bx	lr
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 8002f30:	08009344 	.word	0x08009344
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8002f34:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8002f38:	20000880 	.word	0x20000880
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 8002f3c:	20000880 	.word	0x20000880
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8002f40:	20001f98 	.word	0x20001f98

08002f44 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8002f44:	f7ff bffe 	b.w	8002f44 <ADC_IRQHandler>

08002f48 <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8002f48:	b580      	push	{r7, lr}
 8002f4a:	af00      	add	r7, sp, #0
	/* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
	SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8002f4c:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8002f50:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002f54:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 8002f58:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8002f5c:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 8002f60:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8002f64:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
#endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8002f68:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002f6c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002f70:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8002f74:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002f78:	6812      	ldr	r2, [r2, #0]
 8002f7a:	f042 0201 	orr.w	r2, r2, #1
 8002f7e:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8002f80:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002f84:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002f88:	2200      	movs	r2, #0
 8002f8a:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8002f8c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002f90:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002f94:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8002f98:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002f9c:	6812      	ldr	r2, [r2, #0]
 8002f9e:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8002fa2:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002fa6:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8002fa8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002fac:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002fb0:	f243 0210 	movw	r2, #12304	; 0x3010
 8002fb4:	f2c2 4200 	movt	r2, #9216	; 0x2400
 8002fb8:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8002fba:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002fbe:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002fc2:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8002fc6:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002fca:	6812      	ldr	r2, [r2, #0]
 8002fcc:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8002fd0:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8002fd2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002fd6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002fda:	2200      	movs	r2, #0
 8002fdc:	60da      	str	r2, [r3, #12]
  SystemInit_ExtMemCtl(); 
#endif /* DATA_IN_ExtSRAM */
         
  /* Configure the System clock source, PLL Multiplier and Divider factors, 
     AHB/APBx prescalers and Flash settings ----------------------------------*/
  SetSysClock();
 8002fde:	f000 f809 	bl	8002ff4 <SetSysClock>

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8002fe2:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8002fe6:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002fea:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8002fee:	609a      	str	r2, [r3, #8]
#endif
}
 8002ff0:	bd80      	pop	{r7, pc}
 8002ff2:	bf00      	nop

08002ff4 <SetSysClock>:
  *         is reset to the default reset state (done in SystemInit() function).   
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 8002ff4:	b480      	push	{r7}
 8002ff6:	b083      	sub	sp, #12
 8002ff8:	af00      	add	r7, sp, #0
/******************************************************************************/
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 8002ffa:	2300      	movs	r3, #0
 8002ffc:	607b      	str	r3, [r7, #4]
 8002ffe:	2300      	movs	r3, #0
 8003000:	603b      	str	r3, [r7, #0]
  
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8003002:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8003006:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800300a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800300e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003012:	6812      	ldr	r2, [r2, #0]
 8003014:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8003018:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 800301a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800301e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003022:	681b      	ldr	r3, [r3, #0]
 8003024:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003028:	603b      	str	r3, [r7, #0]
    StartUpCounter++;
 800302a:	687b      	ldr	r3, [r7, #4]
 800302c:	3301      	adds	r3, #1
 800302e:	607b      	str	r3, [r7, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8003030:	683b      	ldr	r3, [r7, #0]
 8003032:	2b00      	cmp	r3, #0
 8003034:	d103      	bne.n	800303e <SetSysClock+0x4a>
 8003036:	687b      	ldr	r3, [r7, #4]
 8003038:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 800303c:	d1ed      	bne.n	800301a <SetSysClock+0x26>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 800303e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8003042:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003046:	681b      	ldr	r3, [r3, #0]
 8003048:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800304c:	2b00      	cmp	r3, #0
 800304e:	d002      	beq.n	8003056 <SetSysClock+0x62>
  {
    HSEStatus = (uint32_t)0x01;
 8003050:	2301      	movs	r3, #1
 8003052:	603b      	str	r3, [r7, #0]
 8003054:	e001      	b.n	800305a <SetSysClock+0x66>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 8003056:	2300      	movs	r3, #0
 8003058:	603b      	str	r3, [r7, #0]
  }

  if (HSEStatus == (uint32_t)0x01)
 800305a:	683b      	ldr	r3, [r7, #0]
 800305c:	2b01      	cmp	r3, #1
 800305e:	f040 8082 	bne.w	8003166 <SetSysClock+0x172>
  {
    /* Enable high performance mode, System frequency up to 168 MHz */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 8003062:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8003066:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800306a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800306e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003072:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8003074:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8003078:	641a      	str	r2, [r3, #64]	; 0x40
    PWR->CR |= PWR_CR_PMODE;  
 800307a:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 800307e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8003082:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 8003086:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800308a:	6812      	ldr	r2, [r2, #0]
 800308c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8003090:	601a      	str	r2, [r3, #0]

    /* HCLK = SYSCLK / 1*/
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 8003092:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8003096:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800309a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800309e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80030a2:	6892      	ldr	r2, [r2, #8]
 80030a4:	609a      	str	r2, [r3, #8]
      
    /* PCLK2 = HCLK / 2*/
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 80030a6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80030aa:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80030ae:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80030b2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80030b6:	6892      	ldr	r2, [r2, #8]
 80030b8:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80030bc:	609a      	str	r2, [r3, #8]
    
    /* PCLK1 = HCLK / 4*/
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 80030be:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80030c2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80030c6:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80030ca:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80030ce:	6892      	ldr	r2, [r2, #8]
 80030d0:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 80030d4:	609a      	str	r2, [r3, #8]

    /* Configure the main PLL */
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 80030d6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80030da:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80030de:	f245 4208 	movw	r2, #21512	; 0x5408
 80030e2:	f2c0 7240 	movt	r2, #1856	; 0x740
 80030e6:	605a      	str	r2, [r3, #4]
                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

    /* Enable the main PLL */
    RCC->CR |= RCC_CR_PLLON;
 80030e8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80030ec:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80030f0:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80030f4:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80030f8:	6812      	ldr	r2, [r2, #0]
 80030fa:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80030fe:	601a      	str	r2, [r3, #0]

    /* Wait till the main PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8003100:	bf00      	nop
 8003102:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8003106:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800310a:	681b      	ldr	r3, [r3, #0]
 800310c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8003110:	2b00      	cmp	r3, #0
 8003112:	d0f6      	beq.n	8003102 <SetSysClock+0x10e>
    {
    }
   
    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 8003114:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8003118:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800311c:	f240 6205 	movw	r2, #1541	; 0x605
 8003120:	601a      	str	r2, [r3, #0]

    /* Select the main PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8003122:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8003126:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800312a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800312e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003132:	6892      	ldr	r2, [r2, #8]
 8003134:	f022 0203 	bic.w	r2, r2, #3
 8003138:	609a      	str	r2, [r3, #8]
    RCC->CFGR |= RCC_CFGR_SW_PLL;
 800313a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800313e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003142:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8003146:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800314a:	6892      	ldr	r2, [r2, #8]
 800314c:	f042 0202 	orr.w	r2, r2, #2
 8003150:	609a      	str	r2, [r3, #8]

    /* Wait till the main PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 8003152:	bf00      	nop
 8003154:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8003158:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800315c:	689b      	ldr	r3, [r3, #8]
 800315e:	f003 030c 	and.w	r3, r3, #12
 8003162:	2b08      	cmp	r3, #8
 8003164:	d1f6      	bne.n	8003154 <SetSysClock+0x160>

/******************************************************************************/
/*                        I2S clock configuration                             */
/******************************************************************************/
  /* PLLI2S clock used as I2S clock source */
  RCC->CFGR &= ~RCC_CFGR_I2SSRC;
 8003166:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800316a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800316e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8003172:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003176:	6892      	ldr	r2, [r2, #8]
 8003178:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 800317c:	609a      	str	r2, [r3, #8]

  /* Configure PLLI2S */
  RCC->PLLI2SCFGR = (PLLI2S_N << 6) | (PLLI2S_R << 28);
 800317e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8003182:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003186:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 800318a:	f2c5 0200 	movt	r2, #20480	; 0x5000
 800318e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Enable PLLI2S */
  RCC->CR |= ((uint32_t)RCC_CR_PLLI2SON);
 8003192:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8003196:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800319a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800319e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80031a2:	6812      	ldr	r2, [r2, #0]
 80031a4:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 80031a8:	601a      	str	r2, [r3, #0]

  /* Wait till PLLI2S is ready */
  while((RCC->CR & RCC_CR_PLLI2SRDY) == 0)
 80031aa:	bf00      	nop
 80031ac:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80031b0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80031b4:	681b      	ldr	r3, [r3, #0]
 80031b6:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80031ba:	2b00      	cmp	r3, #0
 80031bc:	d0f6      	beq.n	80031ac <SetSysClock+0x1b8>
  {
  }
}
 80031be:	f107 070c 	add.w	r7, r7, #12
 80031c2:	46bd      	mov	sp, r7
 80031c4:	bc80      	pop	{r7}
 80031c6:	4770      	bx	lr

080031c8 <TIM4_IRQHandler>:
static volatile clock_time_t count;
static volatile unsigned long current_seconds = 0;
static unsigned int second_countdown = CLOCK_SECOND;
/*---------------------------------------------------------------------------*/
void TIM4_IRQHandler(void)
{
 80031c8:	b580      	push	{r7, lr}
 80031ca:	af00      	add	r7, sp, #0
  TIM_ClearITPendingBit(TIM4, TIM_IT_Update);
 80031cc:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80031d0:	f2c4 0000 	movt	r0, #16384	; 0x4000
 80031d4:	2101      	movs	r1, #1
 80031d6:	f004 fd0d 	bl	8007bf4 <TIM_ClearITPendingBit>
  count++;
 80031da:	f241 13ec 	movw	r3, #4588	; 0x11ec
 80031de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80031e2:	681b      	ldr	r3, [r3, #0]
 80031e4:	1c5a      	adds	r2, r3, #1
 80031e6:	f241 13ec 	movw	r3, #4588	; 0x11ec
 80031ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80031ee:	601a      	str	r2, [r3, #0]
  if(etimer_pending()) {
 80031f0:	f001 fafe 	bl	80047f0 <etimer_pending>
 80031f4:	4603      	mov	r3, r0
 80031f6:	2b00      	cmp	r3, #0
 80031f8:	d001      	beq.n	80031fe <TIM4_IRQHandler+0x36>
    etimer_request_poll();
 80031fa:	f001 fa73 	bl	80046e4 <etimer_request_poll>
  }

  if (--second_countdown == 0) {
 80031fe:	f640 0318 	movw	r3, #2072	; 0x818
 8003202:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003206:	681b      	ldr	r3, [r3, #0]
 8003208:	1e5a      	subs	r2, r3, #1
 800320a:	f640 0318 	movw	r3, #2072	; 0x818
 800320e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003212:	601a      	str	r2, [r3, #0]
 8003214:	f640 0318 	movw	r3, #2072	; 0x818
 8003218:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800321c:	681b      	ldr	r3, [r3, #0]
 800321e:	2b00      	cmp	r3, #0
 8003220:	d111      	bne.n	8003246 <TIM4_IRQHandler+0x7e>
    current_seconds++;
 8003222:	f241 13f0 	movw	r3, #4592	; 0x11f0
 8003226:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800322a:	681b      	ldr	r3, [r3, #0]
 800322c:	1c5a      	adds	r2, r3, #1
 800322e:	f241 13f0 	movw	r3, #4592	; 0x11f0
 8003232:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003236:	601a      	str	r2, [r3, #0]
    second_countdown = CLOCK_SECOND;
 8003238:	f640 0318 	movw	r3, #2072	; 0x818
 800323c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003240:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8003244:	601a      	str	r2, [r3, #0]
  }	
}
 8003246:	bd80      	pop	{r7, pc}

08003248 <clock_time>:
/*---------------------------------------------------------------------------*/
clock_time_t
clock_time(void)
{
 8003248:	b480      	push	{r7}
 800324a:	af00      	add	r7, sp, #0
  return count;
 800324c:	f241 13ec 	movw	r3, #4588	; 0x11ec
 8003250:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003254:	681b      	ldr	r3, [r3, #0]
}
 8003256:	4618      	mov	r0, r3
 8003258:	46bd      	mov	sp, r7
 800325a:	bc80      	pop	{r7}
 800325c:	4770      	bx	lr
 800325e:	bf00      	nop

08003260 <clock_init>:
/*---------------------------------------------------------------------------*/
void
clock_init(void)
{
 8003260:	b580      	push	{r7, lr}
 8003262:	b084      	sub	sp, #16
 8003264:	af00      	add	r7, sp, #0
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;
	/* RCC TIM4 clock enable */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
 8003266:	2004      	movs	r0, #4
 8003268:	2101      	movs	r1, #1
 800326a:	f004 fac9 	bl	8007800 <RCC_APB1PeriphClockCmd>
	/* TIM4 config for 1ms*INTERVAL interrupts */
    TIM_TimeBaseInitStructure.TIM_Prescaler = 0;
 800326e:	2300      	movs	r3, #0
 8003270:	80bb      	strh	r3, [r7, #4]
    TIM_TimeBaseInitStructure.TIM_Period = (uint32_t)((42000000/1000));
 8003272:	f24a 4310 	movw	r3, #42000	; 0xa410
 8003276:	60bb      	str	r3, [r7, #8]
    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
 8003278:	2300      	movs	r3, #0
 800327a:	81bb      	strh	r3, [r7, #12]
    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
 800327c:	2300      	movs	r3, #0
 800327e:	80fb      	strh	r3, [r7, #6]
    TIM_TimeBaseInit(TIM4, &TIM_TimeBaseInitStructure);
 8003280:	1d3b      	adds	r3, r7, #4
 8003282:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8003286:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800328a:	4619      	mov	r1, r3
 800328c:	f004 fbf8 	bl	8007a80 <TIM_TimeBaseInit>
	TIM_Cmd(TIM4, ENABLE);
 8003290:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8003294:	f2c4 0000 	movt	r0, #16384	; 0x4000
 8003298:	2101      	movs	r1, #1
 800329a:	f004 fc67 	bl	8007b6c <TIM_Cmd>
	TIM_ITConfig(TIM4, TIM_IT_Update, ENABLE);	
 800329e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80032a2:	f2c4 0000 	movt	r0, #16384	; 0x4000
 80032a6:	2101      	movs	r1, #1
 80032a8:	2201      	movs	r2, #1
 80032aa:	f004 fc7f 	bl	8007bac <TIM_ITConfig>
	/* NVIC */
	NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;
 80032ae:	231e      	movs	r3, #30
 80032b0:	703b      	strb	r3, [r7, #0]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
 80032b2:	2301      	movs	r3, #1
 80032b4:	707b      	strb	r3, [r7, #1]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 80032b6:	2300      	movs	r3, #0
 80032b8:	70bb      	strb	r3, [r7, #2]
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 80032ba:	2301      	movs	r3, #1
 80032bc:	70fb      	strb	r3, [r7, #3]
    NVIC_Init(&NVIC_InitStructure);
 80032be:	463b      	mov	r3, r7
 80032c0:	4618      	mov	r0, r3
 80032c2:	f004 f93b 	bl	800753c <NVIC_Init>

	count = 0;
 80032c6:	f241 13ec 	movw	r3, #4588	; 0x11ec
 80032ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80032ce:	2200      	movs	r2, #0
 80032d0:	601a      	str	r2, [r3, #0]
}
 80032d2:	f107 0710 	add.w	r7, r7, #16
 80032d6:	46bd      	mov	sp, r7
 80032d8:	bd80      	pop	{r7, pc}
 80032da:	bf00      	nop

080032dc <clock_seconds>:

}
/*---------------------------------------------------------------------------*/
unsigned long
clock_seconds(void)
{
 80032dc:	b480      	push	{r7}
 80032de:	af00      	add	r7, sp, #0
  return current_seconds;
 80032e0:	f241 13f0 	movw	r3, #4592	; 0x11f0
 80032e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80032e8:	681b      	ldr	r3, [r3, #0]
}
 80032ea:	4618      	mov	r0, r3
 80032ec:	46bd      	mov	sp, r7
 80032ee:	bc80      	pop	{r7}
 80032f0:	4770      	bx	lr
 80032f2:	bf00      	nop

080032f4 <uart1_set_input>:
	return 0;
}
/*---------------------------------------------------------------------------*/
void
uart1_set_input(int (*input)(unsigned char c))
{
 80032f4:	b480      	push	{r7}
 80032f6:	b083      	sub	sp, #12
 80032f8:	af00      	add	r7, sp, #0
 80032fa:	6078      	str	r0, [r7, #4]
  uart1_input_handler = input;
 80032fc:	f241 13f4 	movw	r3, #4596	; 0x11f4
 8003300:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003304:	687a      	ldr	r2, [r7, #4]
 8003306:	601a      	str	r2, [r3, #0]
}
 8003308:	f107 070c 	add.w	r7, r7, #12
 800330c:	46bd      	mov	sp, r7
 800330e:	bc80      	pop	{r7}
 8003310:	4770      	bx	lr
 8003312:	bf00      	nop

08003314 <uart1_writeb>:
/*---------------------------------------------------------------------------*/
void
uart1_writeb(unsigned char c)
{
 8003314:	b580      	push	{r7, lr}
 8003316:	b082      	sub	sp, #8
 8003318:	af00      	add	r7, sp, #0
 800331a:	4603      	mov	r3, r0
 800331c:	71fb      	strb	r3, [r7, #7]
	USART_SendData(USART1,c);
 800331e:	79fb      	ldrb	r3, [r7, #7]
 8003320:	b29b      	uxth	r3, r3
 8003322:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8003326:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800332a:	4619      	mov	r1, r3
 800332c:	f004 fd56 	bl	8007ddc <USART_SendData>
	while(USART_GetFlagStatus(USART1, USART_FLAG_TXE)== RESET);
 8003330:	bf00      	nop
 8003332:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8003336:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800333a:	2180      	movs	r1, #128	; 0x80
 800333c:	f004 fdb8 	bl	8007eb0 <USART_GetFlagStatus>
 8003340:	4603      	mov	r3, r0
 8003342:	2b00      	cmp	r3, #0
 8003344:	d0f5      	beq.n	8003332 <uart1_writeb+0x1e>
}
 8003346:	f107 0708 	add.w	r7, r7, #8
 800334a:	46bd      	mov	sp, r7
 800334c:	bd80      	pop	{r7, pc}
 800334e:	bf00      	nop

08003350 <uart1_init>:
 * Initalize the RS232 port.
 *
 */
void
uart1_init(unsigned long ubr)
{
 8003350:	b580      	push	{r7, lr}
 8003352:	b08a      	sub	sp, #40	; 0x28
 8003354:	af00      	add	r7, sp, #0
 8003356:	6078      	str	r0, [r7, #4]
	USART_InitTypeDef USARTInitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;
//
//	RCC
//
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 8003358:	2002      	movs	r0, #2
 800335a:	2101      	movs	r1, #1
 800335c:	f004 fa28 	bl	80077b0 <RCC_AHB1PeriphClockCmd>
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);
 8003360:	2010      	movs	r0, #16
 8003362:	2101      	movs	r1, #1
 8003364:	f004 fa74 	bl	8007850 <RCC_APB2PeriphClockCmd>
//
// USART1 config
//
	// USART1 Pin config
	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF;
 8003368:	2302      	movs	r3, #2
 800336a:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6 | GPIO_Pin_7;
 800336e:	23c0      	movs	r3, #192	; 0xc0
 8003370:	623b      	str	r3, [r7, #32]
	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
 8003372:	2302      	movs	r3, #2
 8003374:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8003378:	2300      	movs	r3, #0
 800337a:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
 800337e:	2301      	movs	r3, #1
 8003380:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	GPIO_Init(GPIOB,&GPIO_InitStructure);
 8003384:	f107 0320 	add.w	r3, r7, #32
 8003388:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800338c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003390:	4619      	mov	r1, r3
 8003392:	f004 fa85 	bl	80078a0 <GPIO_Init>

  	GPIO_PinAFConfig(GPIOB,GPIO_PinSource6,GPIO_AF_USART1);
 8003396:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800339a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800339e:	2106      	movs	r1, #6
 80033a0:	2207      	movs	r2, #7
 80033a2:	f004 fb27 	bl	80079f4 <GPIO_PinAFConfig>
  	GPIO_PinAFConfig(GPIOB,GPIO_PinSource7,GPIO_AF_USART1);
 80033a6:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80033aa:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80033ae:	2107      	movs	r1, #7
 80033b0:	2207      	movs	r2, #7
 80033b2:	f004 fb1f 	bl	80079f4 <GPIO_PinAFConfig>

	USARTInitStructure.USART_BaudRate=115200;
 80033b6:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 80033ba:	613b      	str	r3, [r7, #16]
	USARTInitStructure.USART_HardwareFlowControl=USART_HardwareFlowControl_None;
 80033bc:	2300      	movs	r3, #0
 80033be:	83bb      	strh	r3, [r7, #28]
	USARTInitStructure.USART_Mode=USART_Mode_Tx|USART_Mode_Rx;
 80033c0:	230c      	movs	r3, #12
 80033c2:	837b      	strh	r3, [r7, #26]
	USARTInitStructure.USART_Parity=USART_Parity_No;
 80033c4:	2300      	movs	r3, #0
 80033c6:	833b      	strh	r3, [r7, #24]
	USARTInitStructure.USART_StopBits=USART_StopBits_1;
 80033c8:	2300      	movs	r3, #0
 80033ca:	82fb      	strh	r3, [r7, #22]
	USARTInitStructure.USART_WordLength=USART_WordLength_8b;
 80033cc:	2300      	movs	r3, #0
 80033ce:	82bb      	strh	r3, [r7, #20]
	USART_Init(USART1,&USARTInitStructure);
 80033d0:	f107 0310 	add.w	r3, r7, #16
 80033d4:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80033d8:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80033dc:	4619      	mov	r1, r3
 80033de:	f004 fc19 	bl	8007c14 <USART_Init>
	USART_Cmd(USART1, ENABLE);
 80033e2:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80033e6:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80033ea:	2101      	movs	r1, #1
 80033ec:	f004 fcd6 	bl	8007d9c <USART_Cmd>
	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
 80033f0:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80033f4:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80033f8:	f240 5125 	movw	r1, #1317	; 0x525
 80033fc:	2201      	movs	r2, #1
 80033fe:	f004 fd0f 	bl	8007e20 <USART_ITConfig>

//
//  NVIC config
//
	// USART1
	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
 8003402:	2325      	movs	r3, #37	; 0x25
 8003404:	733b      	strb	r3, [r7, #12]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 8003406:	2300      	movs	r3, #0
 8003408:	737b      	strb	r3, [r7, #13]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 800340a:	2300      	movs	r3, #0
 800340c:	73bb      	strb	r3, [r7, #14]
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800340e:	2301      	movs	r3, #1
 8003410:	73fb      	strb	r3, [r7, #15]
    NVIC_Init(&NVIC_InitStructure);
 8003412:	f107 030c 	add.w	r3, r7, #12
 8003416:	4618      	mov	r0, r3
 8003418:	f004 f890 	bl	800753c <NVIC_Init>
}
 800341c:	f107 0728 	add.w	r7, r7, #40	; 0x28
 8003420:	46bd      	mov	sp, r7
 8003422:	bd80      	pop	{r7, pc}

08003424 <USART1_IRQHandler>:


/*---------------------------------------------------------------------------*/
void USART1_IRQHandler(void)
{
 8003424:	b580      	push	{r7, lr}
 8003426:	b082      	sub	sp, #8
 8003428:	af00      	add	r7, sp, #0
	uint8_t c;

	if(USART_GetITStatus(USART1, USART_IT_RXNE))
 800342a:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800342e:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003432:	f240 5125 	movw	r1, #1317	; 0x525
 8003436:	f004 fd57 	bl	8007ee8 <USART_GetITStatus>
 800343a:	4603      	mov	r3, r0
 800343c:	2b00      	cmp	r3, #0
 800343e:	d01e      	beq.n	800347e <USART1_IRQHandler+0x5a>
	{
		//GPIO_SetBits(GPIOC, GPIO_Pin_9);
		USART_ClearITPendingBit(USART1,USART_IT_RXNE);
 8003440:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8003444:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003448:	f240 5125 	movw	r1, #1317	; 0x525
 800344c:	f004 fda4 	bl	8007f98 <USART_ClearITPendingBit>
		c=USART_ReceiveData(USART1);
 8003450:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8003454:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003458:	f004 fcd2 	bl	8007e00 <USART_ReceiveData>
 800345c:	4603      	mov	r3, r0
 800345e:	71fb      	strb	r3, [r7, #7]
		if(uart1_input_handler != NULL)
 8003460:	f241 13f4 	movw	r3, #4596	; 0x11f4
 8003464:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003468:	681b      	ldr	r3, [r3, #0]
 800346a:	2b00      	cmp	r3, #0
 800346c:	d007      	beq.n	800347e <USART1_IRQHandler+0x5a>
		{
			//		if(c == 0x0D)
			//		{
			//			c = 0x0A;
			//		}
			uart1_input_handler(c);
 800346e:	f241 13f4 	movw	r3, #4596	; 0x11f4
 8003472:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003476:	681b      	ldr	r3, [r3, #0]
 8003478:	79fa      	ldrb	r2, [r7, #7]
 800347a:	4610      	mov	r0, r2
 800347c:	4798      	blx	r3
		}
		//GPIO_ResetBits(GPIOC, GPIO_Pin_9);
	}
	if(USART_GetITStatus(USART1, USART_IT_ORE|USART_IT_IDLE))
 800347e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8003482:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003486:	f240 7164 	movw	r1, #1892	; 0x764
 800348a:	f004 fd2d 	bl	8007ee8 <USART_GetITStatus>
 800348e:	4603      	mov	r3, r0
 8003490:	2b00      	cmp	r3, #0
 8003492:	d007      	beq.n	80034a4 <USART1_IRQHandler+0x80>
	{
		//GPIO_SetBits(GPIOC, GPIO_Pin_8);
		USART_ClearITPendingBit(USART1,USART_IT_ORE|USART_IT_IDLE);
 8003494:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8003498:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800349c:	f240 7164 	movw	r1, #1892	; 0x764
 80034a0:	f004 fd7a 	bl	8007f98 <USART_ClearITPendingBit>
		//GPIO_ResetBits(GPIOC, GPIO_Pin_8);
	}
}
 80034a4:	f107 0708 	add.w	r7, r7, #8
 80034a8:	46bd      	mov	sp, r7
 80034aa:	bd80      	pop	{r7, pc}

080034ac <slip_arch_init>:
#include "dev/slip.h"
#include "dev/uart1.h"

void
slip_arch_init(unsigned long ubr)
{
 80034ac:	b580      	push	{r7, lr}
 80034ae:	b082      	sub	sp, #8
 80034b0:	af00      	add	r7, sp, #0
 80034b2:	6078      	str	r0, [r7, #4]
  uart1_set_input(slip_input_byte);
 80034b4:	f643 305d 	movw	r0, #15197	; 0x3b5d
 80034b8:	f6c0 0000 	movt	r0, #2048	; 0x800
 80034bc:	f7ff ff1a 	bl	80032f4 <uart1_set_input>
}
 80034c0:	f107 0708 	add.w	r7, r7, #8
 80034c4:	46bd      	mov	sp, r7
 80034c6:	bd80      	pop	{r7, pc}

080034c8 <slip_arch_writeb>:

void
slip_arch_writeb(unsigned char c)
{
 80034c8:	b580      	push	{r7, lr}
 80034ca:	b082      	sub	sp, #8
 80034cc:	af00      	add	r7, sp, #0
 80034ce:	4603      	mov	r3, r0
 80034d0:	71fb      	strb	r3, [r7, #7]
  uart1_writeb(c);
 80034d2:	79fb      	ldrb	r3, [r7, #7]
 80034d4:	4618      	mov	r0, r3
 80034d6:	f7ff ff1d 	bl	8003314 <uart1_writeb>
}
 80034da:	f107 0708 	add.w	r7, r7, #8
 80034de:	46bd      	mov	sp, r7
 80034e0:	bd80      	pop	{r7, pc}
 80034e2:	bf00      	nop

080034e4 <show_leds>:

static unsigned char leds, invert;
/*---------------------------------------------------------------------------*/
static void
show_leds(unsigned char changed)
{
 80034e4:	b580      	push	{r7, lr}
 80034e6:	b082      	sub	sp, #8
 80034e8:	af00      	add	r7, sp, #0
 80034ea:	4603      	mov	r3, r0
 80034ec:	71fb      	strb	r3, [r7, #7]
  if(changed & LEDS_GREEN) {
 80034ee:	79fb      	ldrb	r3, [r7, #7]
 80034f0:	f003 0301 	and.w	r3, r3, #1
 80034f4:	2b00      	cmp	r3, #0
      ENERGEST_ON(ENERGEST_TYPE_LED_GREEN);
    } else {
      ENERGEST_OFF(ENERGEST_TYPE_LED_GREEN);
    }
  }
  if(changed & LEDS_YELLOW) {
 80034f6:	79fb      	ldrb	r3, [r7, #7]
 80034f8:	f003 0302 	and.w	r3, r3, #2
 80034fc:	2b00      	cmp	r3, #0
      ENERGEST_ON(ENERGEST_TYPE_LED_YELLOW);
    } else {
      ENERGEST_OFF(ENERGEST_TYPE_LED_YELLOW);
    }
  }
  if(changed & LEDS_RED) {
 80034fe:	79fb      	ldrb	r3, [r7, #7]
 8003500:	f003 0304 	and.w	r3, r3, #4
 8003504:	2b00      	cmp	r3, #0
      ENERGEST_ON(ENERGEST_TYPE_LED_RED);
    } else {
      ENERGEST_OFF(ENERGEST_TYPE_LED_RED);
    }
  }
  leds_arch_set(leds ^ invert);
 8003506:	f241 13f8 	movw	r3, #4600	; 0x11f8
 800350a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800350e:	781a      	ldrb	r2, [r3, #0]
 8003510:	f241 13f9 	movw	r3, #4601	; 0x11f9
 8003514:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003518:	781b      	ldrb	r3, [r3, #0]
 800351a:	4053      	eors	r3, r2
 800351c:	b2db      	uxtb	r3, r3
 800351e:	4618      	mov	r0, r3
 8003520:	f004 fd90 	bl	8008044 <leds_arch_set>
}
 8003524:	f107 0708 	add.w	r7, r7, #8
 8003528:	46bd      	mov	sp, r7
 800352a:	bd80      	pop	{r7, pc}

0800352c <leds_init>:
/*---------------------------------------------------------------------------*/
void
leds_init(void)
{
 800352c:	b580      	push	{r7, lr}
 800352e:	af00      	add	r7, sp, #0
  leds_arch_init();
 8003530:	f004 fd4e 	bl	8007fd0 <leds_arch_init>
  leds = invert = 0;
 8003534:	f241 13f9 	movw	r3, #4601	; 0x11f9
 8003538:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800353c:	2200      	movs	r2, #0
 800353e:	701a      	strb	r2, [r3, #0]
 8003540:	f241 13f9 	movw	r3, #4601	; 0x11f9
 8003544:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003548:	781a      	ldrb	r2, [r3, #0]
 800354a:	f241 13f8 	movw	r3, #4600	; 0x11f8
 800354e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003552:	701a      	strb	r2, [r3, #0]
}
 8003554:	bd80      	pop	{r7, pc}
 8003556:	bf00      	nop

08003558 <leds_toggle>:
  show_leds(changed);
}
/*---------------------------------------------------------------------------*/
void
leds_toggle(unsigned char ledv)
{
 8003558:	b580      	push	{r7, lr}
 800355a:	b082      	sub	sp, #8
 800355c:	af00      	add	r7, sp, #0
 800355e:	4603      	mov	r3, r0
 8003560:	71fb      	strb	r3, [r7, #7]
  leds_invert(ledv);
 8003562:	79fb      	ldrb	r3, [r7, #7]
 8003564:	4618      	mov	r0, r3
 8003566:	f000 f805 	bl	8003574 <leds_invert>
}
 800356a:	f107 0708 	add.w	r7, r7, #8
 800356e:	46bd      	mov	sp, r7
 8003570:	bd80      	pop	{r7, pc}
 8003572:	bf00      	nop

08003574 <leds_invert>:
/*---------------------------------------------------------------------------*/
/*   invert the invert register using the leds parameter */
void
leds_invert(unsigned char ledv) {
 8003574:	b580      	push	{r7, lr}
 8003576:	b082      	sub	sp, #8
 8003578:	af00      	add	r7, sp, #0
 800357a:	4603      	mov	r3, r0
 800357c:	71fb      	strb	r3, [r7, #7]
  invert = invert ^ ledv;
 800357e:	f241 13f9 	movw	r3, #4601	; 0x11f9
 8003582:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003586:	781a      	ldrb	r2, [r3, #0]
 8003588:	79fb      	ldrb	r3, [r7, #7]
 800358a:	4053      	eors	r3, r2
 800358c:	b2da      	uxtb	r2, r3
 800358e:	f241 13f9 	movw	r3, #4601	; 0x11f9
 8003592:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003596:	701a      	strb	r2, [r3, #0]
  show_leds(ledv);
 8003598:	79fb      	ldrb	r3, [r7, #7]
 800359a:	4618      	mov	r0, r3
 800359c:	f7ff ffa2 	bl	80034e4 <show_leds>
}
 80035a0:	f107 0708 	add.w	r7, r7, #8
 80035a4:	46bd      	mov	sp, r7
 80035a6:	bd80      	pop	{r7, pc}

080035a8 <slip_send>:
 * was used in slip-bridge.c
 */
//#if WITH_UIP
uint8_t
slip_send(void)
{
 80035a8:	b580      	push	{r7, lr}
 80035aa:	b084      	sub	sp, #16
 80035ac:	af00      	add	r7, sp, #0
  uint16_t i;
  uint8_t *ptr;
  uint8_t c;

  slip_arch_writeb(SLIP_END);
 80035ae:	20c0      	movs	r0, #192	; 0xc0
 80035b0:	f7ff ff8a 	bl	80034c8 <slip_arch_writeb>

  ptr = &uip_buf[UIP_LLH_LEN];
 80035b4:	f241 7318 	movw	r3, #5912	; 0x1718
 80035b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80035bc:	60bb      	str	r3, [r7, #8]
  for(i = 0; i < uip_len; ++i) {
 80035be:	2300      	movs	r3, #0
 80035c0:	81fb      	strh	r3, [r7, #14]
 80035c2:	e026      	b.n	8003612 <slip_send+0x6a>
    if(i == UIP_TCPIP_HLEN) {
 80035c4:	89fb      	ldrh	r3, [r7, #14]
 80035c6:	2b28      	cmp	r3, #40	; 0x28
 80035c8:	d105      	bne.n	80035d6 <slip_send+0x2e>
      ptr = (uint8_t *)uip_appdata;
 80035ca:	f641 03c4 	movw	r3, #6340	; 0x18c4
 80035ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80035d2:	681b      	ldr	r3, [r3, #0]
 80035d4:	60bb      	str	r3, [r7, #8]
    }
    c = *ptr++;
 80035d6:	68bb      	ldr	r3, [r7, #8]
 80035d8:	781b      	ldrb	r3, [r3, #0]
 80035da:	71fb      	strb	r3, [r7, #7]
 80035dc:	68bb      	ldr	r3, [r7, #8]
 80035de:	3301      	adds	r3, #1
 80035e0:	60bb      	str	r3, [r7, #8]
    if(c == SLIP_END) {
 80035e2:	79fb      	ldrb	r3, [r7, #7]
 80035e4:	2bc0      	cmp	r3, #192	; 0xc0
 80035e6:	d105      	bne.n	80035f4 <slip_send+0x4c>
      slip_arch_writeb(SLIP_ESC);
 80035e8:	20db      	movs	r0, #219	; 0xdb
 80035ea:	f7ff ff6d 	bl	80034c8 <slip_arch_writeb>
      c = SLIP_ESC_END;
 80035ee:	23dc      	movs	r3, #220	; 0xdc
 80035f0:	71fb      	strb	r3, [r7, #7]
 80035f2:	e007      	b.n	8003604 <slip_send+0x5c>
    } else if(c == SLIP_ESC) {
 80035f4:	79fb      	ldrb	r3, [r7, #7]
 80035f6:	2bdb      	cmp	r3, #219	; 0xdb
 80035f8:	d104      	bne.n	8003604 <slip_send+0x5c>
      slip_arch_writeb(SLIP_ESC);
 80035fa:	20db      	movs	r0, #219	; 0xdb
 80035fc:	f7ff ff64 	bl	80034c8 <slip_arch_writeb>
      c = SLIP_ESC_ESC;
 8003600:	23dd      	movs	r3, #221	; 0xdd
 8003602:	71fb      	strb	r3, [r7, #7]
    }
    slip_arch_writeb(c);
 8003604:	79fb      	ldrb	r3, [r7, #7]
 8003606:	4618      	mov	r0, r3
 8003608:	f7ff ff5e 	bl	80034c8 <slip_arch_writeb>
  uint8_t c;

  slip_arch_writeb(SLIP_END);

  ptr = &uip_buf[UIP_LLH_LEN];
  for(i = 0; i < uip_len; ++i) {
 800360c:	89fb      	ldrh	r3, [r7, #14]
 800360e:	3301      	adds	r3, #1
 8003610:	81fb      	strh	r3, [r7, #14]
 8003612:	f241 730c 	movw	r3, #5900	; 0x170c
 8003616:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800361a:	881b      	ldrh	r3, [r3, #0]
 800361c:	89fa      	ldrh	r2, [r7, #14]
 800361e:	429a      	cmp	r2, r3
 8003620:	d3d0      	bcc.n	80035c4 <slip_send+0x1c>
      slip_arch_writeb(SLIP_ESC);
      c = SLIP_ESC_ESC;
    }
    slip_arch_writeb(c);
  }
  slip_arch_writeb(SLIP_END);
 8003622:	20c0      	movs	r0, #192	; 0xc0
 8003624:	f7ff ff50 	bl	80034c8 <slip_arch_writeb>

  return UIP_FW_OK;
 8003628:	2300      	movs	r3, #0
}
 800362a:	4618      	mov	r0, r3
 800362c:	f107 0710 	add.w	r7, r7, #16
 8003630:	46bd      	mov	sp, r7
 8003632:	bd80      	pop	{r7, pc}

08003634 <slip_write>:
//#endif /* WITH_UIP */
/*---------------------------------------------------------------------------*/
uint8_t
slip_write(const void *_ptr, int len)
{
 8003634:	b580      	push	{r7, lr}
 8003636:	b084      	sub	sp, #16
 8003638:	af00      	add	r7, sp, #0
 800363a:	6078      	str	r0, [r7, #4]
 800363c:	6039      	str	r1, [r7, #0]
  const uint8_t *ptr = _ptr;
 800363e:	687b      	ldr	r3, [r7, #4]
 8003640:	60fb      	str	r3, [r7, #12]
  uint16_t i;
  uint8_t c;

  slip_arch_writeb(SLIP_END);
 8003642:	20c0      	movs	r0, #192	; 0xc0
 8003644:	f7ff ff40 	bl	80034c8 <slip_arch_writeb>

  for(i = 0; i < len; ++i) {
 8003648:	2300      	movs	r3, #0
 800364a:	817b      	strh	r3, [r7, #10]
 800364c:	e01d      	b.n	800368a <slip_write+0x56>
    c = *ptr++;
 800364e:	68fb      	ldr	r3, [r7, #12]
 8003650:	781b      	ldrb	r3, [r3, #0]
 8003652:	727b      	strb	r3, [r7, #9]
 8003654:	68fb      	ldr	r3, [r7, #12]
 8003656:	3301      	adds	r3, #1
 8003658:	60fb      	str	r3, [r7, #12]
    if(c == SLIP_END) {
 800365a:	7a7b      	ldrb	r3, [r7, #9]
 800365c:	2bc0      	cmp	r3, #192	; 0xc0
 800365e:	d105      	bne.n	800366c <slip_write+0x38>
      slip_arch_writeb(SLIP_ESC);
 8003660:	20db      	movs	r0, #219	; 0xdb
 8003662:	f7ff ff31 	bl	80034c8 <slip_arch_writeb>
      c = SLIP_ESC_END;
 8003666:	23dc      	movs	r3, #220	; 0xdc
 8003668:	727b      	strb	r3, [r7, #9]
 800366a:	e007      	b.n	800367c <slip_write+0x48>
    } else if(c == SLIP_ESC) {
 800366c:	7a7b      	ldrb	r3, [r7, #9]
 800366e:	2bdb      	cmp	r3, #219	; 0xdb
 8003670:	d104      	bne.n	800367c <slip_write+0x48>
      slip_arch_writeb(SLIP_ESC);
 8003672:	20db      	movs	r0, #219	; 0xdb
 8003674:	f7ff ff28 	bl	80034c8 <slip_arch_writeb>
      c = SLIP_ESC_ESC;
 8003678:	23dd      	movs	r3, #221	; 0xdd
 800367a:	727b      	strb	r3, [r7, #9]
    }
    slip_arch_writeb(c);
 800367c:	7a7b      	ldrb	r3, [r7, #9]
 800367e:	4618      	mov	r0, r3
 8003680:	f7ff ff22 	bl	80034c8 <slip_arch_writeb>
  uint16_t i;
  uint8_t c;

  slip_arch_writeb(SLIP_END);

  for(i = 0; i < len; ++i) {
 8003684:	897b      	ldrh	r3, [r7, #10]
 8003686:	3301      	adds	r3, #1
 8003688:	817b      	strh	r3, [r7, #10]
 800368a:	897a      	ldrh	r2, [r7, #10]
 800368c:	683b      	ldr	r3, [r7, #0]
 800368e:	429a      	cmp	r2, r3
 8003690:	dbdd      	blt.n	800364e <slip_write+0x1a>
      slip_arch_writeb(SLIP_ESC);
      c = SLIP_ESC_ESC;
    }
    slip_arch_writeb(c);
  }
  slip_arch_writeb(SLIP_END);
 8003692:	20c0      	movs	r0, #192	; 0xc0
 8003694:	f7ff ff18 	bl	80034c8 <slip_arch_writeb>

  return len;
 8003698:	683b      	ldr	r3, [r7, #0]
 800369a:	b2db      	uxtb	r3, r3
}
 800369c:	4618      	mov	r0, r3
 800369e:	f107 0710 	add.w	r7, r7, #16
 80036a2:	46bd      	mov	sp, r7
 80036a4:	bd80      	pop	{r7, pc}
 80036a6:	bf00      	nop

080036a8 <rxbuf_init>:
/*---------------------------------------------------------------------------*/
static void
rxbuf_init(void)
{
 80036a8:	b480      	push	{r7}
 80036aa:	af00      	add	r7, sp, #0
  begin = end = pkt_end = 0;
 80036ac:	f241 33b4 	movw	r3, #5044	; 0x13b4
 80036b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80036b4:	2200      	movs	r2, #0
 80036b6:	801a      	strh	r2, [r3, #0]
 80036b8:	f241 33b4 	movw	r3, #5044	; 0x13b4
 80036bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80036c0:	881a      	ldrh	r2, [r3, #0]
 80036c2:	f241 13fe 	movw	r3, #4606	; 0x11fe
 80036c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80036ca:	801a      	strh	r2, [r3, #0]
 80036cc:	f241 13fe 	movw	r3, #4606	; 0x11fe
 80036d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80036d4:	881a      	ldrh	r2, [r3, #0]
 80036d6:	f241 13fc 	movw	r3, #4604	; 0x11fc
 80036da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80036de:	801a      	strh	r2, [r3, #0]
  state = STATE_OK;
 80036e0:	f241 13fa 	movw	r3, #4602	; 0x11fa
 80036e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80036e8:	2201      	movs	r2, #1
 80036ea:	701a      	strb	r2, [r3, #0]
}
 80036ec:	46bd      	mov	sp, r7
 80036ee:	bc80      	pop	{r7}
 80036f0:	4770      	bx	lr
 80036f2:	bf00      	nop

080036f4 <slip_poll_handler>:
/*---------------------------------------------------------------------------*/
/* Upper half does the polling. */
static uint16_t
slip_poll_handler(uint8_t *outbuf, uint16_t blen)
{
 80036f4:	b580      	push	{r7, lr}
 80036f6:	b086      	sub	sp, #24
 80036f8:	af00      	add	r7, sp, #0
 80036fa:	6078      	str	r0, [r7, #4]
 80036fc:	460b      	mov	r3, r1
 80036fe:	807b      	strh	r3, [r7, #2]
  /* This is a hack and won't work across buffer edge! */
  if(rxbuf[begin] == 'C') {
 8003700:	f241 13fc 	movw	r3, #4604	; 0x11fc
 8003704:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003708:	881b      	ldrh	r3, [r3, #0]
 800370a:	461a      	mov	r2, r3
 800370c:	f241 2300 	movw	r3, #4608	; 0x1200
 8003710:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003714:	5c9b      	ldrb	r3, [r3, r2]
 8003716:	2b43      	cmp	r3, #67	; 0x43
 8003718:	d15c      	bne.n	80037d4 <slip_poll_handler+0xe0>
    int i;
    if(begin < end && (end - begin) >= 6
 800371a:	f241 13fc 	movw	r3, #4604	; 0x11fc
 800371e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003722:	881a      	ldrh	r2, [r3, #0]
 8003724:	f241 13fe 	movw	r3, #4606	; 0x11fe
 8003728:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800372c:	881b      	ldrh	r3, [r3, #0]
 800372e:	429a      	cmp	r2, r3
 8003730:	d250      	bcs.n	80037d4 <slip_poll_handler+0xe0>
 8003732:	f241 13fe 	movw	r3, #4606	; 0x11fe
 8003736:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800373a:	881b      	ldrh	r3, [r3, #0]
 800373c:	461a      	mov	r2, r3
 800373e:	f241 13fc 	movw	r3, #4604	; 0x11fc
 8003742:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003746:	881b      	ldrh	r3, [r3, #0]
 8003748:	1ad3      	subs	r3, r2, r3
 800374a:	2b05      	cmp	r3, #5
 800374c:	dd42      	ble.n	80037d4 <slip_poll_handler+0xe0>
       && memcmp(&rxbuf[begin], "CLIENT", 6) == 0) {
 800374e:	f241 13fc 	movw	r3, #4604	; 0x11fc
 8003752:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003756:	881b      	ldrh	r3, [r3, #0]
 8003758:	461a      	mov	r2, r3
 800375a:	f241 2300 	movw	r3, #4608	; 0x1200
 800375e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003762:	18d3      	adds	r3, r2, r3
 8003764:	4618      	mov	r0, r3
 8003766:	f648 712c 	movw	r1, #36652	; 0x8f2c
 800376a:	f6c0 0100 	movt	r1, #2048	; 0x800
 800376e:	2206      	movs	r2, #6
 8003770:	f7fc fd93 	bl	800029a <memcmp>
 8003774:	4603      	mov	r3, r0
 8003776:	2b00      	cmp	r3, #0
 8003778:	d12c      	bne.n	80037d4 <slip_poll_handler+0xe0>
      state = STATE_TWOPACKETS;	/* Interrupts do nothing. */
 800377a:	f241 13fa 	movw	r3, #4602	; 0x11fa
 800377e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003782:	2200      	movs	r2, #0
 8003784:	701a      	strb	r2, [r3, #0]
      memset(&rxbuf[begin], 0x0, 6);
 8003786:	f241 13fc 	movw	r3, #4604	; 0x11fc
 800378a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800378e:	881b      	ldrh	r3, [r3, #0]
 8003790:	461a      	mov	r2, r3
 8003792:	f241 2300 	movw	r3, #4608	; 0x1200
 8003796:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800379a:	18d3      	adds	r3, r2, r3
 800379c:	4618      	mov	r0, r3
 800379e:	2100      	movs	r1, #0
 80037a0:	2206      	movs	r2, #6
 80037a2:	f7fc fd93 	bl	80002cc <memset>
      
      rxbuf_init();
 80037a6:	f7ff ff7f 	bl	80036a8 <rxbuf_init>
      
      for(i = 0; i < 13; i++) {
 80037aa:	2300      	movs	r3, #0
 80037ac:	617b      	str	r3, [r7, #20]
 80037ae:	e00c      	b.n	80037ca <slip_poll_handler+0xd6>
	slip_arch_writeb("CLIENTSERVER\300"[i]);
 80037b0:	f648 7334 	movw	r3, #36660	; 0x8f34
 80037b4:	f6c0 0300 	movt	r3, #2048	; 0x800
 80037b8:	697a      	ldr	r2, [r7, #20]
 80037ba:	189b      	adds	r3, r3, r2
 80037bc:	781b      	ldrb	r3, [r3, #0]
 80037be:	4618      	mov	r0, r3
 80037c0:	f7ff fe82 	bl	80034c8 <slip_arch_writeb>
      state = STATE_TWOPACKETS;	/* Interrupts do nothing. */
      memset(&rxbuf[begin], 0x0, 6);
      
      rxbuf_init();
      
      for(i = 0; i < 13; i++) {
 80037c4:	697b      	ldr	r3, [r7, #20]
 80037c6:	3301      	adds	r3, #1
 80037c8:	617b      	str	r3, [r7, #20]
 80037ca:	697b      	ldr	r3, [r7, #20]
 80037cc:	2b0c      	cmp	r3, #12
 80037ce:	ddef      	ble.n	80037b0 <slip_poll_handler+0xbc>
	slip_arch_writeb("CLIENTSERVER\300"[i]);
      }
      return 0;
 80037d0:	2300      	movs	r3, #0
 80037d2:	e0b3      	b.n	800393c <slip_poll_handler+0x248>

  /*
   * Interrupt can not change begin but may change pkt_end.
   * If pkt_end != begin it will not change again.
   */
  if(begin != pkt_end) {
 80037d4:	f241 13fc 	movw	r3, #4604	; 0x11fc
 80037d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80037dc:	881a      	ldrh	r2, [r3, #0]
 80037de:	f241 33b4 	movw	r3, #5044	; 0x13b4
 80037e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80037e6:	881b      	ldrh	r3, [r3, #0]
 80037e8:	429a      	cmp	r2, r3
 80037ea:	f000 80a6 	beq.w	800393a <slip_poll_handler+0x246>
    uint16_t len;

    if(begin < pkt_end) {
 80037ee:	f241 13fc 	movw	r3, #4604	; 0x11fc
 80037f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80037f6:	881a      	ldrh	r2, [r3, #0]
 80037f8:	f241 33b4 	movw	r3, #5044	; 0x13b4
 80037fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003800:	881b      	ldrh	r3, [r3, #0]
 8003802:	429a      	cmp	r2, r3
 8003804:	d224      	bcs.n	8003850 <slip_poll_handler+0x15c>
      len = pkt_end - begin;
 8003806:	f241 33b4 	movw	r3, #5044	; 0x13b4
 800380a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800380e:	881a      	ldrh	r2, [r3, #0]
 8003810:	f241 13fc 	movw	r3, #4604	; 0x11fc
 8003814:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003818:	881b      	ldrh	r3, [r3, #0]
 800381a:	1ad3      	subs	r3, r2, r3
 800381c:	827b      	strh	r3, [r7, #18]
      if(len > blen) {
 800381e:	8a7a      	ldrh	r2, [r7, #18]
 8003820:	887b      	ldrh	r3, [r7, #2]
 8003822:	429a      	cmp	r2, r3
 8003824:	d902      	bls.n	800382c <slip_poll_handler+0x138>
	len = 0;
 8003826:	2300      	movs	r3, #0
 8003828:	827b      	strh	r3, [r7, #18]
 800382a:	e05d      	b.n	80038e8 <slip_poll_handler+0x1f4>
      } else {
	memcpy(outbuf, &rxbuf[begin], len);
 800382c:	f241 13fc 	movw	r3, #4604	; 0x11fc
 8003830:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003834:	881b      	ldrh	r3, [r3, #0]
 8003836:	461a      	mov	r2, r3
 8003838:	f241 2300 	movw	r3, #4608	; 0x1200
 800383c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003840:	18d2      	adds	r2, r2, r3
 8003842:	8a7b      	ldrh	r3, [r7, #18]
 8003844:	6878      	ldr	r0, [r7, #4]
 8003846:	4611      	mov	r1, r2
 8003848:	461a      	mov	r2, r3
 800384a:	f7fc fd36 	bl	80002ba <memcpy>
 800384e:	e04b      	b.n	80038e8 <slip_poll_handler+0x1f4>
      }
    } else {
      len = (RX_BUFSIZE - begin) + (pkt_end - 0);
 8003850:	f241 33b4 	movw	r3, #5044	; 0x13b4
 8003854:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003858:	881a      	ldrh	r2, [r3, #0]
 800385a:	f241 13fc 	movw	r3, #4604	; 0x11fc
 800385e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003862:	881b      	ldrh	r3, [r3, #0]
 8003864:	1ad3      	subs	r3, r2, r3
 8003866:	b29b      	uxth	r3, r3
 8003868:	f503 73da 	add.w	r3, r3, #436	; 0x1b4
 800386c:	827b      	strh	r3, [r7, #18]
      if(len > blen) {
 800386e:	8a7a      	ldrh	r2, [r7, #18]
 8003870:	887b      	ldrh	r3, [r7, #2]
 8003872:	429a      	cmp	r2, r3
 8003874:	d902      	bls.n	800387c <slip_poll_handler+0x188>
	len = 0;
 8003876:	2300      	movs	r3, #0
 8003878:	827b      	strh	r3, [r7, #18]
 800387a:	e035      	b.n	80038e8 <slip_poll_handler+0x1f4>
      } else {
	unsigned i;
	for(i = begin; i < RX_BUFSIZE; i++) {
 800387c:	f241 13fc 	movw	r3, #4604	; 0x11fc
 8003880:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003884:	881b      	ldrh	r3, [r3, #0]
 8003886:	60fb      	str	r3, [r7, #12]
 8003888:	e00e      	b.n	80038a8 <slip_poll_handler+0x1b4>
	  *outbuf++ = rxbuf[i];
 800388a:	f241 2300 	movw	r3, #4608	; 0x1200
 800388e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003892:	68fa      	ldr	r2, [r7, #12]
 8003894:	189b      	adds	r3, r3, r2
 8003896:	781a      	ldrb	r2, [r3, #0]
 8003898:	687b      	ldr	r3, [r7, #4]
 800389a:	701a      	strb	r2, [r3, #0]
 800389c:	687b      	ldr	r3, [r7, #4]
 800389e:	3301      	adds	r3, #1
 80038a0:	607b      	str	r3, [r7, #4]
      len = (RX_BUFSIZE - begin) + (pkt_end - 0);
      if(len > blen) {
	len = 0;
      } else {
	unsigned i;
	for(i = begin; i < RX_BUFSIZE; i++) {
 80038a2:	68fb      	ldr	r3, [r7, #12]
 80038a4:	3301      	adds	r3, #1
 80038a6:	60fb      	str	r3, [r7, #12]
 80038a8:	68fa      	ldr	r2, [r7, #12]
 80038aa:	f240 13b3 	movw	r3, #435	; 0x1b3
 80038ae:	429a      	cmp	r2, r3
 80038b0:	d9eb      	bls.n	800388a <slip_poll_handler+0x196>
	  *outbuf++ = rxbuf[i];
	}
	for(i = 0; i < pkt_end; i++) {
 80038b2:	2300      	movs	r3, #0
 80038b4:	60fb      	str	r3, [r7, #12]
 80038b6:	e00e      	b.n	80038d6 <slip_poll_handler+0x1e2>
	  *outbuf++ = rxbuf[i];
 80038b8:	f241 2300 	movw	r3, #4608	; 0x1200
 80038bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80038c0:	68fa      	ldr	r2, [r7, #12]
 80038c2:	189b      	adds	r3, r3, r2
 80038c4:	781a      	ldrb	r2, [r3, #0]
 80038c6:	687b      	ldr	r3, [r7, #4]
 80038c8:	701a      	strb	r2, [r3, #0]
 80038ca:	687b      	ldr	r3, [r7, #4]
 80038cc:	3301      	adds	r3, #1
 80038ce:	607b      	str	r3, [r7, #4]
      } else {
	unsigned i;
	for(i = begin; i < RX_BUFSIZE; i++) {
	  *outbuf++ = rxbuf[i];
	}
	for(i = 0; i < pkt_end; i++) {
 80038d0:	68fb      	ldr	r3, [r7, #12]
 80038d2:	3301      	adds	r3, #1
 80038d4:	60fb      	str	r3, [r7, #12]
 80038d6:	f241 33b4 	movw	r3, #5044	; 0x13b4
 80038da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80038de:	881b      	ldrh	r3, [r3, #0]
 80038e0:	461a      	mov	r2, r3
 80038e2:	68fb      	ldr	r3, [r7, #12]
 80038e4:	429a      	cmp	r2, r3
 80038e6:	d8e7      	bhi.n	80038b8 <slip_poll_handler+0x1c4>
	}
      }
    }

    /* Remove data from buffer together with the copied packet. */
    begin = pkt_end;
 80038e8:	f241 33b4 	movw	r3, #5044	; 0x13b4
 80038ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80038f0:	881a      	ldrh	r2, [r3, #0]
 80038f2:	f241 13fc 	movw	r3, #4604	; 0x11fc
 80038f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80038fa:	801a      	strh	r2, [r3, #0]
    if(state == STATE_TWOPACKETS) {
 80038fc:	f241 13fa 	movw	r3, #4602	; 0x11fa
 8003900:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003904:	781b      	ldrb	r3, [r3, #0]
 8003906:	2b00      	cmp	r3, #0
 8003908:	d115      	bne.n	8003936 <slip_poll_handler+0x242>
      pkt_end = end;
 800390a:	f241 13fe 	movw	r3, #4606	; 0x11fe
 800390e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003912:	881a      	ldrh	r2, [r3, #0]
 8003914:	f241 33b4 	movw	r3, #5044	; 0x13b4
 8003918:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800391c:	801a      	strh	r2, [r3, #0]
      state = STATE_OK;		/* Assume no bytes where lost! */
 800391e:	f241 13fa 	movw	r3, #4602	; 0x11fa
 8003922:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003926:	2201      	movs	r2, #1
 8003928:	701a      	strb	r2, [r3, #0]
      
      /* One more packet is buffered, need to be polled again! */
      process_poll(&slip_process);
 800392a:	f640 001c 	movw	r0, #2076	; 0x81c
 800392e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003932:	f000 fcdb 	bl	80042ec <process_poll>
    }
    return len;
 8003936:	8a7b      	ldrh	r3, [r7, #18]
 8003938:	e000      	b.n	800393c <slip_poll_handler+0x248>
  }

  return 0;
 800393a:	2300      	movs	r3, #0
}
 800393c:	4618      	mov	r0, r3
 800393e:	f107 0718 	add.w	r7, r7, #24
 8003942:	46bd      	mov	sp, r7
 8003944:	bd80      	pop	{r7, pc}
 8003946:	bf00      	nop

08003948 <process_thread_slip_process>:
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(slip_process, ev, data)
{
 8003948:	b580      	push	{r7, lr}
 800394a:	b088      	sub	sp, #32
 800394c:	af00      	add	r7, sp, #0
 800394e:	60f8      	str	r0, [r7, #12]
 8003950:	460b      	mov	r3, r1
 8003952:	607a      	str	r2, [r7, #4]
 8003954:	72fb      	strb	r3, [r7, #11]
  PROCESS_BEGIN();
 8003956:	2301      	movs	r3, #1
 8003958:	77fb      	strb	r3, [r7, #31]
 800395a:	68fb      	ldr	r3, [r7, #12]
 800395c:	881b      	ldrh	r3, [r3, #0]
 800395e:	2b00      	cmp	r3, #0
 8003960:	d004      	beq.n	800396c <process_thread_slip_process+0x24>
 8003962:	f240 1205 	movw	r2, #261	; 0x105
 8003966:	4293      	cmp	r3, r2
 8003968:	d008      	beq.n	800397c <process_thread_slip_process+0x34>
 800396a:	e0eb      	b.n	8003b44 <process_thread_slip_process+0x1fc>

  rxbuf_init();
 800396c:	f7ff fe9c 	bl	80036a8 <rxbuf_init>

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_POLL);
 8003970:	2300      	movs	r3, #0
 8003972:	77fb      	strb	r3, [r7, #31]
 8003974:	68fb      	ldr	r3, [r7, #12]
 8003976:	f240 1205 	movw	r2, #261	; 0x105
 800397a:	801a      	strh	r2, [r3, #0]
 800397c:	7ffb      	ldrb	r3, [r7, #31]
 800397e:	2b00      	cmp	r3, #0
 8003980:	d002      	beq.n	8003988 <process_thread_slip_process+0x40>
 8003982:	7afb      	ldrb	r3, [r7, #11]
 8003984:	2b82      	cmp	r3, #130	; 0x82
 8003986:	d001      	beq.n	800398c <process_thread_slip_process+0x44>
 8003988:	2301      	movs	r3, #1
 800398a:	e0e1      	b.n	8003b50 <process_thread_slip_process+0x208>
    
    slip_active = 1;
 800398c:	f241 7308 	movw	r3, #5896	; 0x1708
 8003990:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003994:	2201      	movs	r2, #1
 8003996:	701a      	strb	r2, [r3, #0]

    /* Move packet from rxbuf to buffer provided by uIP. */
    uip_len = slip_poll_handler(&uip_buf[UIP_LLH_LEN],
 8003998:	f241 7018 	movw	r0, #5912	; 0x1718
 800399c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80039a0:	f44f 71d2 	mov.w	r1, #420	; 0x1a4
 80039a4:	f7ff fea6 	bl	80036f4 <slip_poll_handler>
 80039a8:	4603      	mov	r3, r0
 80039aa:	461a      	mov	r2, r3
 80039ac:	f241 730c 	movw	r3, #5900	; 0x170c
 80039b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80039b4:	801a      	strh	r2, [r3, #0]
				UIP_BUFSIZE - UIP_LLH_LEN);
#if !UIP_CONF_IPV6
    if(uip_len == 4 && strncmp((char*)&uip_buf[UIP_LLH_LEN], "?IPA", 4) == 0) {
 80039b6:	f241 730c 	movw	r3, #5900	; 0x170c
 80039ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80039be:	881b      	ldrh	r3, [r3, #0]
 80039c0:	2b04      	cmp	r3, #4
 80039c2:	d136      	bne.n	8003a32 <process_thread_slip_process+0xea>
 80039c4:	f241 7018 	movw	r0, #5912	; 0x1718
 80039c8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80039cc:	f648 7144 	movw	r1, #36676	; 0x8f44
 80039d0:	f6c0 0100 	movt	r1, #2048	; 0x800
 80039d4:	2204      	movs	r2, #4
 80039d6:	f7fc fcc9 	bl	800036c <strncmp>
 80039da:	4603      	mov	r3, r0
 80039dc:	2b00      	cmp	r3, #0
 80039de:	d128      	bne.n	8003a32 <process_thread_slip_process+0xea>
      char buf[8];
      memcpy(&buf[0], "=IPA", 4);
 80039e0:	f107 0314 	add.w	r3, r7, #20
 80039e4:	4618      	mov	r0, r3
 80039e6:	f648 714c 	movw	r1, #36684	; 0x8f4c
 80039ea:	f6c0 0100 	movt	r1, #2048	; 0x800
 80039ee:	2204      	movs	r2, #4
 80039f0:	f7fc fc63 	bl	80002ba <memcpy>
      memcpy(&buf[4], &uip_hostaddr, 4);
 80039f4:	f107 0314 	add.w	r3, r7, #20
 80039f8:	3304      	adds	r3, #4
 80039fa:	4618      	mov	r0, r3
 80039fc:	f641 61c4 	movw	r1, #7876	; 0x1ec4
 8003a00:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8003a04:	2204      	movs	r2, #4
 8003a06:	f7fc fc58 	bl	80002ba <memcpy>
      if(input_callback) {
 8003a0a:	f241 33b8 	movw	r3, #5048	; 0x13b8
 8003a0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003a12:	681b      	ldr	r3, [r3, #0]
 8003a14:	2b00      	cmp	r3, #0
 8003a16:	d005      	beq.n	8003a24 <process_thread_slip_process+0xdc>
	input_callback();
 8003a18:	f241 33b8 	movw	r3, #5048	; 0x13b8
 8003a1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003a20:	681b      	ldr	r3, [r3, #0]
 8003a22:	4798      	blx	r3
      }
      slip_write(buf, 8);
 8003a24:	f107 0314 	add.w	r3, r7, #20
 8003a28:	4618      	mov	r0, r3
 8003a2a:	2108      	movs	r1, #8
 8003a2c:	f7ff fe02 	bl	8003634 <slip_write>

    /* Move packet from rxbuf to buffer provided by uIP. */
    uip_len = slip_poll_handler(&uip_buf[UIP_LLH_LEN],
				UIP_BUFSIZE - UIP_LLH_LEN);
#if !UIP_CONF_IPV6
    if(uip_len == 4 && strncmp((char*)&uip_buf[UIP_LLH_LEN], "?IPA", 4) == 0) {
 8003a30:	e087      	b.n	8003b42 <process_thread_slip_process+0x1fa>
      memcpy(&buf[4], &uip_hostaddr, 4);
      if(input_callback) {
	input_callback();
      }
      slip_write(buf, 8);
    } else if(uip_len > 0
 8003a32:	f241 730c 	movw	r3, #5900	; 0x170c
 8003a36:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003a3a:	881b      	ldrh	r3, [r3, #0]
 8003a3c:	2b00      	cmp	r3, #0
 8003a3e:	d079      	beq.n	8003b34 <process_thread_slip_process+0x1ec>
       && uip_len == (((uint16_t)(BUF->len[0]) << 8) + BUF->len[1])
 8003a40:	f241 730c 	movw	r3, #5900	; 0x170c
 8003a44:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003a48:	881b      	ldrh	r3, [r3, #0]
 8003a4a:	461a      	mov	r2, r3
 8003a4c:	f241 7318 	movw	r3, #5912	; 0x1718
 8003a50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003a54:	789b      	ldrb	r3, [r3, #2]
 8003a56:	0219      	lsls	r1, r3, #8
 8003a58:	f241 7318 	movw	r3, #5912	; 0x1718
 8003a5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003a60:	78db      	ldrb	r3, [r3, #3]
 8003a62:	18cb      	adds	r3, r1, r3
 8003a64:	429a      	cmp	r2, r3
 8003a66:	d165      	bne.n	8003b34 <process_thread_slip_process+0x1ec>
       && uip_ipchksum() == 0xffff) {
 8003a68:	f001 f86c 	bl	8004b44 <uip_ipchksum>
 8003a6c:	4603      	mov	r3, r0
 8003a6e:	461a      	mov	r2, r3
 8003a70:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8003a74:	429a      	cmp	r2, r3
 8003a76:	d15d      	bne.n	8003b34 <process_thread_slip_process+0x1ec>
#define IP_DF   0x40
      if(BUF->ipid[0] == 0 && BUF->ipid[1] == 0 && BUF->ipoffset[0] & IP_DF) {
 8003a78:	f241 7318 	movw	r3, #5912	; 0x1718
 8003a7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003a80:	791b      	ldrb	r3, [r3, #4]
 8003a82:	2b00      	cmp	r3, #0
 8003a84:	d153      	bne.n	8003b2e <process_thread_slip_process+0x1e6>
 8003a86:	f241 7318 	movw	r3, #5912	; 0x1718
 8003a8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003a8e:	795b      	ldrb	r3, [r3, #5]
 8003a90:	2b00      	cmp	r3, #0
 8003a92:	d14c      	bne.n	8003b2e <process_thread_slip_process+0x1e6>
 8003a94:	f241 7318 	movw	r3, #5912	; 0x1718
 8003a98:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003a9c:	799b      	ldrb	r3, [r3, #6]
 8003a9e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8003aa2:	2b00      	cmp	r3, #0
 8003aa4:	d043      	beq.n	8003b2e <process_thread_slip_process+0x1e6>
	static uint16_t ip_id;
	uint16_t nid = ip_id++;
 8003aa6:	f241 33bc 	movw	r3, #5052	; 0x13bc
 8003aaa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003aae:	881b      	ldrh	r3, [r3, #0]
 8003ab0:	461a      	mov	r2, r3
 8003ab2:	83ba      	strh	r2, [r7, #28]
 8003ab4:	3301      	adds	r3, #1
 8003ab6:	b29a      	uxth	r2, r3
 8003ab8:	f241 33bc 	movw	r3, #5052	; 0x13bc
 8003abc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ac0:	801a      	strh	r2, [r3, #0]
	BUF->ipid[0] = nid >> 8;
 8003ac2:	f241 7318 	movw	r3, #5912	; 0x1718
 8003ac6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003aca:	8bba      	ldrh	r2, [r7, #28]
 8003acc:	0a12      	lsrs	r2, r2, #8
 8003ace:	b292      	uxth	r2, r2
 8003ad0:	b2d2      	uxtb	r2, r2
 8003ad2:	711a      	strb	r2, [r3, #4]
	BUF->ipid[1] = nid;
 8003ad4:	f241 7318 	movw	r3, #5912	; 0x1718
 8003ad8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003adc:	8bba      	ldrh	r2, [r7, #28]
 8003ade:	b2d2      	uxtb	r2, r2
 8003ae0:	715a      	strb	r2, [r3, #5]
	nid = uip_htons(nid);
 8003ae2:	8bbb      	ldrh	r3, [r7, #28]
 8003ae4:	4618      	mov	r0, r3
 8003ae6:	f002 ff83 	bl	80069f0 <uip_htons>
 8003aea:	4603      	mov	r3, r0
 8003aec:	83bb      	strh	r3, [r7, #28]
	nid = ~nid;		/* negate */
 8003aee:	8bbb      	ldrh	r3, [r7, #28]
 8003af0:	43db      	mvns	r3, r3
 8003af2:	83bb      	strh	r3, [r7, #28]
	BUF->ipchksum += nid;	/* add */
 8003af4:	f241 7318 	movw	r3, #5912	; 0x1718
 8003af8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003afc:	f241 7218 	movw	r2, #5912	; 0x1718
 8003b00:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8003b04:	8951      	ldrh	r1, [r2, #10]
 8003b06:	8bba      	ldrh	r2, [r7, #28]
 8003b08:	188a      	adds	r2, r1, r2
 8003b0a:	b292      	uxth	r2, r2
 8003b0c:	815a      	strh	r2, [r3, #10]
	if(BUF->ipchksum < nid) { /* 1-complement overflow? */
 8003b0e:	f241 7318 	movw	r3, #5912	; 0x1718
 8003b12:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003b16:	895b      	ldrh	r3, [r3, #10]
 8003b18:	8bba      	ldrh	r2, [r7, #28]
 8003b1a:	429a      	cmp	r2, r3
 8003b1c:	d907      	bls.n	8003b2e <process_thread_slip_process+0x1e6>
	  BUF->ipchksum++;
 8003b1e:	f241 7318 	movw	r3, #5912	; 0x1718
 8003b22:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003b26:	895a      	ldrh	r2, [r3, #10]
 8003b28:	3201      	adds	r2, #1
 8003b2a:	b292      	uxth	r2, r2
 8003b2c:	815a      	strh	r2, [r3, #10]
	}
      }
#ifdef SLIP_CONF_TCPIP_INPUT
      SLIP_CONF_TCPIP_INPUT();
#else
      tcpip_input();
 8003b2e:	f003 f9c7 	bl	8006ec0 <tcpip_input>
 8003b32:	e006      	b.n	8003b42 <process_thread_slip_process+0x1fa>
#endif
    } else {
      uip_len = 0;
 8003b34:	f241 730c 	movw	r3, #5900	; 0x170c
 8003b38:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003b3c:	2200      	movs	r2, #0
 8003b3e:	801a      	strh	r2, [r3, #0]
#else
      tcpip_input();
#endif
    }
#endif /* UIP_CONF_IPV6 */
  }
 8003b40:	e716      	b.n	8003970 <process_thread_slip_process+0x28>
 8003b42:	e715      	b.n	8003970 <process_thread_slip_process+0x28>

  PROCESS_END();
 8003b44:	2300      	movs	r3, #0
 8003b46:	77fb      	strb	r3, [r7, #31]
 8003b48:	68fb      	ldr	r3, [r7, #12]
 8003b4a:	2200      	movs	r2, #0
 8003b4c:	801a      	strh	r2, [r3, #0]
 8003b4e:	2303      	movs	r3, #3
}
 8003b50:	4618      	mov	r0, r3
 8003b52:	f107 0720 	add.w	r7, r7, #32
 8003b56:	46bd      	mov	sp, r7
 8003b58:	bd80      	pop	{r7, pc}
 8003b5a:	bf00      	nop

08003b5c <slip_input_byte>:
/*---------------------------------------------------------------------------*/
int
slip_input_byte(unsigned char c)
{
 8003b5c:	b580      	push	{r7, lr}
 8003b5e:	b084      	sub	sp, #16
 8003b60:	af00      	add	r7, sp, #0
 8003b62:	4603      	mov	r3, r0
 8003b64:	71fb      	strb	r3, [r7, #7]
  switch(state) {
 8003b66:	f241 13fa 	movw	r3, #4602	; 0x11fa
 8003b6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003b6e:	781b      	ldrb	r3, [r3, #0]
 8003b70:	2b03      	cmp	r3, #3
 8003b72:	d87f      	bhi.n	8003c74 <slip_input_byte+0x118>
 8003b74:	a201      	add	r2, pc, #4	; (adr r2, 8003b7c <slip_input_byte+0x20>)
 8003b76:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003b7a:	bf00      	nop
 8003b7c:	08003ba3 	.word	0x08003ba3
 8003b80:	08003bf1 	.word	0x08003bf1
 8003b84:	08003ba7 	.word	0x08003ba7
 8003b88:	08003b8d 	.word	0x08003b8d
  case STATE_RUBBISH:
    if(c == SLIP_END) {
 8003b8c:	79fb      	ldrb	r3, [r7, #7]
 8003b8e:	2bc0      	cmp	r3, #192	; 0xc0
 8003b90:	d105      	bne.n	8003b9e <slip_input_byte+0x42>
      state = STATE_OK;
 8003b92:	f241 13fa 	movw	r3, #4602	; 0x11fa
 8003b96:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003b9a:	2201      	movs	r2, #1
 8003b9c:	701a      	strb	r2, [r3, #0]
    }
    return 0;
 8003b9e:	2300      	movs	r3, #0
 8003ba0:	e0bc      	b.n	8003d1c <slip_input_byte+0x1c0>
    
  case STATE_TWOPACKETS:       /* Two packets are already buffered! */
    return 0;
 8003ba2:	2300      	movs	r3, #0
 8003ba4:	e0ba      	b.n	8003d1c <slip_input_byte+0x1c0>

  case STATE_ESC:
    if(c == SLIP_ESC_END) {
 8003ba6:	79fb      	ldrb	r3, [r7, #7]
 8003ba8:	2bdc      	cmp	r3, #220	; 0xdc
 8003baa:	d102      	bne.n	8003bb2 <slip_input_byte+0x56>
      c = SLIP_END;
 8003bac:	23c0      	movs	r3, #192	; 0xc0
 8003bae:	71fb      	strb	r3, [r7, #7]
 8003bb0:	e017      	b.n	8003be2 <slip_input_byte+0x86>
    } else if(c == SLIP_ESC_ESC) {
 8003bb2:	79fb      	ldrb	r3, [r7, #7]
 8003bb4:	2bdd      	cmp	r3, #221	; 0xdd
 8003bb6:	d102      	bne.n	8003bbe <slip_input_byte+0x62>
      c = SLIP_ESC;
 8003bb8:	23db      	movs	r3, #219	; 0xdb
 8003bba:	71fb      	strb	r3, [r7, #7]
 8003bbc:	e011      	b.n	8003be2 <slip_input_byte+0x86>
    } else {
      state = STATE_RUBBISH;
 8003bbe:	f241 13fa 	movw	r3, #4602	; 0x11fa
 8003bc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003bc6:	2203      	movs	r2, #3
 8003bc8:	701a      	strb	r2, [r3, #0]
      SLIP_STATISTICS(slip_rubbish++);
      end = pkt_end;		/* remove rubbish */
 8003bca:	f241 33b4 	movw	r3, #5044	; 0x13b4
 8003bce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003bd2:	881a      	ldrh	r2, [r3, #0]
 8003bd4:	f241 13fe 	movw	r3, #4606	; 0x11fe
 8003bd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003bdc:	801a      	strh	r2, [r3, #0]
      return 0;
 8003bde:	2300      	movs	r3, #0
 8003be0:	e09c      	b.n	8003d1c <slip_input_byte+0x1c0>
    }
    state = STATE_OK;
 8003be2:	f241 13fa 	movw	r3, #4602	; 0x11fa
 8003be6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003bea:	2201      	movs	r2, #1
 8003bec:	701a      	strb	r2, [r3, #0]
    break;
 8003bee:	e041      	b.n	8003c74 <slip_input_byte+0x118>

  case STATE_OK:
    if(c == SLIP_ESC) {
 8003bf0:	79fb      	ldrb	r3, [r7, #7]
 8003bf2:	2bdb      	cmp	r3, #219	; 0xdb
 8003bf4:	d107      	bne.n	8003c06 <slip_input_byte+0xaa>
      state = STATE_ESC;
 8003bf6:	f241 13fa 	movw	r3, #4602	; 0x11fa
 8003bfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003bfe:	2202      	movs	r2, #2
 8003c00:	701a      	strb	r2, [r3, #0]
      return 0;
 8003c02:	2300      	movs	r3, #0
 8003c04:	e08a      	b.n	8003d1c <slip_input_byte+0x1c0>
    } else if(c == SLIP_END) {
 8003c06:	79fb      	ldrb	r3, [r7, #7]
 8003c08:	2bc0      	cmp	r3, #192	; 0xc0
 8003c0a:	d132      	bne.n	8003c72 <slip_input_byte+0x116>
	/*
	 * We have a new packet, possibly of zero length.
	 *
	 * There may already be one packet buffered.
	 */
      if(end != pkt_end) {	/* Non zero length. */
 8003c0c:	f241 13fe 	movw	r3, #4606	; 0x11fe
 8003c10:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003c14:	881a      	ldrh	r2, [r3, #0]
 8003c16:	f241 33b4 	movw	r3, #5044	; 0x13b4
 8003c1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003c1e:	881b      	ldrh	r3, [r3, #0]
 8003c20:	429a      	cmp	r2, r3
 8003c22:	d024      	beq.n	8003c6e <slip_input_byte+0x112>
	if(begin == pkt_end) {	/* None buffered. */
 8003c24:	f241 13fc 	movw	r3, #4604	; 0x11fc
 8003c28:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003c2c:	881a      	ldrh	r2, [r3, #0]
 8003c2e:	f241 33b4 	movw	r3, #5044	; 0x13b4
 8003c32:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003c36:	881b      	ldrh	r3, [r3, #0]
 8003c38:	429a      	cmp	r2, r3
 8003c3a:	d10a      	bne.n	8003c52 <slip_input_byte+0xf6>
	  pkt_end = end;
 8003c3c:	f241 13fe 	movw	r3, #4606	; 0x11fe
 8003c40:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003c44:	881a      	ldrh	r2, [r3, #0]
 8003c46:	f241 33b4 	movw	r3, #5044	; 0x13b4
 8003c4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003c4e:	801a      	strh	r2, [r3, #0]
 8003c50:	e005      	b.n	8003c5e <slip_input_byte+0x102>
	} else {
	  state = STATE_TWOPACKETS;
 8003c52:	f241 13fa 	movw	r3, #4602	; 0x11fa
 8003c56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003c5a:	2200      	movs	r2, #0
 8003c5c:	701a      	strb	r2, [r3, #0]
	  SLIP_STATISTICS(slip_twopackets++);
	}
	process_poll(&slip_process);
 8003c5e:	f640 001c 	movw	r0, #2076	; 0x81c
 8003c62:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003c66:	f000 fb41 	bl	80042ec <process_poll>
	return 1;
 8003c6a:	2301      	movs	r3, #1
 8003c6c:	e056      	b.n	8003d1c <slip_input_byte+0x1c0>
      }
      return 0;
 8003c6e:	2300      	movs	r3, #0
 8003c70:	e054      	b.n	8003d1c <slip_input_byte+0x1c0>
    }
    break;
 8003c72:	bf00      	nop
  }

  /* add_char: */
  {
    unsigned next;
    next = end + 1;
 8003c74:	f241 13fe 	movw	r3, #4606	; 0x11fe
 8003c78:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003c7c:	881b      	ldrh	r3, [r3, #0]
 8003c7e:	3301      	adds	r3, #1
 8003c80:	60fb      	str	r3, [r7, #12]
    if(next == RX_BUFSIZE) {
 8003c82:	68fb      	ldr	r3, [r7, #12]
 8003c84:	f5b3 7fda 	cmp.w	r3, #436	; 0x1b4
 8003c88:	d101      	bne.n	8003c8e <slip_input_byte+0x132>
      next = 0;
 8003c8a:	2300      	movs	r3, #0
 8003c8c:	60fb      	str	r3, [r7, #12]
    }
    if(next == begin) {		/* rxbuf is full */
 8003c8e:	f241 13fc 	movw	r3, #4604	; 0x11fc
 8003c92:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003c96:	881b      	ldrh	r3, [r3, #0]
 8003c98:	461a      	mov	r2, r3
 8003c9a:	68fb      	ldr	r3, [r7, #12]
 8003c9c:	429a      	cmp	r2, r3
 8003c9e:	d111      	bne.n	8003cc4 <slip_input_byte+0x168>
      state = STATE_RUBBISH;
 8003ca0:	f241 13fa 	movw	r3, #4602	; 0x11fa
 8003ca4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ca8:	2203      	movs	r2, #3
 8003caa:	701a      	strb	r2, [r3, #0]
      SLIP_STATISTICS(slip_overflow++);
      end = pkt_end;		/* remove rubbish */
 8003cac:	f241 33b4 	movw	r3, #5044	; 0x13b4
 8003cb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003cb4:	881a      	ldrh	r2, [r3, #0]
 8003cb6:	f241 13fe 	movw	r3, #4606	; 0x11fe
 8003cba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003cbe:	801a      	strh	r2, [r3, #0]
      return 0;
 8003cc0:	2300      	movs	r3, #0
 8003cc2:	e02b      	b.n	8003d1c <slip_input_byte+0x1c0>
    }
    rxbuf[end] = c;
 8003cc4:	f241 13fe 	movw	r3, #4606	; 0x11fe
 8003cc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ccc:	881b      	ldrh	r3, [r3, #0]
 8003cce:	461a      	mov	r2, r3
 8003cd0:	f241 2300 	movw	r3, #4608	; 0x1200
 8003cd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003cd8:	79f9      	ldrb	r1, [r7, #7]
 8003cda:	5499      	strb	r1, [r3, r2]
    end = next;
 8003cdc:	68fb      	ldr	r3, [r7, #12]
 8003cde:	b29a      	uxth	r2, r3
 8003ce0:	f241 13fe 	movw	r3, #4606	; 0x11fe
 8003ce4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ce8:	801a      	strh	r2, [r3, #0]
  }

  /* There could be a separate poll routine for this. */
  if(c == 'T' && rxbuf[begin] == 'C') {
 8003cea:	79fb      	ldrb	r3, [r7, #7]
 8003cec:	2b54      	cmp	r3, #84	; 0x54
 8003cee:	d114      	bne.n	8003d1a <slip_input_byte+0x1be>
 8003cf0:	f241 13fc 	movw	r3, #4604	; 0x11fc
 8003cf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003cf8:	881b      	ldrh	r3, [r3, #0]
 8003cfa:	461a      	mov	r2, r3
 8003cfc:	f241 2300 	movw	r3, #4608	; 0x1200
 8003d00:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003d04:	5c9b      	ldrb	r3, [r3, r2]
 8003d06:	2b43      	cmp	r3, #67	; 0x43
 8003d08:	d107      	bne.n	8003d1a <slip_input_byte+0x1be>
    process_poll(&slip_process);
 8003d0a:	f640 001c 	movw	r0, #2076	; 0x81c
 8003d0e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003d12:	f000 faeb 	bl	80042ec <process_poll>
    return 1;
 8003d16:	2301      	movs	r3, #1
 8003d18:	e000      	b.n	8003d1c <slip_input_byte+0x1c0>
  }

  return 0;
 8003d1a:	2300      	movs	r3, #0
}
 8003d1c:	4618      	mov	r0, r3
 8003d1e:	f107 0710 	add.w	r7, r7, #16
 8003d22:	46bd      	mov	sp, r7
 8003d24:	bd80      	pop	{r7, pc}
 8003d26:	bf00      	nop

08003d28 <process_alloc_event>:
#endif

/*---------------------------------------------------------------------------*/
process_event_t
process_alloc_event(void)
{
 8003d28:	b480      	push	{r7}
 8003d2a:	af00      	add	r7, sp, #0
  return lastevent++;
 8003d2c:	f241 33c8 	movw	r3, #5064	; 0x13c8
 8003d30:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003d34:	781b      	ldrb	r3, [r3, #0]
 8003d36:	461a      	mov	r2, r3
 8003d38:	3301      	adds	r3, #1
 8003d3a:	b2d9      	uxtb	r1, r3
 8003d3c:	f241 33c8 	movw	r3, #5064	; 0x13c8
 8003d40:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003d44:	7019      	strb	r1, [r3, #0]
 8003d46:	4613      	mov	r3, r2
}
 8003d48:	4618      	mov	r0, r3
 8003d4a:	46bd      	mov	sp, r7
 8003d4c:	bc80      	pop	{r7}
 8003d4e:	4770      	bx	lr

08003d50 <process_start>:
/*---------------------------------------------------------------------------*/
void
process_start(struct process *p, const char *arg)
{
 8003d50:	b580      	push	{r7, lr}
 8003d52:	b084      	sub	sp, #16
 8003d54:	af00      	add	r7, sp, #0
 8003d56:	6078      	str	r0, [r7, #4]
 8003d58:	6039      	str	r1, [r7, #0]
  struct process *q;

  /* First make sure that we don't try to start a process that is
     already running. */
  for(q = process_list; q != p && q != NULL; q = q->next);
 8003d5a:	f241 33c0 	movw	r3, #5056	; 0x13c0
 8003d5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003d62:	681b      	ldr	r3, [r3, #0]
 8003d64:	60fb      	str	r3, [r7, #12]
 8003d66:	e002      	b.n	8003d6e <process_start+0x1e>
 8003d68:	68fb      	ldr	r3, [r7, #12]
 8003d6a:	681b      	ldr	r3, [r3, #0]
 8003d6c:	60fb      	str	r3, [r7, #12]
 8003d6e:	68fa      	ldr	r2, [r7, #12]
 8003d70:	687b      	ldr	r3, [r7, #4]
 8003d72:	429a      	cmp	r2, r3
 8003d74:	d002      	beq.n	8003d7c <process_start+0x2c>
 8003d76:	68fb      	ldr	r3, [r7, #12]
 8003d78:	2b00      	cmp	r3, #0
 8003d7a:	d1f5      	bne.n	8003d68 <process_start+0x18>

  /* If we found the process on the process list, we bail out. */
  if(q == p) {
 8003d7c:	68fa      	ldr	r2, [r7, #12]
 8003d7e:	687b      	ldr	r3, [r7, #4]
 8003d80:	429a      	cmp	r2, r3
 8003d82:	d018      	beq.n	8003db6 <process_start+0x66>
    return;
  }
  /* Put on the procs list.*/
  p->next = process_list;
 8003d84:	f241 33c0 	movw	r3, #5056	; 0x13c0
 8003d88:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003d8c:	681a      	ldr	r2, [r3, #0]
 8003d8e:	687b      	ldr	r3, [r7, #4]
 8003d90:	601a      	str	r2, [r3, #0]
  process_list = p;
 8003d92:	f241 33c0 	movw	r3, #5056	; 0x13c0
 8003d96:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003d9a:	687a      	ldr	r2, [r7, #4]
 8003d9c:	601a      	str	r2, [r3, #0]
  p->state = PROCESS_STATE_RUNNING;
 8003d9e:	687b      	ldr	r3, [r7, #4]
 8003da0:	2201      	movs	r2, #1
 8003da2:	739a      	strb	r2, [r3, #14]
  PT_INIT(&p->pt);
 8003da4:	687b      	ldr	r3, [r7, #4]
 8003da6:	2200      	movs	r2, #0
 8003da8:	819a      	strh	r2, [r3, #12]

  PRINTF("process: starting '%s'\n", PROCESS_NAME_STRING(p));

  /* Post a synchronous initialization event to the process. */
  process_post_synch(p, PROCESS_EVENT_INIT, (process_data_t)arg);
 8003daa:	6878      	ldr	r0, [r7, #4]
 8003dac:	2181      	movs	r1, #129	; 0x81
 8003dae:	683a      	ldr	r2, [r7, #0]
 8003db0:	f000 fa7e 	bl	80042b0 <process_post_synch>
 8003db4:	e000      	b.n	8003db8 <process_start+0x68>
     already running. */
  for(q = process_list; q != p && q != NULL; q = q->next);

  /* If we found the process on the process list, we bail out. */
  if(q == p) {
    return;
 8003db6:	bf00      	nop

  PRINTF("process: starting '%s'\n", PROCESS_NAME_STRING(p));

  /* Post a synchronous initialization event to the process. */
  process_post_synch(p, PROCESS_EVENT_INIT, (process_data_t)arg);
}
 8003db8:	f107 0710 	add.w	r7, r7, #16
 8003dbc:	46bd      	mov	sp, r7
 8003dbe:	bd80      	pop	{r7, pc}

08003dc0 <exit_process>:
/*---------------------------------------------------------------------------*/
static void
exit_process(struct process *p, struct process *fromprocess)
{
 8003dc0:	b590      	push	{r4, r7, lr}
 8003dc2:	b085      	sub	sp, #20
 8003dc4:	af00      	add	r7, sp, #0
 8003dc6:	6078      	str	r0, [r7, #4]
 8003dc8:	6039      	str	r1, [r7, #0]
  register struct process *q;
  struct process *old_current = process_current;
 8003dca:	f241 33c4 	movw	r3, #5060	; 0x13c4
 8003dce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003dd2:	681b      	ldr	r3, [r3, #0]
 8003dd4:	60fb      	str	r3, [r7, #12]

  PRINTF("process: exit_process '%s'\n", PROCESS_NAME_STRING(p));

  /* Make sure the process is in the process list before we try to
     exit it. */
  for(q = process_list; q != p && q != NULL; q = q->next);
 8003dd6:	f241 33c0 	movw	r3, #5056	; 0x13c0
 8003dda:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003dde:	681c      	ldr	r4, [r3, #0]
 8003de0:	e000      	b.n	8003de4 <exit_process+0x24>
 8003de2:	6824      	ldr	r4, [r4, #0]
 8003de4:	687b      	ldr	r3, [r7, #4]
 8003de6:	429c      	cmp	r4, r3
 8003de8:	d001      	beq.n	8003dee <exit_process+0x2e>
 8003dea:	2c00      	cmp	r4, #0
 8003dec:	d1f9      	bne.n	8003de2 <exit_process+0x22>
  if(q == NULL) {
 8003dee:	2c00      	cmp	r4, #0
 8003df0:	d05b      	beq.n	8003eaa <exit_process+0xea>
    return;
  }

  if(process_is_running(p)) {
 8003df2:	6878      	ldr	r0, [r7, #4]
 8003df4:	f000 fa98 	bl	8004328 <process_is_running>
 8003df8:	4603      	mov	r3, r0
 8003dfa:	2b00      	cmp	r3, #0
 8003dfc:	d029      	beq.n	8003e52 <exit_process+0x92>
    /* Process was running */
    p->state = PROCESS_STATE_NONE;
 8003dfe:	687b      	ldr	r3, [r7, #4]
 8003e00:	2200      	movs	r2, #0
 8003e02:	739a      	strb	r2, [r3, #14]
    /*
     * Post a synchronous event to all processes to inform them that
     * this process is about to exit. This will allow services to
     * deallocate state associated with this process.
     */
    for(q = process_list; q != NULL; q = q->next) {
 8003e04:	f241 33c0 	movw	r3, #5056	; 0x13c0
 8003e08:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003e0c:	681c      	ldr	r4, [r3, #0]
 8003e0e:	e008      	b.n	8003e22 <exit_process+0x62>
      if(p != q) {
 8003e10:	687b      	ldr	r3, [r7, #4]
 8003e12:	42a3      	cmp	r3, r4
 8003e14:	d004      	beq.n	8003e20 <exit_process+0x60>
	call_process(q, PROCESS_EVENT_EXITED, (process_data_t)p);
 8003e16:	4620      	mov	r0, r4
 8003e18:	2187      	movs	r1, #135	; 0x87
 8003e1a:	687a      	ldr	r2, [r7, #4]
 8003e1c:	f000 f84a 	bl	8003eb4 <call_process>
    /*
     * Post a synchronous event to all processes to inform them that
     * this process is about to exit. This will allow services to
     * deallocate state associated with this process.
     */
    for(q = process_list; q != NULL; q = q->next) {
 8003e20:	6824      	ldr	r4, [r4, #0]
 8003e22:	2c00      	cmp	r4, #0
 8003e24:	d1f4      	bne.n	8003e10 <exit_process+0x50>
      if(p != q) {
	call_process(q, PROCESS_EVENT_EXITED, (process_data_t)p);
      }
    }

    if(p->thread != NULL && p != fromprocess) {
 8003e26:	687b      	ldr	r3, [r7, #4]
 8003e28:	689b      	ldr	r3, [r3, #8]
 8003e2a:	2b00      	cmp	r3, #0
 8003e2c:	d011      	beq.n	8003e52 <exit_process+0x92>
 8003e2e:	687a      	ldr	r2, [r7, #4]
 8003e30:	683b      	ldr	r3, [r7, #0]
 8003e32:	429a      	cmp	r2, r3
 8003e34:	d00d      	beq.n	8003e52 <exit_process+0x92>
      /* Post the exit event to the process that is about to exit. */
      process_current = p;
 8003e36:	f241 33c4 	movw	r3, #5060	; 0x13c4
 8003e3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003e3e:	687a      	ldr	r2, [r7, #4]
 8003e40:	601a      	str	r2, [r3, #0]
      p->thread(&p->pt, PROCESS_EVENT_EXIT, NULL);
 8003e42:	687b      	ldr	r3, [r7, #4]
 8003e44:	689b      	ldr	r3, [r3, #8]
 8003e46:	687a      	ldr	r2, [r7, #4]
 8003e48:	320c      	adds	r2, #12
 8003e4a:	4610      	mov	r0, r2
 8003e4c:	2183      	movs	r1, #131	; 0x83
 8003e4e:	2200      	movs	r2, #0
 8003e50:	4798      	blx	r3
    }
  }

  if(p == process_list) {
 8003e52:	f241 33c0 	movw	r3, #5056	; 0x13c0
 8003e56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003e5a:	681b      	ldr	r3, [r3, #0]
 8003e5c:	687a      	ldr	r2, [r7, #4]
 8003e5e:	429a      	cmp	r2, r3
 8003e60:	d10b      	bne.n	8003e7a <exit_process+0xba>
    process_list = process_list->next;
 8003e62:	f241 33c0 	movw	r3, #5056	; 0x13c0
 8003e66:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003e6a:	681b      	ldr	r3, [r3, #0]
 8003e6c:	681a      	ldr	r2, [r3, #0]
 8003e6e:	f241 33c0 	movw	r3, #5056	; 0x13c0
 8003e72:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003e76:	601a      	str	r2, [r3, #0]
 8003e78:	e010      	b.n	8003e9c <exit_process+0xdc>
  } else {
    for(q = process_list; q != NULL; q = q->next) {
 8003e7a:	f241 33c0 	movw	r3, #5056	; 0x13c0
 8003e7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003e82:	681c      	ldr	r4, [r3, #0]
 8003e84:	e008      	b.n	8003e98 <exit_process+0xd8>
      if(q->next == p) {
 8003e86:	6822      	ldr	r2, [r4, #0]
 8003e88:	687b      	ldr	r3, [r7, #4]
 8003e8a:	429a      	cmp	r2, r3
 8003e8c:	d103      	bne.n	8003e96 <exit_process+0xd6>
	q->next = p->next;
 8003e8e:	687b      	ldr	r3, [r7, #4]
 8003e90:	681b      	ldr	r3, [r3, #0]
 8003e92:	6023      	str	r3, [r4, #0]
	break;
 8003e94:	e002      	b.n	8003e9c <exit_process+0xdc>
  }

  if(p == process_list) {
    process_list = process_list->next;
  } else {
    for(q = process_list; q != NULL; q = q->next) {
 8003e96:	6824      	ldr	r4, [r4, #0]
 8003e98:	2c00      	cmp	r4, #0
 8003e9a:	d1f4      	bne.n	8003e86 <exit_process+0xc6>
	break;
      }
    }
  }

  process_current = old_current;
 8003e9c:	f241 33c4 	movw	r3, #5060	; 0x13c4
 8003ea0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ea4:	68fa      	ldr	r2, [r7, #12]
 8003ea6:	601a      	str	r2, [r3, #0]
 8003ea8:	e000      	b.n	8003eac <exit_process+0xec>

  /* Make sure the process is in the process list before we try to
     exit it. */
  for(q = process_list; q != p && q != NULL; q = q->next);
  if(q == NULL) {
    return;
 8003eaa:	bf00      	nop
      }
    }
  }

  process_current = old_current;
}
 8003eac:	f107 0714 	add.w	r7, r7, #20
 8003eb0:	46bd      	mov	sp, r7
 8003eb2:	bd90      	pop	{r4, r7, pc}

08003eb4 <call_process>:
/*---------------------------------------------------------------------------*/
static void
call_process(struct process *p, process_event_t ev, process_data_t data)
{
 8003eb4:	b580      	push	{r7, lr}
 8003eb6:	b086      	sub	sp, #24
 8003eb8:	af00      	add	r7, sp, #0
 8003eba:	60f8      	str	r0, [r7, #12]
 8003ebc:	460b      	mov	r3, r1
 8003ebe:	607a      	str	r2, [r7, #4]
 8003ec0:	72fb      	strb	r3, [r7, #11]
  if(p->state == PROCESS_STATE_CALLED) {
    printf("process: process '%s' called again with event %d\n", PROCESS_NAME_STRING(p), ev);
  }
#endif /* DEBUG */
  
  if((p->state & PROCESS_STATE_RUNNING) &&
 8003ec2:	68fb      	ldr	r3, [r7, #12]
 8003ec4:	7b9b      	ldrb	r3, [r3, #14]
 8003ec6:	f003 0301 	and.w	r3, r3, #1
 8003eca:	2b00      	cmp	r3, #0
 8003ecc:	d029      	beq.n	8003f22 <call_process+0x6e>
     p->thread != NULL) {
 8003ece:	68fb      	ldr	r3, [r7, #12]
 8003ed0:	689b      	ldr	r3, [r3, #8]
  if(p->state == PROCESS_STATE_CALLED) {
    printf("process: process '%s' called again with event %d\n", PROCESS_NAME_STRING(p), ev);
  }
#endif /* DEBUG */
  
  if((p->state & PROCESS_STATE_RUNNING) &&
 8003ed2:	2b00      	cmp	r3, #0
 8003ed4:	d025      	beq.n	8003f22 <call_process+0x6e>
     p->thread != NULL) {
    PRINTF("process: calling process '%s' with event %d\n", PROCESS_NAME_STRING(p), ev);
    process_current = p;
 8003ed6:	f241 33c4 	movw	r3, #5060	; 0x13c4
 8003eda:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ede:	68fa      	ldr	r2, [r7, #12]
 8003ee0:	601a      	str	r2, [r3, #0]
    p->state = PROCESS_STATE_CALLED;
 8003ee2:	68fb      	ldr	r3, [r7, #12]
 8003ee4:	2202      	movs	r2, #2
 8003ee6:	739a      	strb	r2, [r3, #14]
    ret = p->thread(&p->pt, ev, data);
 8003ee8:	68fb      	ldr	r3, [r7, #12]
 8003eea:	689b      	ldr	r3, [r3, #8]
 8003eec:	68fa      	ldr	r2, [r7, #12]
 8003eee:	f102 010c 	add.w	r1, r2, #12
 8003ef2:	7afa      	ldrb	r2, [r7, #11]
 8003ef4:	4608      	mov	r0, r1
 8003ef6:	4611      	mov	r1, r2
 8003ef8:	687a      	ldr	r2, [r7, #4]
 8003efa:	4798      	blx	r3
 8003efc:	4603      	mov	r3, r0
 8003efe:	617b      	str	r3, [r7, #20]
    if(ret == PT_EXITED ||
 8003f00:	697b      	ldr	r3, [r7, #20]
 8003f02:	2b02      	cmp	r3, #2
 8003f04:	d005      	beq.n	8003f12 <call_process+0x5e>
 8003f06:	697b      	ldr	r3, [r7, #20]
 8003f08:	2b03      	cmp	r3, #3
 8003f0a:	d002      	beq.n	8003f12 <call_process+0x5e>
       ret == PT_ENDED ||
 8003f0c:	7afb      	ldrb	r3, [r7, #11]
 8003f0e:	2b83      	cmp	r3, #131	; 0x83
 8003f10:	d104      	bne.n	8003f1c <call_process+0x68>
       ev == PROCESS_EVENT_EXIT) {
      exit_process(p, p);
 8003f12:	68f8      	ldr	r0, [r7, #12]
 8003f14:	68f9      	ldr	r1, [r7, #12]
 8003f16:	f7ff ff53 	bl	8003dc0 <exit_process>
 8003f1a:	e002      	b.n	8003f22 <call_process+0x6e>
    } else {
      p->state = PROCESS_STATE_RUNNING;
 8003f1c:	68fb      	ldr	r3, [r7, #12]
 8003f1e:	2201      	movs	r2, #1
 8003f20:	739a      	strb	r2, [r3, #14]
    }
  }
}
 8003f22:	f107 0718 	add.w	r7, r7, #24
 8003f26:	46bd      	mov	sp, r7
 8003f28:	bd80      	pop	{r7, pc}
 8003f2a:	bf00      	nop

08003f2c <process_exit>:
/*---------------------------------------------------------------------------*/
void
process_exit(struct process *p)
{
 8003f2c:	b580      	push	{r7, lr}
 8003f2e:	b082      	sub	sp, #8
 8003f30:	af00      	add	r7, sp, #0
 8003f32:	6078      	str	r0, [r7, #4]
  exit_process(p, PROCESS_CURRENT());
 8003f34:	f241 33c4 	movw	r3, #5060	; 0x13c4
 8003f38:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f3c:	681b      	ldr	r3, [r3, #0]
 8003f3e:	6878      	ldr	r0, [r7, #4]
 8003f40:	4619      	mov	r1, r3
 8003f42:	f7ff ff3d 	bl	8003dc0 <exit_process>
}
 8003f46:	f107 0708 	add.w	r7, r7, #8
 8003f4a:	46bd      	mov	sp, r7
 8003f4c:	bd80      	pop	{r7, pc}
 8003f4e:	bf00      	nop

08003f50 <process_init>:
/*---------------------------------------------------------------------------*/
void
process_init(void)
{
 8003f50:	b480      	push	{r7}
 8003f52:	af00      	add	r7, sp, #0
  lastevent = PROCESS_EVENT_MAX;
 8003f54:	f241 33c8 	movw	r3, #5064	; 0x13c8
 8003f58:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f5c:	228a      	movs	r2, #138	; 0x8a
 8003f5e:	701a      	strb	r2, [r3, #0]

  nevents = fevent = 0;
 8003f60:	f241 33ca 	movw	r3, #5066	; 0x13ca
 8003f64:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f68:	2200      	movs	r2, #0
 8003f6a:	701a      	strb	r2, [r3, #0]
 8003f6c:	f241 33ca 	movw	r3, #5066	; 0x13ca
 8003f70:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f74:	781a      	ldrb	r2, [r3, #0]
 8003f76:	f241 33c9 	movw	r3, #5065	; 0x13c9
 8003f7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f7e:	701a      	strb	r2, [r3, #0]
#if PROCESS_CONF_STATS
  process_maxevents = 0;
#endif /* PROCESS_CONF_STATS */

  process_current = process_list = NULL;
 8003f80:	f241 33c0 	movw	r3, #5056	; 0x13c0
 8003f84:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f88:	2200      	movs	r2, #0
 8003f8a:	601a      	str	r2, [r3, #0]
 8003f8c:	f241 33c0 	movw	r3, #5056	; 0x13c0
 8003f90:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f94:	681a      	ldr	r2, [r3, #0]
 8003f96:	f241 33c4 	movw	r3, #5060	; 0x13c4
 8003f9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f9e:	601a      	str	r2, [r3, #0]
}
 8003fa0:	46bd      	mov	sp, r7
 8003fa2:	bc80      	pop	{r7}
 8003fa4:	4770      	bx	lr
 8003fa6:	bf00      	nop

08003fa8 <do_poll>:
 * Call each process' poll handler.
 */
/*---------------------------------------------------------------------------*/
static void
do_poll(void)
{
 8003fa8:	b580      	push	{r7, lr}
 8003faa:	b082      	sub	sp, #8
 8003fac:	af00      	add	r7, sp, #0
  struct process *p;

  poll_requested = 0;
 8003fae:	f241 534c 	movw	r3, #5452	; 0x154c
 8003fb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003fb6:	2200      	movs	r2, #0
 8003fb8:	701a      	strb	r2, [r3, #0]
  /* Call the processes that needs to be polled. */
  for(p = process_list; p != NULL; p = p->next) {
 8003fba:	f241 33c0 	movw	r3, #5056	; 0x13c0
 8003fbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003fc2:	681b      	ldr	r3, [r3, #0]
 8003fc4:	607b      	str	r3, [r7, #4]
 8003fc6:	e011      	b.n	8003fec <do_poll+0x44>
    if(p->needspoll) {
 8003fc8:	687b      	ldr	r3, [r7, #4]
 8003fca:	7bdb      	ldrb	r3, [r3, #15]
 8003fcc:	2b00      	cmp	r3, #0
 8003fce:	d00a      	beq.n	8003fe6 <do_poll+0x3e>
      p->state = PROCESS_STATE_RUNNING;
 8003fd0:	687b      	ldr	r3, [r7, #4]
 8003fd2:	2201      	movs	r2, #1
 8003fd4:	739a      	strb	r2, [r3, #14]
      p->needspoll = 0;
 8003fd6:	687b      	ldr	r3, [r7, #4]
 8003fd8:	2200      	movs	r2, #0
 8003fda:	73da      	strb	r2, [r3, #15]
      call_process(p, PROCESS_EVENT_POLL, NULL);
 8003fdc:	6878      	ldr	r0, [r7, #4]
 8003fde:	2182      	movs	r1, #130	; 0x82
 8003fe0:	2200      	movs	r2, #0
 8003fe2:	f7ff ff67 	bl	8003eb4 <call_process>
{
  struct process *p;

  poll_requested = 0;
  /* Call the processes that needs to be polled. */
  for(p = process_list; p != NULL; p = p->next) {
 8003fe6:	687b      	ldr	r3, [r7, #4]
 8003fe8:	681b      	ldr	r3, [r3, #0]
 8003fea:	607b      	str	r3, [r7, #4]
 8003fec:	687b      	ldr	r3, [r7, #4]
 8003fee:	2b00      	cmp	r3, #0
 8003ff0:	d1ea      	bne.n	8003fc8 <do_poll+0x20>
      p->state = PROCESS_STATE_RUNNING;
      p->needspoll = 0;
      call_process(p, PROCESS_EVENT_POLL, NULL);
    }
  }
}
 8003ff2:	f107 0708 	add.w	r7, r7, #8
 8003ff6:	46bd      	mov	sp, r7
 8003ff8:	bd80      	pop	{r7, pc}
 8003ffa:	bf00      	nop

08003ffc <do_event>:
 * listening processes.
 */
/*---------------------------------------------------------------------------*/
static void
do_event(void)
{
 8003ffc:	b580      	push	{r7, lr}
 8003ffe:	af00      	add	r7, sp, #0
   * delivered to any of them. If so, we call the event handler
   * function for the process. We only process one event at a time and
   * call the poll handlers inbetween.
   */

  if(nevents > 0) {
 8004000:	f241 33c9 	movw	r3, #5065	; 0x13c9
 8004004:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004008:	781b      	ldrb	r3, [r3, #0]
 800400a:	2b00      	cmp	r3, #0
 800400c:	f000 80c4 	beq.w	8004198 <do_event+0x19c>
    
    /* There are events that we should deliver. */
    ev = events[fevent].ev;
 8004010:	f241 33ca 	movw	r3, #5066	; 0x13ca
 8004014:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004018:	781b      	ldrb	r3, [r3, #0]
 800401a:	4619      	mov	r1, r3
 800401c:	f241 32cc 	movw	r2, #5068	; 0x13cc
 8004020:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004024:	460b      	mov	r3, r1
 8004026:	005b      	lsls	r3, r3, #1
 8004028:	185b      	adds	r3, r3, r1
 800402a:	009b      	lsls	r3, r3, #2
 800402c:	18d3      	adds	r3, r2, r3
 800402e:	781a      	ldrb	r2, [r3, #0]
 8004030:	f241 534e 	movw	r3, #5454	; 0x154e
 8004034:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004038:	701a      	strb	r2, [r3, #0]
    
    data = events[fevent].data;
 800403a:	f241 33ca 	movw	r3, #5066	; 0x13ca
 800403e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004042:	781b      	ldrb	r3, [r3, #0]
 8004044:	4619      	mov	r1, r3
 8004046:	f241 32cc 	movw	r2, #5068	; 0x13cc
 800404a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800404e:	460b      	mov	r3, r1
 8004050:	005b      	lsls	r3, r3, #1
 8004052:	185b      	adds	r3, r3, r1
 8004054:	009b      	lsls	r3, r3, #2
 8004056:	18d3      	adds	r3, r2, r3
 8004058:	3304      	adds	r3, #4
 800405a:	681a      	ldr	r2, [r3, #0]
 800405c:	f241 5350 	movw	r3, #5456	; 0x1550
 8004060:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004064:	601a      	str	r2, [r3, #0]
    receiver = events[fevent].p;
 8004066:	f241 33ca 	movw	r3, #5066	; 0x13ca
 800406a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800406e:	781b      	ldrb	r3, [r3, #0]
 8004070:	4619      	mov	r1, r3
 8004072:	f241 32cc 	movw	r2, #5068	; 0x13cc
 8004076:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800407a:	460b      	mov	r3, r1
 800407c:	005b      	lsls	r3, r3, #1
 800407e:	185b      	adds	r3, r3, r1
 8004080:	009b      	lsls	r3, r3, #2
 8004082:	18d3      	adds	r3, r2, r3
 8004084:	3308      	adds	r3, #8
 8004086:	681a      	ldr	r2, [r3, #0]
 8004088:	f241 5354 	movw	r3, #5460	; 0x1554
 800408c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004090:	601a      	str	r2, [r3, #0]

    /* Since we have seen the new event, we move pointer upwards
       and decrese the number of events. */
    fevent = (fevent + 1) % PROCESS_CONF_NUMEVENTS;
 8004092:	f241 33ca 	movw	r3, #5066	; 0x13ca
 8004096:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800409a:	781b      	ldrb	r3, [r3, #0]
 800409c:	1c5a      	adds	r2, r3, #1
 800409e:	17d3      	asrs	r3, r2, #31
 80040a0:	0edb      	lsrs	r3, r3, #27
 80040a2:	18d2      	adds	r2, r2, r3
 80040a4:	f002 021f 	and.w	r2, r2, #31
 80040a8:	1ad3      	subs	r3, r2, r3
 80040aa:	b2da      	uxtb	r2, r3
 80040ac:	f241 33ca 	movw	r3, #5066	; 0x13ca
 80040b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80040b4:	701a      	strb	r2, [r3, #0]
    --nevents;
 80040b6:	f241 33c9 	movw	r3, #5065	; 0x13c9
 80040ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80040be:	781b      	ldrb	r3, [r3, #0]
 80040c0:	3b01      	subs	r3, #1
 80040c2:	b2da      	uxtb	r2, r3
 80040c4:	f241 33c9 	movw	r3, #5065	; 0x13c9
 80040c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80040cc:	701a      	strb	r2, [r3, #0]

    /* If this is a broadcast event, we deliver it to all events, in
       order of their priority. */
    if(receiver == PROCESS_BROADCAST) {
 80040ce:	f241 5354 	movw	r3, #5460	; 0x1554
 80040d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80040d6:	681b      	ldr	r3, [r3, #0]
 80040d8:	2b00      	cmp	r3, #0
 80040da:	d13b      	bne.n	8004154 <do_event+0x158>
      for(p = process_list; p != NULL; p = p->next) {
 80040dc:	f241 33c0 	movw	r3, #5056	; 0x13c0
 80040e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80040e4:	681a      	ldr	r2, [r3, #0]
 80040e6:	f241 5358 	movw	r3, #5464	; 0x1558
 80040ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80040ee:	601a      	str	r2, [r3, #0]
 80040f0:	e028      	b.n	8004144 <do_event+0x148>

	/* If we have been requested to poll a process, we do this in
	   between processing the broadcast event. */
	if(poll_requested) {
 80040f2:	f241 534c 	movw	r3, #5452	; 0x154c
 80040f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80040fa:	781b      	ldrb	r3, [r3, #0]
 80040fc:	b2db      	uxtb	r3, r3
 80040fe:	2b00      	cmp	r3, #0
 8004100:	d001      	beq.n	8004106 <do_event+0x10a>
	  do_poll();
 8004102:	f7ff ff51 	bl	8003fa8 <do_poll>
	}
	call_process(p, ev, data);
 8004106:	f241 5358 	movw	r3, #5464	; 0x1558
 800410a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800410e:	6819      	ldr	r1, [r3, #0]
 8004110:	f241 534e 	movw	r3, #5454	; 0x154e
 8004114:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004118:	781a      	ldrb	r2, [r3, #0]
 800411a:	f241 5350 	movw	r3, #5456	; 0x1550
 800411e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004122:	681b      	ldr	r3, [r3, #0]
 8004124:	4608      	mov	r0, r1
 8004126:	4611      	mov	r1, r2
 8004128:	461a      	mov	r2, r3
 800412a:	f7ff fec3 	bl	8003eb4 <call_process>
    --nevents;

    /* If this is a broadcast event, we deliver it to all events, in
       order of their priority. */
    if(receiver == PROCESS_BROADCAST) {
      for(p = process_list; p != NULL; p = p->next) {
 800412e:	f241 5358 	movw	r3, #5464	; 0x1558
 8004132:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004136:	681b      	ldr	r3, [r3, #0]
 8004138:	681a      	ldr	r2, [r3, #0]
 800413a:	f241 5358 	movw	r3, #5464	; 0x1558
 800413e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004142:	601a      	str	r2, [r3, #0]
 8004144:	f241 5358 	movw	r3, #5464	; 0x1558
 8004148:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800414c:	681b      	ldr	r3, [r3, #0]
 800414e:	2b00      	cmp	r3, #0
 8004150:	d1cf      	bne.n	80040f2 <do_event+0xf6>
 8004152:	e021      	b.n	8004198 <do_event+0x19c>
    } else {
      /* This is not a broadcast event, so we deliver it to the
	 specified process. */
      /* If the event was an INIT event, we should also update the
	 state of the process. */
      if(ev == PROCESS_EVENT_INIT) {
 8004154:	f241 534e 	movw	r3, #5454	; 0x154e
 8004158:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800415c:	781b      	ldrb	r3, [r3, #0]
 800415e:	2b81      	cmp	r3, #129	; 0x81
 8004160:	d106      	bne.n	8004170 <do_event+0x174>
	receiver->state = PROCESS_STATE_RUNNING;
 8004162:	f241 5354 	movw	r3, #5460	; 0x1554
 8004166:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800416a:	681b      	ldr	r3, [r3, #0]
 800416c:	2201      	movs	r2, #1
 800416e:	739a      	strb	r2, [r3, #14]
      }

      /* Make sure that the process actually is running. */
      call_process(receiver, ev, data);
 8004170:	f241 5354 	movw	r3, #5460	; 0x1554
 8004174:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004178:	6819      	ldr	r1, [r3, #0]
 800417a:	f241 534e 	movw	r3, #5454	; 0x154e
 800417e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004182:	781a      	ldrb	r2, [r3, #0]
 8004184:	f241 5350 	movw	r3, #5456	; 0x1550
 8004188:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800418c:	681b      	ldr	r3, [r3, #0]
 800418e:	4608      	mov	r0, r1
 8004190:	4611      	mov	r1, r2
 8004192:	461a      	mov	r2, r3
 8004194:	f7ff fe8e 	bl	8003eb4 <call_process>
    }
  }
}
 8004198:	bd80      	pop	{r7, pc}
 800419a:	bf00      	nop

0800419c <process_run>:
/*---------------------------------------------------------------------------*/
int
process_run(void)
{
 800419c:	b580      	push	{r7, lr}
 800419e:	af00      	add	r7, sp, #0
  /* Process poll events. */
  if(poll_requested) {
 80041a0:	f241 534c 	movw	r3, #5452	; 0x154c
 80041a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80041a8:	781b      	ldrb	r3, [r3, #0]
 80041aa:	b2db      	uxtb	r3, r3
 80041ac:	2b00      	cmp	r3, #0
 80041ae:	d001      	beq.n	80041b4 <process_run+0x18>
    do_poll();
 80041b0:	f7ff fefa 	bl	8003fa8 <do_poll>
  }

  /* Process one event from the queue */
  do_event();
 80041b4:	f7ff ff22 	bl	8003ffc <do_event>

  return nevents + poll_requested;
 80041b8:	f241 33c9 	movw	r3, #5065	; 0x13c9
 80041bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80041c0:	781b      	ldrb	r3, [r3, #0]
 80041c2:	461a      	mov	r2, r3
 80041c4:	f241 534c 	movw	r3, #5452	; 0x154c
 80041c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80041cc:	781b      	ldrb	r3, [r3, #0]
 80041ce:	b2db      	uxtb	r3, r3
 80041d0:	18d3      	adds	r3, r2, r3
}
 80041d2:	4618      	mov	r0, r3
 80041d4:	bd80      	pop	{r7, pc}
 80041d6:	bf00      	nop

080041d8 <process_post>:
  return nevents + poll_requested;
}
/*---------------------------------------------------------------------------*/
int
process_post(struct process *p, process_event_t ev, process_data_t data)
{
 80041d8:	b480      	push	{r7}
 80041da:	b085      	sub	sp, #20
 80041dc:	af00      	add	r7, sp, #0
 80041de:	60f8      	str	r0, [r7, #12]
 80041e0:	460b      	mov	r3, r1
 80041e2:	607a      	str	r2, [r7, #4]
 80041e4:	72fb      	strb	r3, [r7, #11]
    PRINTF("process_post: Process '%s' posts event %d to process '%s', nevents %d\n",
	   PROCESS_NAME_STRING(PROCESS_CURRENT()), ev,
	   p == PROCESS_BROADCAST? "<broadcast>": PROCESS_NAME_STRING(p), nevents);
  }
  
  if(nevents == PROCESS_CONF_NUMEVENTS) {
 80041e6:	f241 33c9 	movw	r3, #5065	; 0x13c9
 80041ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80041ee:	781b      	ldrb	r3, [r3, #0]
 80041f0:	2b20      	cmp	r3, #32
 80041f2:	d101      	bne.n	80041f8 <process_post+0x20>
      printf("soft panic: event queue is full when broadcast event %d was posted from %s\n", ev, PROCESS_NAME_STRING(process_current));
    } else {
      printf("soft panic: event queue is full when event %d was posted to %s frpm %s\n", ev, PROCESS_NAME_STRING(p), PROCESS_NAME_STRING(process_current));
    }
#endif /* DEBUG */
    return PROCESS_ERR_FULL;
 80041f4:	2301      	movs	r3, #1
 80041f6:	e055      	b.n	80042a4 <process_post+0xcc>
  }
  
  snum = (process_num_events_t)(fevent + nevents) % PROCESS_CONF_NUMEVENTS;
 80041f8:	f241 33ca 	movw	r3, #5066	; 0x13ca
 80041fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004200:	781a      	ldrb	r2, [r3, #0]
 8004202:	f241 33c9 	movw	r3, #5065	; 0x13c9
 8004206:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800420a:	781b      	ldrb	r3, [r3, #0]
 800420c:	18d3      	adds	r3, r2, r3
 800420e:	b2db      	uxtb	r3, r3
 8004210:	f003 031f 	and.w	r3, r3, #31
 8004214:	b2da      	uxtb	r2, r3
 8004216:	f241 534d 	movw	r3, #5453	; 0x154d
 800421a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800421e:	701a      	strb	r2, [r3, #0]
  events[snum].ev = ev;
 8004220:	f241 534d 	movw	r3, #5453	; 0x154d
 8004224:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004228:	781b      	ldrb	r3, [r3, #0]
 800422a:	4619      	mov	r1, r3
 800422c:	f241 32cc 	movw	r2, #5068	; 0x13cc
 8004230:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004234:	460b      	mov	r3, r1
 8004236:	005b      	lsls	r3, r3, #1
 8004238:	185b      	adds	r3, r3, r1
 800423a:	009b      	lsls	r3, r3, #2
 800423c:	18d3      	adds	r3, r2, r3
 800423e:	7afa      	ldrb	r2, [r7, #11]
 8004240:	701a      	strb	r2, [r3, #0]
  events[snum].data = data;
 8004242:	f241 534d 	movw	r3, #5453	; 0x154d
 8004246:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800424a:	781b      	ldrb	r3, [r3, #0]
 800424c:	4619      	mov	r1, r3
 800424e:	f241 32cc 	movw	r2, #5068	; 0x13cc
 8004252:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004256:	460b      	mov	r3, r1
 8004258:	005b      	lsls	r3, r3, #1
 800425a:	185b      	adds	r3, r3, r1
 800425c:	009b      	lsls	r3, r3, #2
 800425e:	18d3      	adds	r3, r2, r3
 8004260:	3304      	adds	r3, #4
 8004262:	687a      	ldr	r2, [r7, #4]
 8004264:	601a      	str	r2, [r3, #0]
  events[snum].p = p;
 8004266:	f241 534d 	movw	r3, #5453	; 0x154d
 800426a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800426e:	781b      	ldrb	r3, [r3, #0]
 8004270:	4619      	mov	r1, r3
 8004272:	f241 32cc 	movw	r2, #5068	; 0x13cc
 8004276:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800427a:	460b      	mov	r3, r1
 800427c:	005b      	lsls	r3, r3, #1
 800427e:	185b      	adds	r3, r3, r1
 8004280:	009b      	lsls	r3, r3, #2
 8004282:	18d3      	adds	r3, r2, r3
 8004284:	3308      	adds	r3, #8
 8004286:	68fa      	ldr	r2, [r7, #12]
 8004288:	601a      	str	r2, [r3, #0]
  ++nevents;
 800428a:	f241 33c9 	movw	r3, #5065	; 0x13c9
 800428e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004292:	781b      	ldrb	r3, [r3, #0]
 8004294:	3301      	adds	r3, #1
 8004296:	b2da      	uxtb	r2, r3
 8004298:	f241 33c9 	movw	r3, #5065	; 0x13c9
 800429c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80042a0:	701a      	strb	r2, [r3, #0]
  if(nevents > process_maxevents) {
    process_maxevents = nevents;
  }
#endif /* PROCESS_CONF_STATS */
  
  return PROCESS_ERR_OK;
 80042a2:	2300      	movs	r3, #0
}
 80042a4:	4618      	mov	r0, r3
 80042a6:	f107 0714 	add.w	r7, r7, #20
 80042aa:	46bd      	mov	sp, r7
 80042ac:	bc80      	pop	{r7}
 80042ae:	4770      	bx	lr

080042b0 <process_post_synch>:
/*---------------------------------------------------------------------------*/
void
process_post_synch(struct process *p, process_event_t ev, process_data_t data)
{
 80042b0:	b580      	push	{r7, lr}
 80042b2:	b086      	sub	sp, #24
 80042b4:	af00      	add	r7, sp, #0
 80042b6:	60f8      	str	r0, [r7, #12]
 80042b8:	460b      	mov	r3, r1
 80042ba:	607a      	str	r2, [r7, #4]
 80042bc:	72fb      	strb	r3, [r7, #11]
  struct process *caller = process_current;
 80042be:	f241 33c4 	movw	r3, #5060	; 0x13c4
 80042c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80042c6:	681b      	ldr	r3, [r3, #0]
 80042c8:	617b      	str	r3, [r7, #20]

  call_process(p, ev, data);
 80042ca:	7afb      	ldrb	r3, [r7, #11]
 80042cc:	68f8      	ldr	r0, [r7, #12]
 80042ce:	4619      	mov	r1, r3
 80042d0:	687a      	ldr	r2, [r7, #4]
 80042d2:	f7ff fdef 	bl	8003eb4 <call_process>
  process_current = caller;
 80042d6:	f241 33c4 	movw	r3, #5060	; 0x13c4
 80042da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80042de:	697a      	ldr	r2, [r7, #20]
 80042e0:	601a      	str	r2, [r3, #0]
}
 80042e2:	f107 0718 	add.w	r7, r7, #24
 80042e6:	46bd      	mov	sp, r7
 80042e8:	bd80      	pop	{r7, pc}
 80042ea:	bf00      	nop

080042ec <process_poll>:
/*---------------------------------------------------------------------------*/
void
process_poll(struct process *p)
{
 80042ec:	b480      	push	{r7}
 80042ee:	b083      	sub	sp, #12
 80042f0:	af00      	add	r7, sp, #0
 80042f2:	6078      	str	r0, [r7, #4]
  if(p != NULL) {
 80042f4:	687b      	ldr	r3, [r7, #4]
 80042f6:	2b00      	cmp	r3, #0
 80042f8:	d010      	beq.n	800431c <process_poll+0x30>
    if(p->state == PROCESS_STATE_RUNNING ||
 80042fa:	687b      	ldr	r3, [r7, #4]
 80042fc:	7b9b      	ldrb	r3, [r3, #14]
 80042fe:	2b01      	cmp	r3, #1
 8004300:	d003      	beq.n	800430a <process_poll+0x1e>
       p->state == PROCESS_STATE_CALLED) {
 8004302:	687b      	ldr	r3, [r7, #4]
 8004304:	7b9b      	ldrb	r3, [r3, #14]
/*---------------------------------------------------------------------------*/
void
process_poll(struct process *p)
{
  if(p != NULL) {
    if(p->state == PROCESS_STATE_RUNNING ||
 8004306:	2b02      	cmp	r3, #2
 8004308:	d108      	bne.n	800431c <process_poll+0x30>
       p->state == PROCESS_STATE_CALLED) {
      p->needspoll = 1;
 800430a:	687b      	ldr	r3, [r7, #4]
 800430c:	2201      	movs	r2, #1
 800430e:	73da      	strb	r2, [r3, #15]
      poll_requested = 1;
 8004310:	f241 534c 	movw	r3, #5452	; 0x154c
 8004314:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004318:	2201      	movs	r2, #1
 800431a:	701a      	strb	r2, [r3, #0]
    }
  }
}
 800431c:	f107 070c 	add.w	r7, r7, #12
 8004320:	46bd      	mov	sp, r7
 8004322:	bc80      	pop	{r7}
 8004324:	4770      	bx	lr
 8004326:	bf00      	nop

08004328 <process_is_running>:
/*---------------------------------------------------------------------------*/
int
process_is_running(struct process *p)
{
 8004328:	b480      	push	{r7}
 800432a:	b083      	sub	sp, #12
 800432c:	af00      	add	r7, sp, #0
 800432e:	6078      	str	r0, [r7, #4]
  return p->state != PROCESS_STATE_NONE;
 8004330:	687b      	ldr	r3, [r7, #4]
 8004332:	7b9b      	ldrb	r3, [r3, #14]
 8004334:	2b00      	cmp	r3, #0
 8004336:	bf0c      	ite	eq
 8004338:	2300      	moveq	r3, #0
 800433a:	2301      	movne	r3, #1
 800433c:	b2db      	uxtb	r3, r3
}
 800433e:	4618      	mov	r0, r3
 8004340:	f107 070c 	add.w	r7, r7, #12
 8004344:	46bd      	mov	sp, r7
 8004346:	bc80      	pop	{r7}
 8004348:	4770      	bx	lr
 800434a:	bf00      	nop

0800434c <autostart_start>:
#endif

/*---------------------------------------------------------------------------*/
void
autostart_start(struct process * const processes[])
{
 800434c:	b580      	push	{r7, lr}
 800434e:	b084      	sub	sp, #16
 8004350:	af00      	add	r7, sp, #0
 8004352:	6078      	str	r0, [r7, #4]
  int i;
  
  for(i = 0; processes[i] != NULL; ++i) {
 8004354:	2300      	movs	r3, #0
 8004356:	60fb      	str	r3, [r7, #12]
 8004358:	e00b      	b.n	8004372 <autostart_start+0x26>
    process_start(processes[i], NULL);
 800435a:	68fb      	ldr	r3, [r7, #12]
 800435c:	009b      	lsls	r3, r3, #2
 800435e:	687a      	ldr	r2, [r7, #4]
 8004360:	18d3      	adds	r3, r2, r3
 8004362:	681b      	ldr	r3, [r3, #0]
 8004364:	4618      	mov	r0, r3
 8004366:	2100      	movs	r1, #0
 8004368:	f7ff fcf2 	bl	8003d50 <process_start>
void
autostart_start(struct process * const processes[])
{
  int i;
  
  for(i = 0; processes[i] != NULL; ++i) {
 800436c:	68fb      	ldr	r3, [r7, #12]
 800436e:	3301      	adds	r3, #1
 8004370:	60fb      	str	r3, [r7, #12]
 8004372:	68fb      	ldr	r3, [r7, #12]
 8004374:	009b      	lsls	r3, r3, #2
 8004376:	687a      	ldr	r2, [r7, #4]
 8004378:	18d3      	adds	r3, r2, r3
 800437a:	681b      	ldr	r3, [r3, #0]
 800437c:	2b00      	cmp	r3, #0
 800437e:	d1ec      	bne.n	800435a <autostart_start+0xe>
    process_start(processes[i], NULL);
    PRINTF("autostart_start: starting process '%s'\n", processes[i]->name);
  }
}
 8004380:	f107 0710 	add.w	r7, r7, #16
 8004384:	46bd      	mov	sp, r7
 8004386:	bd80      	pop	{r7, pc}

08004388 <list_init>:
 *
 * \param list The list to be initialized.
 */
void
list_init(list_t list)
{
 8004388:	b480      	push	{r7}
 800438a:	b083      	sub	sp, #12
 800438c:	af00      	add	r7, sp, #0
 800438e:	6078      	str	r0, [r7, #4]
  *list = NULL;
 8004390:	687b      	ldr	r3, [r7, #4]
 8004392:	2200      	movs	r2, #0
 8004394:	601a      	str	r2, [r3, #0]
}
 8004396:	f107 070c 	add.w	r7, r7, #12
 800439a:	46bd      	mov	sp, r7
 800439c:	bc80      	pop	{r7}
 800439e:	4770      	bx	lr

080043a0 <list_head>:
 *
 * \sa list_tail()
 */
void *
list_head(list_t list)
{
 80043a0:	b480      	push	{r7}
 80043a2:	b083      	sub	sp, #12
 80043a4:	af00      	add	r7, sp, #0
 80043a6:	6078      	str	r0, [r7, #4]
  return *list;
 80043a8:	687b      	ldr	r3, [r7, #4]
 80043aa:	681b      	ldr	r3, [r3, #0]
}
 80043ac:	4618      	mov	r0, r3
 80043ae:	f107 070c 	add.w	r7, r7, #12
 80043b2:	46bd      	mov	sp, r7
 80043b4:	bc80      	pop	{r7}
 80043b6:	4770      	bx	lr

080043b8 <list_tail>:
 *
 * \sa list_head()
 */
void *
list_tail(list_t list)
{
 80043b8:	b480      	push	{r7}
 80043ba:	b085      	sub	sp, #20
 80043bc:	af00      	add	r7, sp, #0
 80043be:	6078      	str	r0, [r7, #4]
  struct list *l;
  
  if(*list == NULL) {
 80043c0:	687b      	ldr	r3, [r7, #4]
 80043c2:	681b      	ldr	r3, [r3, #0]
 80043c4:	2b00      	cmp	r3, #0
 80043c6:	d101      	bne.n	80043cc <list_tail+0x14>
    return NULL;
 80043c8:	2300      	movs	r3, #0
 80043ca:	e00b      	b.n	80043e4 <list_tail+0x2c>
  }
  
  for(l = *list; l->next != NULL; l = l->next);
 80043cc:	687b      	ldr	r3, [r7, #4]
 80043ce:	681b      	ldr	r3, [r3, #0]
 80043d0:	60fb      	str	r3, [r7, #12]
 80043d2:	e002      	b.n	80043da <list_tail+0x22>
 80043d4:	68fb      	ldr	r3, [r7, #12]
 80043d6:	681b      	ldr	r3, [r3, #0]
 80043d8:	60fb      	str	r3, [r7, #12]
 80043da:	68fb      	ldr	r3, [r7, #12]
 80043dc:	681b      	ldr	r3, [r3, #0]
 80043de:	2b00      	cmp	r3, #0
 80043e0:	d1f8      	bne.n	80043d4 <list_tail+0x1c>
  
  return l;
 80043e2:	68fb      	ldr	r3, [r7, #12]
}
 80043e4:	4618      	mov	r0, r3
 80043e6:	f107 0714 	add.w	r7, r7, #20
 80043ea:	46bd      	mov	sp, r7
 80043ec:	bc80      	pop	{r7}
 80043ee:	4770      	bx	lr

080043f0 <list_add>:
 * \sa list_push()
 *
 */
void
list_add(list_t list, void *item)
{
 80043f0:	b580      	push	{r7, lr}
 80043f2:	b084      	sub	sp, #16
 80043f4:	af00      	add	r7, sp, #0
 80043f6:	6078      	str	r0, [r7, #4]
 80043f8:	6039      	str	r1, [r7, #0]
  struct list *l;

  /* Make sure not to add the same element twice */
  list_remove(list, item);
 80043fa:	6878      	ldr	r0, [r7, #4]
 80043fc:	6839      	ldr	r1, [r7, #0]
 80043fe:	f000 f829 	bl	8004454 <list_remove>

  ((struct list *)item)->next = NULL;
 8004402:	683b      	ldr	r3, [r7, #0]
 8004404:	2200      	movs	r2, #0
 8004406:	601a      	str	r2, [r3, #0]
  
  l = list_tail(list);
 8004408:	6878      	ldr	r0, [r7, #4]
 800440a:	f7ff ffd5 	bl	80043b8 <list_tail>
 800440e:	60f8      	str	r0, [r7, #12]

  if(l == NULL) {
 8004410:	68fb      	ldr	r3, [r7, #12]
 8004412:	2b00      	cmp	r3, #0
 8004414:	d103      	bne.n	800441e <list_add+0x2e>
    *list = item;
 8004416:	687b      	ldr	r3, [r7, #4]
 8004418:	683a      	ldr	r2, [r7, #0]
 800441a:	601a      	str	r2, [r3, #0]
 800441c:	e002      	b.n	8004424 <list_add+0x34>
  } else {
    l->next = item;
 800441e:	68fb      	ldr	r3, [r7, #12]
 8004420:	683a      	ldr	r2, [r7, #0]
 8004422:	601a      	str	r2, [r3, #0]
  }
}
 8004424:	f107 0710 	add.w	r7, r7, #16
 8004428:	46bd      	mov	sp, r7
 800442a:	bd80      	pop	{r7, pc}

0800442c <list_push>:
/**
 * Add an item to the start of the list.
 */
void
list_push(list_t list, void *item)
{
 800442c:	b580      	push	{r7, lr}
 800442e:	b082      	sub	sp, #8
 8004430:	af00      	add	r7, sp, #0
 8004432:	6078      	str	r0, [r7, #4]
 8004434:	6039      	str	r1, [r7, #0]
  /*  struct list *l;*/

  /* Make sure not to add the same element twice */
  list_remove(list, item);
 8004436:	6878      	ldr	r0, [r7, #4]
 8004438:	6839      	ldr	r1, [r7, #0]
 800443a:	f000 f80b 	bl	8004454 <list_remove>

  ((struct list *)item)->next = *list;
 800443e:	687b      	ldr	r3, [r7, #4]
 8004440:	681a      	ldr	r2, [r3, #0]
 8004442:	683b      	ldr	r3, [r7, #0]
 8004444:	601a      	str	r2, [r3, #0]
  *list = item;
 8004446:	687b      	ldr	r3, [r7, #4]
 8004448:	683a      	ldr	r2, [r7, #0]
 800444a:	601a      	str	r2, [r3, #0]
}
 800444c:	f107 0708 	add.w	r7, r7, #8
 8004450:	46bd      	mov	sp, r7
 8004452:	bd80      	pop	{r7, pc}

08004454 <list_remove>:
 *
 */
/*---------------------------------------------------------------------------*/
void
list_remove(list_t list, void *item)
{
 8004454:	b480      	push	{r7}
 8004456:	b085      	sub	sp, #20
 8004458:	af00      	add	r7, sp, #0
 800445a:	6078      	str	r0, [r7, #4]
 800445c:	6039      	str	r1, [r7, #0]
  struct list *l, *r;
  
  if(*list == NULL) {
 800445e:	687b      	ldr	r3, [r7, #4]
 8004460:	681b      	ldr	r3, [r3, #0]
 8004462:	2b00      	cmp	r3, #0
 8004464:	d022      	beq.n	80044ac <list_remove+0x58>
    return;
  }
  
  r = NULL;
 8004466:	2300      	movs	r3, #0
 8004468:	60bb      	str	r3, [r7, #8]
  for(l = *list; l != NULL; l = l->next) {
 800446a:	687b      	ldr	r3, [r7, #4]
 800446c:	681b      	ldr	r3, [r3, #0]
 800446e:	60fb      	str	r3, [r7, #12]
 8004470:	e018      	b.n	80044a4 <list_remove+0x50>
    if(l == item) {
 8004472:	68fa      	ldr	r2, [r7, #12]
 8004474:	683b      	ldr	r3, [r7, #0]
 8004476:	429a      	cmp	r2, r3
 8004478:	d10f      	bne.n	800449a <list_remove+0x46>
      if(r == NULL) {
 800447a:	68bb      	ldr	r3, [r7, #8]
 800447c:	2b00      	cmp	r3, #0
 800447e:	d104      	bne.n	800448a <list_remove+0x36>
	/* First on list */
	*list = l->next;
 8004480:	68fb      	ldr	r3, [r7, #12]
 8004482:	681a      	ldr	r2, [r3, #0]
 8004484:	687b      	ldr	r3, [r7, #4]
 8004486:	601a      	str	r2, [r3, #0]
 8004488:	e003      	b.n	8004492 <list_remove+0x3e>
      } else {
	/* Not first on list */
	r->next = l->next;
 800448a:	68fb      	ldr	r3, [r7, #12]
 800448c:	681a      	ldr	r2, [r3, #0]
 800448e:	68bb      	ldr	r3, [r7, #8]
 8004490:	601a      	str	r2, [r3, #0]
      }
      l->next = NULL;
 8004492:	68fb      	ldr	r3, [r7, #12]
 8004494:	2200      	movs	r2, #0
 8004496:	601a      	str	r2, [r3, #0]
      return;
 8004498:	e009      	b.n	80044ae <list_remove+0x5a>
    }
    r = l;
 800449a:	68fb      	ldr	r3, [r7, #12]
 800449c:	60bb      	str	r3, [r7, #8]
  if(*list == NULL) {
    return;
  }
  
  r = NULL;
  for(l = *list; l != NULL; l = l->next) {
 800449e:	68fb      	ldr	r3, [r7, #12]
 80044a0:	681b      	ldr	r3, [r3, #0]
 80044a2:	60fb      	str	r3, [r7, #12]
 80044a4:	68fb      	ldr	r3, [r7, #12]
 80044a6:	2b00      	cmp	r3, #0
 80044a8:	d1e3      	bne.n	8004472 <list_remove+0x1e>
 80044aa:	e000      	b.n	80044ae <list_remove+0x5a>
list_remove(list_t list, void *item)
{
  struct list *l, *r;
  
  if(*list == NULL) {
    return;
 80044ac:	bf00      	nop
      l->next = NULL;
      return;
    }
    r = l;
  }
}
 80044ae:	f107 0714 	add.w	r7, r7, #20
 80044b2:	46bd      	mov	sp, r7
 80044b4:	bc80      	pop	{r7}
 80044b6:	4770      	bx	lr

080044b8 <list_insert>:
 *             start of the list.
 *
 */
void
list_insert(list_t list, void *previtem, void *newitem)
{
 80044b8:	b580      	push	{r7, lr}
 80044ba:	b084      	sub	sp, #16
 80044bc:	af00      	add	r7, sp, #0
 80044be:	60f8      	str	r0, [r7, #12]
 80044c0:	60b9      	str	r1, [r7, #8]
 80044c2:	607a      	str	r2, [r7, #4]
  if(previtem == NULL) {
 80044c4:	68bb      	ldr	r3, [r7, #8]
 80044c6:	2b00      	cmp	r3, #0
 80044c8:	d104      	bne.n	80044d4 <list_insert+0x1c>
    list_push(list, newitem);
 80044ca:	68f8      	ldr	r0, [r7, #12]
 80044cc:	6879      	ldr	r1, [r7, #4]
 80044ce:	f7ff ffad 	bl	800442c <list_push>
 80044d2:	e006      	b.n	80044e2 <list_insert+0x2a>
  } else {
  
    ((struct list *)newitem)->next = ((struct list *)previtem)->next;
 80044d4:	68bb      	ldr	r3, [r7, #8]
 80044d6:	681a      	ldr	r2, [r3, #0]
 80044d8:	687b      	ldr	r3, [r7, #4]
 80044da:	601a      	str	r2, [r3, #0]
    ((struct list *)previtem)->next = newitem;
 80044dc:	68bb      	ldr	r3, [r7, #8]
 80044de:	687a      	ldr	r2, [r7, #4]
 80044e0:	601a      	str	r2, [r3, #0]
  }
}
 80044e2:	f107 0710 	add.w	r7, r7, #16
 80044e6:	46bd      	mov	sp, r7
 80044e8:	bd80      	pop	{r7, pc}
 80044ea:	bf00      	nop

080044ec <update_time>:

PROCESS(etimer_process, "Event timer");
/*---------------------------------------------------------------------------*/
static void
update_time(void)
{
 80044ec:	b580      	push	{r7, lr}
 80044ee:	b084      	sub	sp, #16
 80044f0:	af00      	add	r7, sp, #0
  clock_time_t tdist;
  clock_time_t now;
  struct etimer *t;

  if (timerlist == NULL) {
 80044f2:	f241 535c 	movw	r3, #5468	; 0x155c
 80044f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80044fa:	681b      	ldr	r3, [r3, #0]
 80044fc:	2b00      	cmp	r3, #0
 80044fe:	d106      	bne.n	800450e <update_time+0x22>
    next_expiration = 0;
 8004500:	f241 5360 	movw	r3, #5472	; 0x1560
 8004504:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004508:	2200      	movs	r2, #0
 800450a:	601a      	str	r2, [r3, #0]
 800450c:	e034      	b.n	8004578 <update_time+0x8c>
  } else {
    now = clock_time();
 800450e:	f7fe fe9b 	bl	8003248 <clock_time>
 8004512:	6078      	str	r0, [r7, #4]
    t = timerlist;
 8004514:	f241 535c 	movw	r3, #5468	; 0x155c
 8004518:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800451c:	681b      	ldr	r3, [r3, #0]
 800451e:	60bb      	str	r3, [r7, #8]
    /* Must calculate distance to next time into account due to wraps */
    tdist = t->timer.start + t->timer.interval - now;
 8004520:	68bb      	ldr	r3, [r7, #8]
 8004522:	681a      	ldr	r2, [r3, #0]
 8004524:	68bb      	ldr	r3, [r7, #8]
 8004526:	685b      	ldr	r3, [r3, #4]
 8004528:	18d2      	adds	r2, r2, r3
 800452a:	687b      	ldr	r3, [r7, #4]
 800452c:	1ad3      	subs	r3, r2, r3
 800452e:	60fb      	str	r3, [r7, #12]
    for(t = t->next; t != NULL; t = t->next) {
 8004530:	68bb      	ldr	r3, [r7, #8]
 8004532:	689b      	ldr	r3, [r3, #8]
 8004534:	60bb      	str	r3, [r7, #8]
 8004536:	e014      	b.n	8004562 <update_time+0x76>
      if(t->timer.start + t->timer.interval - now < tdist) {
 8004538:	68bb      	ldr	r3, [r7, #8]
 800453a:	681a      	ldr	r2, [r3, #0]
 800453c:	68bb      	ldr	r3, [r7, #8]
 800453e:	685b      	ldr	r3, [r3, #4]
 8004540:	18d2      	adds	r2, r2, r3
 8004542:	687b      	ldr	r3, [r7, #4]
 8004544:	1ad2      	subs	r2, r2, r3
 8004546:	68fb      	ldr	r3, [r7, #12]
 8004548:	429a      	cmp	r2, r3
 800454a:	d207      	bcs.n	800455c <update_time+0x70>
	tdist = t->timer.start + t->timer.interval - now;
 800454c:	68bb      	ldr	r3, [r7, #8]
 800454e:	681a      	ldr	r2, [r3, #0]
 8004550:	68bb      	ldr	r3, [r7, #8]
 8004552:	685b      	ldr	r3, [r3, #4]
 8004554:	18d2      	adds	r2, r2, r3
 8004556:	687b      	ldr	r3, [r7, #4]
 8004558:	1ad3      	subs	r3, r2, r3
 800455a:	60fb      	str	r3, [r7, #12]
  } else {
    now = clock_time();
    t = timerlist;
    /* Must calculate distance to next time into account due to wraps */
    tdist = t->timer.start + t->timer.interval - now;
    for(t = t->next; t != NULL; t = t->next) {
 800455c:	68bb      	ldr	r3, [r7, #8]
 800455e:	689b      	ldr	r3, [r3, #8]
 8004560:	60bb      	str	r3, [r7, #8]
 8004562:	68bb      	ldr	r3, [r7, #8]
 8004564:	2b00      	cmp	r3, #0
 8004566:	d1e7      	bne.n	8004538 <update_time+0x4c>
      if(t->timer.start + t->timer.interval - now < tdist) {
	tdist = t->timer.start + t->timer.interval - now;
      }
    }
    next_expiration = now + tdist;
 8004568:	687a      	ldr	r2, [r7, #4]
 800456a:	68fb      	ldr	r3, [r7, #12]
 800456c:	18d2      	adds	r2, r2, r3
 800456e:	f241 5360 	movw	r3, #5472	; 0x1560
 8004572:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004576:	601a      	str	r2, [r3, #0]
  }
}
 8004578:	f107 0710 	add.w	r7, r7, #16
 800457c:	46bd      	mov	sp, r7
 800457e:	bd80      	pop	{r7, pc}

08004580 <process_thread_etimer_process>:
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(etimer_process, ev, data)
{
 8004580:	b580      	push	{r7, lr}
 8004582:	b088      	sub	sp, #32
 8004584:	af00      	add	r7, sp, #0
 8004586:	60f8      	str	r0, [r7, #12]
 8004588:	460b      	mov	r3, r1
 800458a:	607a      	str	r2, [r7, #4]
 800458c:	72fb      	strb	r3, [r7, #11]
  struct etimer *t, *u;
	
  PROCESS_BEGIN();
 800458e:	2301      	movs	r3, #1
 8004590:	75fb      	strb	r3, [r7, #23]
 8004592:	68fb      	ldr	r3, [r7, #12]
 8004594:	881b      	ldrh	r3, [r3, #0]
 8004596:	2b00      	cmp	r3, #0
 8004598:	d002      	beq.n	80045a0 <process_thread_etimer_process+0x20>
 800459a:	2b5a      	cmp	r3, #90	; 0x5a
 800459c:	d00b      	beq.n	80045b6 <process_thread_etimer_process+0x36>
 800459e:	e096      	b.n	80046ce <process_thread_etimer_process+0x14e>

  timerlist = NULL;
 80045a0:	f241 535c 	movw	r3, #5468	; 0x155c
 80045a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80045a8:	2200      	movs	r2, #0
 80045aa:	601a      	str	r2, [r3, #0]
  
  while(1) {
    PROCESS_YIELD();
 80045ac:	2300      	movs	r3, #0
 80045ae:	75fb      	strb	r3, [r7, #23]
 80045b0:	68fb      	ldr	r3, [r7, #12]
 80045b2:	225a      	movs	r2, #90	; 0x5a
 80045b4:	801a      	strh	r2, [r3, #0]
 80045b6:	7dfb      	ldrb	r3, [r7, #23]
 80045b8:	2b00      	cmp	r3, #0
 80045ba:	d101      	bne.n	80045c0 <process_thread_etimer_process+0x40>
 80045bc:	2301      	movs	r3, #1
 80045be:	e08c      	b.n	80046da <process_thread_etimer_process+0x15a>

    if(ev == PROCESS_EVENT_EXITED) {
 80045c0:	7afb      	ldrb	r3, [r7, #11]
 80045c2:	2b87      	cmp	r3, #135	; 0x87
 80045c4:	d13f      	bne.n	8004646 <process_thread_etimer_process+0xc6>
      struct process *p = data;
 80045c6:	687b      	ldr	r3, [r7, #4]
 80045c8:	613b      	str	r3, [r7, #16]

      while(timerlist != NULL && timerlist->p == p) {
 80045ca:	e00a      	b.n	80045e2 <process_thread_etimer_process+0x62>
	timerlist = timerlist->next;
 80045cc:	f241 535c 	movw	r3, #5468	; 0x155c
 80045d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80045d4:	681b      	ldr	r3, [r3, #0]
 80045d6:	689a      	ldr	r2, [r3, #8]
 80045d8:	f241 535c 	movw	r3, #5468	; 0x155c
 80045dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80045e0:	601a      	str	r2, [r3, #0]
    PROCESS_YIELD();

    if(ev == PROCESS_EVENT_EXITED) {
      struct process *p = data;

      while(timerlist != NULL && timerlist->p == p) {
 80045e2:	f241 535c 	movw	r3, #5468	; 0x155c
 80045e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80045ea:	681b      	ldr	r3, [r3, #0]
 80045ec:	2b00      	cmp	r3, #0
 80045ee:	d008      	beq.n	8004602 <process_thread_etimer_process+0x82>
 80045f0:	f241 535c 	movw	r3, #5468	; 0x155c
 80045f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80045f8:	681b      	ldr	r3, [r3, #0]
 80045fa:	68da      	ldr	r2, [r3, #12]
 80045fc:	693b      	ldr	r3, [r7, #16]
 80045fe:	429a      	cmp	r2, r3
 8004600:	d0e4      	beq.n	80045cc <process_thread_etimer_process+0x4c>
	timerlist = timerlist->next;
      }

      if(timerlist != NULL) {
 8004602:	f241 535c 	movw	r3, #5468	; 0x155c
 8004606:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800460a:	681b      	ldr	r3, [r3, #0]
 800460c:	2b00      	cmp	r3, #0
 800460e:	d05a      	beq.n	80046c6 <process_thread_etimer_process+0x146>
	t = timerlist;
 8004610:	f241 535c 	movw	r3, #5468	; 0x155c
 8004614:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004618:	681b      	ldr	r3, [r3, #0]
 800461a:	61fb      	str	r3, [r7, #28]
	while(t->next != NULL) {
 800461c:	e00e      	b.n	800463c <process_thread_etimer_process+0xbc>
	  if(t->next->p == p) {
 800461e:	69fb      	ldr	r3, [r7, #28]
 8004620:	689b      	ldr	r3, [r3, #8]
 8004622:	68da      	ldr	r2, [r3, #12]
 8004624:	693b      	ldr	r3, [r7, #16]
 8004626:	429a      	cmp	r2, r3
 8004628:	d105      	bne.n	8004636 <process_thread_etimer_process+0xb6>
	    t->next = t->next->next;
 800462a:	69fb      	ldr	r3, [r7, #28]
 800462c:	689b      	ldr	r3, [r3, #8]
 800462e:	689a      	ldr	r2, [r3, #8]
 8004630:	69fb      	ldr	r3, [r7, #28]
 8004632:	609a      	str	r2, [r3, #8]
 8004634:	e002      	b.n	800463c <process_thread_etimer_process+0xbc>
	  } else
	    t = t->next;
 8004636:	69fb      	ldr	r3, [r7, #28]
 8004638:	689b      	ldr	r3, [r3, #8]
 800463a:	61fb      	str	r3, [r7, #28]
	timerlist = timerlist->next;
      }

      if(timerlist != NULL) {
	t = timerlist;
	while(t->next != NULL) {
 800463c:	69fb      	ldr	r3, [r7, #28]
 800463e:	689b      	ldr	r3, [r3, #8]
 8004640:	2b00      	cmp	r3, #0
 8004642:	d1ec      	bne.n	800461e <process_thread_etimer_process+0x9e>
	    t->next = t->next->next;
	  } else
	    t = t->next;
	}
      }
      continue;
 8004644:	e03f      	b.n	80046c6 <process_thread_etimer_process+0x146>
    } else if(ev != PROCESS_EVENT_POLL) {
 8004646:	7afb      	ldrb	r3, [r7, #11]
 8004648:	2b82      	cmp	r3, #130	; 0x82
 800464a:	d13e      	bne.n	80046ca <process_thread_etimer_process+0x14a>
      continue;
    }

  again:
    
    u = NULL;
 800464c:	2300      	movs	r3, #0
 800464e:	61bb      	str	r3, [r7, #24]
    
    for(t = timerlist; t != NULL; t = t->next) {
 8004650:	f241 535c 	movw	r3, #5468	; 0x155c
 8004654:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004658:	681b      	ldr	r3, [r3, #0]
 800465a:	61fb      	str	r3, [r7, #28]
 800465c:	e02f      	b.n	80046be <process_thread_etimer_process+0x13e>
      if(timer_expired(&t->timer)) {
 800465e:	69fb      	ldr	r3, [r7, #28]
 8004660:	4618      	mov	r0, r3
 8004662:	f003 fd55 	bl	8008110 <timer_expired>
 8004666:	4603      	mov	r3, r0
 8004668:	2b00      	cmp	r3, #0
 800466a:	d023      	beq.n	80046b4 <process_thread_etimer_process+0x134>
	if(process_post(t->p, PROCESS_EVENT_TIMER, t) == PROCESS_ERR_OK) {
 800466c:	69fb      	ldr	r3, [r7, #28]
 800466e:	68db      	ldr	r3, [r3, #12]
 8004670:	4618      	mov	r0, r3
 8004672:	2188      	movs	r1, #136	; 0x88
 8004674:	69fa      	ldr	r2, [r7, #28]
 8004676:	f7ff fdaf 	bl	80041d8 <process_post>
 800467a:	4603      	mov	r3, r0
 800467c:	2b00      	cmp	r3, #0
 800467e:	d117      	bne.n	80046b0 <process_thread_etimer_process+0x130>
	  
	  /* Reset the process ID of the event timer, to signal that the
	     etimer has expired. This is later checked in the
	     etimer_expired() function. */
	  t->p = PROCESS_NONE;
 8004680:	69fb      	ldr	r3, [r7, #28]
 8004682:	2200      	movs	r2, #0
 8004684:	60da      	str	r2, [r3, #12]
	  if(u != NULL) {
 8004686:	69bb      	ldr	r3, [r7, #24]
 8004688:	2b00      	cmp	r3, #0
 800468a:	d004      	beq.n	8004696 <process_thread_etimer_process+0x116>
	    u->next = t->next;
 800468c:	69fb      	ldr	r3, [r7, #28]
 800468e:	689a      	ldr	r2, [r3, #8]
 8004690:	69bb      	ldr	r3, [r7, #24]
 8004692:	609a      	str	r2, [r3, #8]
 8004694:	e006      	b.n	80046a4 <process_thread_etimer_process+0x124>
	  } else {
	    timerlist = t->next;
 8004696:	69fb      	ldr	r3, [r7, #28]
 8004698:	689a      	ldr	r2, [r3, #8]
 800469a:	f241 535c 	movw	r3, #5468	; 0x155c
 800469e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80046a2:	601a      	str	r2, [r3, #0]
	  }
	  t->next = NULL;
 80046a4:	69fb      	ldr	r3, [r7, #28]
 80046a6:	2200      	movs	r2, #0
 80046a8:	609a      	str	r2, [r3, #8]
	  update_time();
 80046aa:	f7ff ff1f 	bl	80044ec <update_time>
	  goto again;
 80046ae:	e7cd      	b.n	800464c <process_thread_etimer_process+0xcc>
	} else {
	  etimer_request_poll();
 80046b0:	f000 f818 	bl	80046e4 <etimer_request_poll>
	}
      }
      u = t;
 80046b4:	69fb      	ldr	r3, [r7, #28]
 80046b6:	61bb      	str	r3, [r7, #24]

  again:
    
    u = NULL;
    
    for(t = timerlist; t != NULL; t = t->next) {
 80046b8:	69fb      	ldr	r3, [r7, #28]
 80046ba:	689b      	ldr	r3, [r3, #8]
 80046bc:	61fb      	str	r3, [r7, #28]
 80046be:	69fb      	ldr	r3, [r7, #28]
 80046c0:	2b00      	cmp	r3, #0
 80046c2:	d1cc      	bne.n	800465e <process_thread_etimer_process+0xde>
	}
      }
      u = t;
    }
    
  }
 80046c4:	e772      	b.n	80045ac <process_thread_etimer_process+0x2c>
	    t->next = t->next->next;
	  } else
	    t = t->next;
	}
      }
      continue;
 80046c6:	bf00      	nop
 80046c8:	e000      	b.n	80046cc <process_thread_etimer_process+0x14c>
    } else if(ev != PROCESS_EVENT_POLL) {
      continue;
 80046ca:	bf00      	nop
	}
      }
      u = t;
    }
    
  }
 80046cc:	e76e      	b.n	80045ac <process_thread_etimer_process+0x2c>
  
  PROCESS_END();
 80046ce:	2300      	movs	r3, #0
 80046d0:	75fb      	strb	r3, [r7, #23]
 80046d2:	68fb      	ldr	r3, [r7, #12]
 80046d4:	2200      	movs	r2, #0
 80046d6:	801a      	strh	r2, [r3, #0]
 80046d8:	2303      	movs	r3, #3
}
 80046da:	4618      	mov	r0, r3
 80046dc:	f107 0720 	add.w	r7, r7, #32
 80046e0:	46bd      	mov	sp, r7
 80046e2:	bd80      	pop	{r7, pc}

080046e4 <etimer_request_poll>:
/*---------------------------------------------------------------------------*/
void
etimer_request_poll(void)
{
 80046e4:	b580      	push	{r7, lr}
 80046e6:	af00      	add	r7, sp, #0
  process_poll(&etimer_process);
 80046e8:	f640 002c 	movw	r0, #2092	; 0x82c
 80046ec:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80046f0:	f7ff fdfc 	bl	80042ec <process_poll>
}
 80046f4:	bd80      	pop	{r7, pc}
 80046f6:	bf00      	nop

080046f8 <add_timer>:
/*---------------------------------------------------------------------------*/
static void
add_timer(struct etimer *timer)
{
 80046f8:	b580      	push	{r7, lr}
 80046fa:	b084      	sub	sp, #16
 80046fc:	af00      	add	r7, sp, #0
 80046fe:	6078      	str	r0, [r7, #4]
  struct etimer *t;

  etimer_request_poll();
 8004700:	f7ff fff0 	bl	80046e4 <etimer_request_poll>

  if(timer->p != PROCESS_NONE) {
 8004704:	687b      	ldr	r3, [r7, #4]
 8004706:	68db      	ldr	r3, [r3, #12]
 8004708:	2b00      	cmp	r3, #0
 800470a:	d013      	beq.n	8004734 <add_timer+0x3c>
    /* Timer not on list. */
    
    for(t = timerlist; t != NULL; t = t->next) {
 800470c:	f241 535c 	movw	r3, #5468	; 0x155c
 8004710:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004714:	681b      	ldr	r3, [r3, #0]
 8004716:	60fb      	str	r3, [r7, #12]
 8004718:	e009      	b.n	800472e <add_timer+0x36>
      if(t == timer) {
 800471a:	68fa      	ldr	r2, [r7, #12]
 800471c:	687b      	ldr	r3, [r7, #4]
 800471e:	429a      	cmp	r2, r3
 8004720:	d102      	bne.n	8004728 <add_timer+0x30>
	/* Timer already on list, bail out. */
	update_time();
 8004722:	f7ff fee3 	bl	80044ec <update_time>
	return;
 8004726:	e01b      	b.n	8004760 <add_timer+0x68>
  etimer_request_poll();

  if(timer->p != PROCESS_NONE) {
    /* Timer not on list. */
    
    for(t = timerlist; t != NULL; t = t->next) {
 8004728:	68fb      	ldr	r3, [r7, #12]
 800472a:	689b      	ldr	r3, [r3, #8]
 800472c:	60fb      	str	r3, [r7, #12]
 800472e:	68fb      	ldr	r3, [r7, #12]
 8004730:	2b00      	cmp	r3, #0
 8004732:	d1f2      	bne.n	800471a <add_timer+0x22>
	return;
      }
    }
  }

  timer->p = PROCESS_CURRENT();
 8004734:	f241 33c4 	movw	r3, #5060	; 0x13c4
 8004738:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800473c:	681a      	ldr	r2, [r3, #0]
 800473e:	687b      	ldr	r3, [r7, #4]
 8004740:	60da      	str	r2, [r3, #12]
  timer->next = timerlist;
 8004742:	f241 535c 	movw	r3, #5468	; 0x155c
 8004746:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800474a:	681a      	ldr	r2, [r3, #0]
 800474c:	687b      	ldr	r3, [r7, #4]
 800474e:	609a      	str	r2, [r3, #8]
  timerlist = timer;
 8004750:	f241 535c 	movw	r3, #5468	; 0x155c
 8004754:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004758:	687a      	ldr	r2, [r7, #4]
 800475a:	601a      	str	r2, [r3, #0]

  update_time();
 800475c:	f7ff fec6 	bl	80044ec <update_time>
}
 8004760:	f107 0710 	add.w	r7, r7, #16
 8004764:	46bd      	mov	sp, r7
 8004766:	bd80      	pop	{r7, pc}

08004768 <etimer_set>:
/*---------------------------------------------------------------------------*/
void
etimer_set(struct etimer *et, clock_time_t interval)
{
 8004768:	b580      	push	{r7, lr}
 800476a:	b082      	sub	sp, #8
 800476c:	af00      	add	r7, sp, #0
 800476e:	6078      	str	r0, [r7, #4]
 8004770:	6039      	str	r1, [r7, #0]
  timer_set(&et->timer, interval);
 8004772:	687b      	ldr	r3, [r7, #4]
 8004774:	4618      	mov	r0, r3
 8004776:	6839      	ldr	r1, [r7, #0]
 8004778:	f003 fc9a 	bl	80080b0 <timer_set>
  add_timer(et);
 800477c:	6878      	ldr	r0, [r7, #4]
 800477e:	f7ff ffbb 	bl	80046f8 <add_timer>
}
 8004782:	f107 0708 	add.w	r7, r7, #8
 8004786:	46bd      	mov	sp, r7
 8004788:	bd80      	pop	{r7, pc}
 800478a:	bf00      	nop

0800478c <etimer_reset>:
/*---------------------------------------------------------------------------*/
void
etimer_reset(struct etimer *et)
{
 800478c:	b580      	push	{r7, lr}
 800478e:	b082      	sub	sp, #8
 8004790:	af00      	add	r7, sp, #0
 8004792:	6078      	str	r0, [r7, #4]
  timer_reset(&et->timer);
 8004794:	687b      	ldr	r3, [r7, #4]
 8004796:	4618      	mov	r0, r3
 8004798:	f003 fc9c 	bl	80080d4 <timer_reset>
  add_timer(et);
 800479c:	6878      	ldr	r0, [r7, #4]
 800479e:	f7ff ffab 	bl	80046f8 <add_timer>
}
 80047a2:	f107 0708 	add.w	r7, r7, #8
 80047a6:	46bd      	mov	sp, r7
 80047a8:	bd80      	pop	{r7, pc}
 80047aa:	bf00      	nop

080047ac <etimer_restart>:
/*---------------------------------------------------------------------------*/
void
etimer_restart(struct etimer *et)
{
 80047ac:	b580      	push	{r7, lr}
 80047ae:	b082      	sub	sp, #8
 80047b0:	af00      	add	r7, sp, #0
 80047b2:	6078      	str	r0, [r7, #4]
  timer_restart(&et->timer);
 80047b4:	687b      	ldr	r3, [r7, #4]
 80047b6:	4618      	mov	r0, r3
 80047b8:	f003 fc9c 	bl	80080f4 <timer_restart>
  add_timer(et);
 80047bc:	6878      	ldr	r0, [r7, #4]
 80047be:	f7ff ff9b 	bl	80046f8 <add_timer>
}
 80047c2:	f107 0708 	add.w	r7, r7, #8
 80047c6:	46bd      	mov	sp, r7
 80047c8:	bd80      	pop	{r7, pc}
 80047ca:	bf00      	nop

080047cc <etimer_expired>:
  update_time();
}
/*---------------------------------------------------------------------------*/
int
etimer_expired(struct etimer *et)
{
 80047cc:	b480      	push	{r7}
 80047ce:	b083      	sub	sp, #12
 80047d0:	af00      	add	r7, sp, #0
 80047d2:	6078      	str	r0, [r7, #4]
  return et->p == PROCESS_NONE;
 80047d4:	687b      	ldr	r3, [r7, #4]
 80047d6:	68db      	ldr	r3, [r3, #12]
 80047d8:	2b00      	cmp	r3, #0
 80047da:	bf14      	ite	ne
 80047dc:	2300      	movne	r3, #0
 80047de:	2301      	moveq	r3, #1
 80047e0:	b2db      	uxtb	r3, r3
}
 80047e2:	4618      	mov	r0, r3
 80047e4:	f107 070c 	add.w	r7, r7, #12
 80047e8:	46bd      	mov	sp, r7
 80047ea:	bc80      	pop	{r7}
 80047ec:	4770      	bx	lr
 80047ee:	bf00      	nop

080047f0 <etimer_pending>:
  return et->timer.start;
}
/*---------------------------------------------------------------------------*/
int
etimer_pending(void)
{
 80047f0:	b480      	push	{r7}
 80047f2:	af00      	add	r7, sp, #0
  return timerlist != NULL;
 80047f4:	f241 535c 	movw	r3, #5468	; 0x155c
 80047f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80047fc:	681b      	ldr	r3, [r3, #0]
 80047fe:	2b00      	cmp	r3, #0
 8004800:	bf0c      	ite	eq
 8004802:	2300      	moveq	r3, #0
 8004804:	2301      	movne	r3, #1
 8004806:	b2db      	uxtb	r3, r3
}
 8004808:	4618      	mov	r0, r3
 800480a:	46bd      	mov	sp, r7
 800480c:	bc80      	pop	{r7}
 800480e:	4770      	bx	lr

08004810 <process_thread_ctimer_process>:
#endif

/*---------------------------------------------------------------------------*/
PROCESS(ctimer_process, "Ctimer process");
PROCESS_THREAD(ctimer_process, ev, data)
{
 8004810:	b580      	push	{r7, lr}
 8004812:	b088      	sub	sp, #32
 8004814:	af00      	add	r7, sp, #0
 8004816:	60f8      	str	r0, [r7, #12]
 8004818:	460b      	mov	r3, r1
 800481a:	607a      	str	r2, [r7, #4]
 800481c:	72fb      	strb	r3, [r7, #11]
  struct ctimer *c;
  PROCESS_BEGIN();
 800481e:	2301      	movs	r3, #1
 8004820:	76fb      	strb	r3, [r7, #27]
 8004822:	68fb      	ldr	r3, [r7, #12]
 8004824:	881b      	ldrh	r3, [r3, #0]
 8004826:	2b00      	cmp	r3, #0
 8004828:	d002      	beq.n	8004830 <process_thread_ctimer_process+0x20>
 800482a:	2b4b      	cmp	r3, #75	; 0x4b
 800482c:	d023      	beq.n	8004876 <process_thread_ctimer_process+0x66>
 800482e:	e068      	b.n	8004902 <process_thread_ctimer_process+0xf2>

  for(c = list_head(ctimer_list); c != NULL; c = c->next) {
 8004830:	f640 033c 	movw	r3, #2108	; 0x83c
 8004834:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004838:	681b      	ldr	r3, [r3, #0]
 800483a:	4618      	mov	r0, r3
 800483c:	f7ff fdb0 	bl	80043a0 <list_head>
 8004840:	61f8      	str	r0, [r7, #28]
 8004842:	e00a      	b.n	800485a <process_thread_ctimer_process+0x4a>
    etimer_set(&c->etimer, c->etimer.timer.interval);
 8004844:	69fb      	ldr	r3, [r7, #28]
 8004846:	1d1a      	adds	r2, r3, #4
 8004848:	69fb      	ldr	r3, [r7, #28]
 800484a:	689b      	ldr	r3, [r3, #8]
 800484c:	4610      	mov	r0, r2
 800484e:	4619      	mov	r1, r3
 8004850:	f7ff ff8a 	bl	8004768 <etimer_set>
PROCESS_THREAD(ctimer_process, ev, data)
{
  struct ctimer *c;
  PROCESS_BEGIN();

  for(c = list_head(ctimer_list); c != NULL; c = c->next) {
 8004854:	69fb      	ldr	r3, [r7, #28]
 8004856:	681b      	ldr	r3, [r3, #0]
 8004858:	61fb      	str	r3, [r7, #28]
 800485a:	69fb      	ldr	r3, [r7, #28]
 800485c:	2b00      	cmp	r3, #0
 800485e:	d1f1      	bne.n	8004844 <process_thread_ctimer_process+0x34>
    etimer_set(&c->etimer, c->etimer.timer.interval);
  }
  initialized = 1;
 8004860:	f241 5368 	movw	r3, #5480	; 0x1568
 8004864:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004868:	2201      	movs	r2, #1
 800486a:	701a      	strb	r2, [r3, #0]

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_TIMER);
 800486c:	2300      	movs	r3, #0
 800486e:	76fb      	strb	r3, [r7, #27]
 8004870:	68fb      	ldr	r3, [r7, #12]
 8004872:	224b      	movs	r2, #75	; 0x4b
 8004874:	801a      	strh	r2, [r3, #0]
 8004876:	7efb      	ldrb	r3, [r7, #27]
 8004878:	2b00      	cmp	r3, #0
 800487a:	d002      	beq.n	8004882 <process_thread_ctimer_process+0x72>
 800487c:	7afb      	ldrb	r3, [r7, #11]
 800487e:	2b88      	cmp	r3, #136	; 0x88
 8004880:	d001      	beq.n	8004886 <process_thread_ctimer_process+0x76>
 8004882:	2301      	movs	r3, #1
 8004884:	e043      	b.n	800490e <process_thread_ctimer_process+0xfe>
    for(c = list_head(ctimer_list); c != NULL; c = c->next) {
 8004886:	f640 033c 	movw	r3, #2108	; 0x83c
 800488a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800488e:	681b      	ldr	r3, [r3, #0]
 8004890:	4618      	mov	r0, r3
 8004892:	f7ff fd85 	bl	80043a0 <list_head>
 8004896:	61f8      	str	r0, [r7, #28]
 8004898:	e02f      	b.n	80048fa <process_thread_ctimer_process+0xea>
      if(&c->etimer == data) {
 800489a:	69fb      	ldr	r3, [r7, #28]
 800489c:	1d1a      	adds	r2, r3, #4
 800489e:	687b      	ldr	r3, [r7, #4]
 80048a0:	429a      	cmp	r2, r3
 80048a2:	d127      	bne.n	80048f4 <process_thread_ctimer_process+0xe4>
	list_remove(ctimer_list, c);
 80048a4:	f640 033c 	movw	r3, #2108	; 0x83c
 80048a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80048ac:	681b      	ldr	r3, [r3, #0]
 80048ae:	4618      	mov	r0, r3
 80048b0:	69f9      	ldr	r1, [r7, #28]
 80048b2:	f7ff fdcf 	bl	8004454 <list_remove>
	PROCESS_CONTEXT_BEGIN(c->p);
 80048b6:	f241 33c4 	movw	r3, #5060	; 0x13c4
 80048ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80048be:	681b      	ldr	r3, [r3, #0]
 80048c0:	617b      	str	r3, [r7, #20]
 80048c2:	69fb      	ldr	r3, [r7, #28]
 80048c4:	695a      	ldr	r2, [r3, #20]
 80048c6:	f241 33c4 	movw	r3, #5060	; 0x13c4
 80048ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80048ce:	601a      	str	r2, [r3, #0]
	if(c->f != NULL) {
 80048d0:	69fb      	ldr	r3, [r7, #28]
 80048d2:	699b      	ldr	r3, [r3, #24]
 80048d4:	2b00      	cmp	r3, #0
 80048d6:	d005      	beq.n	80048e4 <process_thread_ctimer_process+0xd4>
	  c->f(c->ptr);
 80048d8:	69fb      	ldr	r3, [r7, #28]
 80048da:	699b      	ldr	r3, [r3, #24]
 80048dc:	69fa      	ldr	r2, [r7, #28]
 80048de:	69d2      	ldr	r2, [r2, #28]
 80048e0:	4610      	mov	r0, r2
 80048e2:	4798      	blx	r3
	}
	PROCESS_CONTEXT_END(c->p);
 80048e4:	f241 33c4 	movw	r3, #5060	; 0x13c4
 80048e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80048ec:	697a      	ldr	r2, [r7, #20]
 80048ee:	601a      	str	r2, [r3, #0]
	break;
 80048f0:	bf00      	nop
      }
    }
  }
 80048f2:	e7bb      	b.n	800486c <process_thread_ctimer_process+0x5c>
  }
  initialized = 1;

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_TIMER);
    for(c = list_head(ctimer_list); c != NULL; c = c->next) {
 80048f4:	69fb      	ldr	r3, [r7, #28]
 80048f6:	681b      	ldr	r3, [r3, #0]
 80048f8:	61fb      	str	r3, [r7, #28]
 80048fa:	69fb      	ldr	r3, [r7, #28]
 80048fc:	2b00      	cmp	r3, #0
 80048fe:	d1cc      	bne.n	800489a <process_thread_ctimer_process+0x8a>
	}
	PROCESS_CONTEXT_END(c->p);
	break;
      }
    }
  }
 8004900:	e7b4      	b.n	800486c <process_thread_ctimer_process+0x5c>
  PROCESS_END();
 8004902:	2300      	movs	r3, #0
 8004904:	76fb      	strb	r3, [r7, #27]
 8004906:	68fb      	ldr	r3, [r7, #12]
 8004908:	2200      	movs	r2, #0
 800490a:	801a      	strh	r2, [r3, #0]
 800490c:	2303      	movs	r3, #3
}
 800490e:	4618      	mov	r0, r3
 8004910:	f107 0720 	add.w	r7, r7, #32
 8004914:	46bd      	mov	sp, r7
 8004916:	bd80      	pop	{r7, pc}

08004918 <ctimer_init>:
/*---------------------------------------------------------------------------*/
void
ctimer_init(void)
{
 8004918:	b580      	push	{r7, lr}
 800491a:	af00      	add	r7, sp, #0
  initialized = 0;
 800491c:	f241 5368 	movw	r3, #5480	; 0x1568
 8004920:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004924:	2200      	movs	r2, #0
 8004926:	701a      	strb	r2, [r3, #0]
  list_init(ctimer_list);
 8004928:	f640 033c 	movw	r3, #2108	; 0x83c
 800492c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004930:	681b      	ldr	r3, [r3, #0]
 8004932:	4618      	mov	r0, r3
 8004934:	f7ff fd28 	bl	8004388 <list_init>
  process_start(&ctimer_process, NULL);
 8004938:	f640 0040 	movw	r0, #2112	; 0x840
 800493c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004940:	2100      	movs	r1, #0
 8004942:	f7ff fa05 	bl	8003d50 <process_start>
}
 8004946:	bd80      	pop	{r7, pc}

08004948 <random_rand>:
  srand(seed);
}
/*---------------------------------------------------------------------------*/
unsigned short
random_rand(void)
{
 8004948:	b580      	push	{r7, lr}
 800494a:	af00      	add	r7, sp, #0
/* In gcc int rand() uses RAND_MAX and long random() uses RANDOM_MAX=0x7FFFFFFF */
/* RAND_MAX varies depending on the architecture */

  return (unsigned short)rand();
 800494c:	f7fb fcd0 	bl	80002f0 <rand>
 8004950:	4603      	mov	r3, r0
 8004952:	b29b      	uxth	r3, r3
}
 8004954:	4618      	mov	r0, r3
 8004956:	bd80      	pop	{r7, pc}

08004958 <uip_add32>:
#endif /* UIP_LOGGING == 1 */

#if ! UIP_ARCH_ADD32
void
uip_add32(uint8_t *op32, uint16_t op16)
{
 8004958:	b480      	push	{r7}
 800495a:	b083      	sub	sp, #12
 800495c:	af00      	add	r7, sp, #0
 800495e:	6078      	str	r0, [r7, #4]
 8004960:	460b      	mov	r3, r1
 8004962:	807b      	strh	r3, [r7, #2]
  uip_acc32[3] = op32[3] + (op16 & 0xff);
 8004964:	687b      	ldr	r3, [r7, #4]
 8004966:	3303      	adds	r3, #3
 8004968:	781a      	ldrb	r2, [r3, #0]
 800496a:	887b      	ldrh	r3, [r7, #2]
 800496c:	b2db      	uxtb	r3, r3
 800496e:	18d3      	adds	r3, r2, r3
 8004970:	b2da      	uxtb	r2, r3
 8004972:	f241 7314 	movw	r3, #5908	; 0x1714
 8004976:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800497a:	70da      	strb	r2, [r3, #3]
  uip_acc32[2] = op32[2] + (op16 >> 8);
 800497c:	687b      	ldr	r3, [r7, #4]
 800497e:	3302      	adds	r3, #2
 8004980:	781a      	ldrb	r2, [r3, #0]
 8004982:	887b      	ldrh	r3, [r7, #2]
 8004984:	0a1b      	lsrs	r3, r3, #8
 8004986:	b29b      	uxth	r3, r3
 8004988:	b2db      	uxtb	r3, r3
 800498a:	18d3      	adds	r3, r2, r3
 800498c:	b2da      	uxtb	r2, r3
 800498e:	f241 7314 	movw	r3, #5908	; 0x1714
 8004992:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004996:	709a      	strb	r2, [r3, #2]
  uip_acc32[1] = op32[1];
 8004998:	687b      	ldr	r3, [r7, #4]
 800499a:	785a      	ldrb	r2, [r3, #1]
 800499c:	f241 7314 	movw	r3, #5908	; 0x1714
 80049a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80049a4:	705a      	strb	r2, [r3, #1]
  uip_acc32[0] = op32[0];
 80049a6:	687b      	ldr	r3, [r7, #4]
 80049a8:	781a      	ldrb	r2, [r3, #0]
 80049aa:	f241 7314 	movw	r3, #5908	; 0x1714
 80049ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80049b2:	701a      	strb	r2, [r3, #0]
  
  if(uip_acc32[2] < (op16 >> 8)) {
 80049b4:	f241 7314 	movw	r3, #5908	; 0x1714
 80049b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80049bc:	789b      	ldrb	r3, [r3, #2]
 80049be:	461a      	mov	r2, r3
 80049c0:	887b      	ldrh	r3, [r7, #2]
 80049c2:	0a1b      	lsrs	r3, r3, #8
 80049c4:	b29b      	uxth	r3, r3
 80049c6:	429a      	cmp	r2, r3
 80049c8:	d21e      	bcs.n	8004a08 <uip_add32+0xb0>
    ++uip_acc32[1];
 80049ca:	f241 7314 	movw	r3, #5908	; 0x1714
 80049ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80049d2:	785b      	ldrb	r3, [r3, #1]
 80049d4:	3301      	adds	r3, #1
 80049d6:	b2da      	uxtb	r2, r3
 80049d8:	f241 7314 	movw	r3, #5908	; 0x1714
 80049dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80049e0:	705a      	strb	r2, [r3, #1]
    if(uip_acc32[1] == 0) {
 80049e2:	f241 7314 	movw	r3, #5908	; 0x1714
 80049e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80049ea:	785b      	ldrb	r3, [r3, #1]
 80049ec:	2b00      	cmp	r3, #0
 80049ee:	d10b      	bne.n	8004a08 <uip_add32+0xb0>
      ++uip_acc32[0];
 80049f0:	f241 7314 	movw	r3, #5908	; 0x1714
 80049f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80049f8:	781b      	ldrb	r3, [r3, #0]
 80049fa:	3301      	adds	r3, #1
 80049fc:	b2da      	uxtb	r2, r3
 80049fe:	f241 7314 	movw	r3, #5908	; 0x1714
 8004a02:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a06:	701a      	strb	r2, [r3, #0]
    }
  }
  
  
  if(uip_acc32[3] < (op16 & 0xff)) {
 8004a08:	f241 7314 	movw	r3, #5908	; 0x1714
 8004a0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a10:	78db      	ldrb	r3, [r3, #3]
 8004a12:	461a      	mov	r2, r3
 8004a14:	887b      	ldrh	r3, [r7, #2]
 8004a16:	b2db      	uxtb	r3, r3
 8004a18:	429a      	cmp	r2, r3
 8004a1a:	da31      	bge.n	8004a80 <uip_add32+0x128>
    ++uip_acc32[2];
 8004a1c:	f241 7314 	movw	r3, #5908	; 0x1714
 8004a20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a24:	789b      	ldrb	r3, [r3, #2]
 8004a26:	3301      	adds	r3, #1
 8004a28:	b2da      	uxtb	r2, r3
 8004a2a:	f241 7314 	movw	r3, #5908	; 0x1714
 8004a2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a32:	709a      	strb	r2, [r3, #2]
    if(uip_acc32[2] == 0) {
 8004a34:	f241 7314 	movw	r3, #5908	; 0x1714
 8004a38:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a3c:	789b      	ldrb	r3, [r3, #2]
 8004a3e:	2b00      	cmp	r3, #0
 8004a40:	d11e      	bne.n	8004a80 <uip_add32+0x128>
      ++uip_acc32[1];
 8004a42:	f241 7314 	movw	r3, #5908	; 0x1714
 8004a46:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a4a:	785b      	ldrb	r3, [r3, #1]
 8004a4c:	3301      	adds	r3, #1
 8004a4e:	b2da      	uxtb	r2, r3
 8004a50:	f241 7314 	movw	r3, #5908	; 0x1714
 8004a54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a58:	705a      	strb	r2, [r3, #1]
      if(uip_acc32[1] == 0) {
 8004a5a:	f241 7314 	movw	r3, #5908	; 0x1714
 8004a5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a62:	785b      	ldrb	r3, [r3, #1]
 8004a64:	2b00      	cmp	r3, #0
 8004a66:	d10b      	bne.n	8004a80 <uip_add32+0x128>
	++uip_acc32[0];
 8004a68:	f241 7314 	movw	r3, #5908	; 0x1714
 8004a6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a70:	781b      	ldrb	r3, [r3, #0]
 8004a72:	3301      	adds	r3, #1
 8004a74:	b2da      	uxtb	r2, r3
 8004a76:	f241 7314 	movw	r3, #5908	; 0x1714
 8004a7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a7e:	701a      	strb	r2, [r3, #0]
      }
    }
  }
}
 8004a80:	f107 070c 	add.w	r7, r7, #12
 8004a84:	46bd      	mov	sp, r7
 8004a86:	bc80      	pop	{r7}
 8004a88:	4770      	bx	lr
 8004a8a:	bf00      	nop

08004a8c <chksum>:

#if ! UIP_ARCH_CHKSUM
/*---------------------------------------------------------------------------*/
static uint16_t
chksum(uint16_t sum, const uint8_t *data, uint16_t len)
{
 8004a8c:	b480      	push	{r7}
 8004a8e:	b087      	sub	sp, #28
 8004a90:	af00      	add	r7, sp, #0
 8004a92:	6039      	str	r1, [r7, #0]
 8004a94:	4613      	mov	r3, r2
 8004a96:	4602      	mov	r2, r0
 8004a98:	80fa      	strh	r2, [r7, #6]
 8004a9a:	80bb      	strh	r3, [r7, #4]
  uint16_t t;
  const uint8_t *dataptr;
  const uint8_t *last_byte;

  dataptr = data;
 8004a9c:	683b      	ldr	r3, [r7, #0]
 8004a9e:	617b      	str	r3, [r7, #20]
  last_byte = data + len - 1;
 8004aa0:	88bb      	ldrh	r3, [r7, #4]
 8004aa2:	3b01      	subs	r3, #1
 8004aa4:	683a      	ldr	r2, [r7, #0]
 8004aa6:	18d3      	adds	r3, r2, r3
 8004aa8:	613b      	str	r3, [r7, #16]
  
  while(dataptr < last_byte) {	/* At least two more bytes */
 8004aaa:	e016      	b.n	8004ada <chksum+0x4e>
    t = (dataptr[0] << 8) + dataptr[1];
 8004aac:	697b      	ldr	r3, [r7, #20]
 8004aae:	781b      	ldrb	r3, [r3, #0]
 8004ab0:	021b      	lsls	r3, r3, #8
 8004ab2:	b29a      	uxth	r2, r3
 8004ab4:	697b      	ldr	r3, [r7, #20]
 8004ab6:	3301      	adds	r3, #1
 8004ab8:	781b      	ldrb	r3, [r3, #0]
 8004aba:	18d3      	adds	r3, r2, r3
 8004abc:	81fb      	strh	r3, [r7, #14]
    sum += t;
 8004abe:	88fa      	ldrh	r2, [r7, #6]
 8004ac0:	89fb      	ldrh	r3, [r7, #14]
 8004ac2:	18d3      	adds	r3, r2, r3
 8004ac4:	80fb      	strh	r3, [r7, #6]
    if(sum < t) {
 8004ac6:	88fa      	ldrh	r2, [r7, #6]
 8004ac8:	89fb      	ldrh	r3, [r7, #14]
 8004aca:	429a      	cmp	r2, r3
 8004acc:	d202      	bcs.n	8004ad4 <chksum+0x48>
      sum++;		/* carry */
 8004ace:	88fb      	ldrh	r3, [r7, #6]
 8004ad0:	3301      	adds	r3, #1
 8004ad2:	80fb      	strh	r3, [r7, #6]
    }
    dataptr += 2;
 8004ad4:	697b      	ldr	r3, [r7, #20]
 8004ad6:	3302      	adds	r3, #2
 8004ad8:	617b      	str	r3, [r7, #20]
  const uint8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
  
  while(dataptr < last_byte) {	/* At least two more bytes */
 8004ada:	697a      	ldr	r2, [r7, #20]
 8004adc:	693b      	ldr	r3, [r7, #16]
 8004ade:	429a      	cmp	r2, r3
 8004ae0:	d3e4      	bcc.n	8004aac <chksum+0x20>
      sum++;		/* carry */
    }
    dataptr += 2;
  }
  
  if(dataptr == last_byte) {
 8004ae2:	697a      	ldr	r2, [r7, #20]
 8004ae4:	693b      	ldr	r3, [r7, #16]
 8004ae6:	429a      	cmp	r2, r3
 8004ae8:	d10e      	bne.n	8004b08 <chksum+0x7c>
    t = (dataptr[0] << 8) + 0;
 8004aea:	697b      	ldr	r3, [r7, #20]
 8004aec:	781b      	ldrb	r3, [r3, #0]
 8004aee:	021b      	lsls	r3, r3, #8
 8004af0:	81fb      	strh	r3, [r7, #14]
    sum += t;
 8004af2:	88fa      	ldrh	r2, [r7, #6]
 8004af4:	89fb      	ldrh	r3, [r7, #14]
 8004af6:	18d3      	adds	r3, r2, r3
 8004af8:	80fb      	strh	r3, [r7, #6]
    if(sum < t) {
 8004afa:	88fa      	ldrh	r2, [r7, #6]
 8004afc:	89fb      	ldrh	r3, [r7, #14]
 8004afe:	429a      	cmp	r2, r3
 8004b00:	d202      	bcs.n	8004b08 <chksum+0x7c>
      sum++;		/* carry */
 8004b02:	88fb      	ldrh	r3, [r7, #6]
 8004b04:	3301      	adds	r3, #1
 8004b06:	80fb      	strh	r3, [r7, #6]
    }
  }

  /* Return sum in host byte order. */
  return sum;
 8004b08:	88fb      	ldrh	r3, [r7, #6]
}
 8004b0a:	4618      	mov	r0, r3
 8004b0c:	f107 071c 	add.w	r7, r7, #28
 8004b10:	46bd      	mov	sp, r7
 8004b12:	bc80      	pop	{r7}
 8004b14:	4770      	bx	lr
 8004b16:	bf00      	nop

08004b18 <uip_chksum>:
/*---------------------------------------------------------------------------*/
uint16_t
uip_chksum(uint16_t *data, uint16_t len)
{
 8004b18:	b580      	push	{r7, lr}
 8004b1a:	b082      	sub	sp, #8
 8004b1c:	af00      	add	r7, sp, #0
 8004b1e:	6078      	str	r0, [r7, #4]
 8004b20:	460b      	mov	r3, r1
 8004b22:	807b      	strh	r3, [r7, #2]
  return uip_htons(chksum(0, (uint8_t *)data, len));
 8004b24:	887b      	ldrh	r3, [r7, #2]
 8004b26:	2000      	movs	r0, #0
 8004b28:	6879      	ldr	r1, [r7, #4]
 8004b2a:	461a      	mov	r2, r3
 8004b2c:	f7ff ffae 	bl	8004a8c <chksum>
 8004b30:	4603      	mov	r3, r0
 8004b32:	4618      	mov	r0, r3
 8004b34:	f001 ff5c 	bl	80069f0 <uip_htons>
 8004b38:	4603      	mov	r3, r0
}
 8004b3a:	4618      	mov	r0, r3
 8004b3c:	f107 0708 	add.w	r7, r7, #8
 8004b40:	46bd      	mov	sp, r7
 8004b42:	bd80      	pop	{r7, pc}

08004b44 <uip_ipchksum>:
/*---------------------------------------------------------------------------*/
#ifndef UIP_ARCH_IPCHKSUM
uint16_t
uip_ipchksum(void)
{
 8004b44:	b580      	push	{r7, lr}
 8004b46:	b082      	sub	sp, #8
 8004b48:	af00      	add	r7, sp, #0
  uint16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
 8004b4a:	2000      	movs	r0, #0
 8004b4c:	f241 7118 	movw	r1, #5912	; 0x1718
 8004b50:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8004b54:	2214      	movs	r2, #20
 8004b56:	f7ff ff99 	bl	8004a8c <chksum>
 8004b5a:	4603      	mov	r3, r0
 8004b5c:	80fb      	strh	r3, [r7, #6]
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : uip_htons(sum);
 8004b5e:	88fb      	ldrh	r3, [r7, #6]
 8004b60:	2b00      	cmp	r3, #0
 8004b62:	d005      	beq.n	8004b70 <uip_ipchksum+0x2c>
 8004b64:	88fb      	ldrh	r3, [r7, #6]
 8004b66:	4618      	mov	r0, r3
 8004b68:	f001 ff42 	bl	80069f0 <uip_htons>
 8004b6c:	4603      	mov	r3, r0
 8004b6e:	e001      	b.n	8004b74 <uip_ipchksum+0x30>
 8004b70:	f64f 73ff 	movw	r3, #65535	; 0xffff
}
 8004b74:	4618      	mov	r0, r3
 8004b76:	f107 0708 	add.w	r7, r7, #8
 8004b7a:	46bd      	mov	sp, r7
 8004b7c:	bd80      	pop	{r7, pc}
 8004b7e:	bf00      	nop

08004b80 <upper_layer_chksum>:
#endif
/*---------------------------------------------------------------------------*/
static uint16_t
upper_layer_chksum(uint8_t proto)
{
 8004b80:	b580      	push	{r7, lr}
 8004b82:	b084      	sub	sp, #16
 8004b84:	af00      	add	r7, sp, #0
 8004b86:	4603      	mov	r3, r0
 8004b88:	71fb      	strb	r3, [r7, #7]
  uint16_t sum;
  
#if UIP_CONF_IPV6
  upper_layer_len = (((uint16_t)(BUF->len[0]) << 8) + BUF->len[1]);
#else /* UIP_CONF_IPV6 */
  upper_layer_len = (((uint16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
 8004b8a:	f241 7318 	movw	r3, #5912	; 0x1718
 8004b8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004b92:	789b      	ldrb	r3, [r3, #2]
 8004b94:	021b      	lsls	r3, r3, #8
 8004b96:	b29a      	uxth	r2, r3
 8004b98:	f241 7318 	movw	r3, #5912	; 0x1718
 8004b9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004ba0:	78db      	ldrb	r3, [r3, #3]
 8004ba2:	18d3      	adds	r3, r2, r3
 8004ba4:	b29b      	uxth	r3, r3
 8004ba6:	3b14      	subs	r3, #20
 8004ba8:	81fb      	strh	r3, [r7, #14]
#endif /* UIP_CONF_IPV6 */
  
  /* First sum pseudoheader. */
  
  /* IP protocol and length fields. This addition cannot carry. */
  sum = upper_layer_len + proto;
 8004baa:	79fb      	ldrb	r3, [r7, #7]
 8004bac:	b29a      	uxth	r2, r3
 8004bae:	89fb      	ldrh	r3, [r7, #14]
 8004bb0:	18d3      	adds	r3, r2, r3
 8004bb2:	81bb      	strh	r3, [r7, #12]
  /* Sum IP source and destination addresses. */
  sum = chksum(sum, (uint8_t *)&BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t));
 8004bb4:	89bb      	ldrh	r3, [r7, #12]
 8004bb6:	4618      	mov	r0, r3
 8004bb8:	490f      	ldr	r1, [pc, #60]	; (8004bf8 <upper_layer_chksum+0x78>)
 8004bba:	2208      	movs	r2, #8
 8004bbc:	f7ff ff66 	bl	8004a8c <chksum>
 8004bc0:	4603      	mov	r3, r0
 8004bc2:	81bb      	strh	r3, [r7, #12]

  /* Sum TCP header and data. */
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
 8004bc4:	89ba      	ldrh	r2, [r7, #12]
 8004bc6:	89fb      	ldrh	r3, [r7, #14]
 8004bc8:	4610      	mov	r0, r2
 8004bca:	490c      	ldr	r1, [pc, #48]	; (8004bfc <upper_layer_chksum+0x7c>)
 8004bcc:	461a      	mov	r2, r3
 8004bce:	f7ff ff5d 	bl	8004a8c <chksum>
 8004bd2:	4603      	mov	r3, r0
 8004bd4:	81bb      	strh	r3, [r7, #12]
	       upper_layer_len);
    
  return (sum == 0) ? 0xffff : uip_htons(sum);
 8004bd6:	89bb      	ldrh	r3, [r7, #12]
 8004bd8:	2b00      	cmp	r3, #0
 8004bda:	d005      	beq.n	8004be8 <upper_layer_chksum+0x68>
 8004bdc:	89bb      	ldrh	r3, [r7, #12]
 8004bde:	4618      	mov	r0, r3
 8004be0:	f001 ff06 	bl	80069f0 <uip_htons>
 8004be4:	4603      	mov	r3, r0
 8004be6:	e001      	b.n	8004bec <upper_layer_chksum+0x6c>
 8004be8:	f64f 73ff 	movw	r3, #65535	; 0xffff
}
 8004bec:	4618      	mov	r0, r3
 8004bee:	f107 0710 	add.w	r7, r7, #16
 8004bf2:	46bd      	mov	sp, r7
 8004bf4:	bd80      	pop	{r7, pc}
 8004bf6:	bf00      	nop
 8004bf8:	20001724 	.word	0x20001724
 8004bfc:	2000172c 	.word	0x2000172c

08004c00 <uip_tcpchksum>:
}
#endif /* UIP_CONF_IPV6 */
/*---------------------------------------------------------------------------*/
uint16_t
uip_tcpchksum(void)
{
 8004c00:	b580      	push	{r7, lr}
 8004c02:	af00      	add	r7, sp, #0
  return upper_layer_chksum(UIP_PROTO_TCP);
 8004c04:	2006      	movs	r0, #6
 8004c06:	f7ff ffbb 	bl	8004b80 <upper_layer_chksum>
 8004c0a:	4603      	mov	r3, r0
}
 8004c0c:	4618      	mov	r0, r3
 8004c0e:	bd80      	pop	{r7, pc}

08004c10 <uip_udpchksum>:
/*---------------------------------------------------------------------------*/
#if UIP_UDP_CHECKSUMS
uint16_t
uip_udpchksum(void)
{
 8004c10:	b580      	push	{r7, lr}
 8004c12:	af00      	add	r7, sp, #0
  return upper_layer_chksum(UIP_PROTO_UDP);
 8004c14:	2011      	movs	r0, #17
 8004c16:	f7ff ffb3 	bl	8004b80 <upper_layer_chksum>
 8004c1a:	4603      	mov	r3, r0
}
 8004c1c:	4618      	mov	r0, r3
 8004c1e:	bd80      	pop	{r7, pc}

08004c20 <uip_init>:
#endif /* UIP_UDP_CHECKSUMS */
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
 8004c20:	b480      	push	{r7}
 8004c22:	af00      	add	r7, sp, #0
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
 8004c24:	f241 5372 	movw	r3, #5490	; 0x1572
 8004c28:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c2c:	2200      	movs	r2, #0
 8004c2e:	701a      	strb	r2, [r3, #0]
 8004c30:	e018      	b.n	8004c64 <uip_init+0x44>
    uip_listenports[c] = 0;
 8004c32:	f241 5372 	movw	r3, #5490	; 0x1572
 8004c36:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c3a:	781b      	ldrb	r3, [r3, #0]
 8004c3c:	461a      	mov	r2, r3
 8004c3e:	f641 636c 	movw	r3, #7788	; 0x1e6c
 8004c42:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c46:	2100      	movs	r1, #0
 8004c48:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
 8004c4c:	f241 5372 	movw	r3, #5490	; 0x1572
 8004c50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c54:	781b      	ldrb	r3, [r3, #0]
 8004c56:	3301      	adds	r3, #1
 8004c58:	b2da      	uxtb	r2, r3
 8004c5a:	f241 5372 	movw	r3, #5490	; 0x1572
 8004c5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c62:	701a      	strb	r2, [r3, #0]
 8004c64:	f241 5372 	movw	r3, #5490	; 0x1572
 8004c68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c6c:	781b      	ldrb	r3, [r3, #0]
 8004c6e:	2b27      	cmp	r3, #39	; 0x27
 8004c70:	d9df      	bls.n	8004c32 <uip_init+0x12>
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
 8004c72:	f241 5372 	movw	r3, #5490	; 0x1572
 8004c76:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c7a:	2200      	movs	r2, #0
 8004c7c:	701a      	strb	r2, [r3, #0]
 8004c7e:	e01d      	b.n	8004cbc <uip_init+0x9c>
    uip_conns[c].tcpstateflags = UIP_CLOSED;
 8004c80:	f241 5372 	movw	r3, #5490	; 0x1572
 8004c84:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c88:	781b      	ldrb	r3, [r3, #0]
 8004c8a:	4619      	mov	r1, r3
 8004c8c:	f641 02cc 	movw	r2, #6348	; 0x18cc
 8004c90:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004c94:	460b      	mov	r3, r1
 8004c96:	00db      	lsls	r3, r3, #3
 8004c98:	185b      	adds	r3, r3, r1
 8004c9a:	009b      	lsls	r3, r3, #2
 8004c9c:	18d3      	adds	r3, r2, r3
 8004c9e:	3318      	adds	r3, #24
 8004ca0:	2200      	movs	r2, #0
 8004ca2:	705a      	strb	r2, [r3, #1]
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
 8004ca4:	f241 5372 	movw	r3, #5490	; 0x1572
 8004ca8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004cac:	781b      	ldrb	r3, [r3, #0]
 8004cae:	3301      	adds	r3, #1
 8004cb0:	b2da      	uxtb	r2, r3
 8004cb2:	f241 5372 	movw	r3, #5490	; 0x1572
 8004cb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004cba:	701a      	strb	r2, [r3, #0]
 8004cbc:	f241 5372 	movw	r3, #5490	; 0x1572
 8004cc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004cc4:	781b      	ldrb	r3, [r3, #0]
 8004cc6:	2b27      	cmp	r3, #39	; 0x27
 8004cc8:	d9da      	bls.n	8004c80 <uip_init+0x60>
    uip_conns[c].tcpstateflags = UIP_CLOSED;
  }
#if UIP_ACTIVE_OPEN || UIP_UDP
  lastport = 1024;
 8004cca:	f241 5370 	movw	r3, #5488	; 0x1570
 8004cce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004cd2:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8004cd6:	801a      	strh	r2, [r3, #0]
#endif /* UIP_ACTIVE_OPEN || UIP_UDP */

#if UIP_UDP
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
 8004cd8:	f241 5372 	movw	r3, #5490	; 0x1572
 8004cdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004ce0:	2200      	movs	r2, #0
 8004ce2:	701a      	strb	r2, [r3, #0]
 8004ce4:	e01c      	b.n	8004d20 <uip_init+0x100>
    uip_udp_conns[c].lport = 0;
 8004ce6:	f241 5372 	movw	r3, #5490	; 0x1572
 8004cea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004cee:	781b      	ldrb	r3, [r3, #0]
 8004cf0:	4619      	mov	r1, r3
 8004cf2:	f641 62cc 	movw	r2, #7884	; 0x1ecc
 8004cf6:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004cfa:	460b      	mov	r3, r1
 8004cfc:	009b      	lsls	r3, r3, #2
 8004cfe:	185b      	adds	r3, r3, r1
 8004d00:	009b      	lsls	r3, r3, #2
 8004d02:	18d3      	adds	r3, r2, r3
 8004d04:	2200      	movs	r2, #0
 8004d06:	809a      	strh	r2, [r3, #4]
#if UIP_ACTIVE_OPEN || UIP_UDP
  lastport = 1024;
#endif /* UIP_ACTIVE_OPEN || UIP_UDP */

#if UIP_UDP
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
 8004d08:	f241 5372 	movw	r3, #5490	; 0x1572
 8004d0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d10:	781b      	ldrb	r3, [r3, #0]
 8004d12:	3301      	adds	r3, #1
 8004d14:	b2da      	uxtb	r2, r3
 8004d16:	f241 5372 	movw	r3, #5490	; 0x1572
 8004d1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d1e:	701a      	strb	r2, [r3, #0]
 8004d20:	f241 5372 	movw	r3, #5490	; 0x1572
 8004d24:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d28:	781b      	ldrb	r3, [r3, #0]
 8004d2a:	2b09      	cmp	r3, #9
 8004d2c:	d9db      	bls.n	8004ce6 <uip_init+0xc6>
  /* IPv4 initialization. */
#if UIP_FIXEDADDR == 0
  /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
#endif /* UIP_FIXEDADDR */

}
 8004d2e:	46bd      	mov	sp, r7
 8004d30:	bc80      	pop	{r7}
 8004d32:	4770      	bx	lr

08004d34 <uip_unlisten>:
}
#endif /* UIP_UDP */
/*---------------------------------------------------------------------------*/
void
uip_unlisten(uint16_t port)
{
 8004d34:	b480      	push	{r7}
 8004d36:	b083      	sub	sp, #12
 8004d38:	af00      	add	r7, sp, #0
 8004d3a:	4603      	mov	r3, r0
 8004d3c:	80fb      	strh	r3, [r7, #6]
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
 8004d3e:	f241 5372 	movw	r3, #5490	; 0x1572
 8004d42:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d46:	2200      	movs	r2, #0
 8004d48:	701a      	strb	r2, [r3, #0]
 8004d4a:	e028      	b.n	8004d9e <uip_unlisten+0x6a>
    if(uip_listenports[c] == port) {
 8004d4c:	f241 5372 	movw	r3, #5490	; 0x1572
 8004d50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d54:	781b      	ldrb	r3, [r3, #0]
 8004d56:	461a      	mov	r2, r3
 8004d58:	f641 636c 	movw	r3, #7788	; 0x1e6c
 8004d5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d60:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8004d64:	88fa      	ldrh	r2, [r7, #6]
 8004d66:	429a      	cmp	r2, r3
 8004d68:	d10d      	bne.n	8004d86 <uip_unlisten+0x52>
      uip_listenports[c] = 0;
 8004d6a:	f241 5372 	movw	r3, #5490	; 0x1572
 8004d6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d72:	781b      	ldrb	r3, [r3, #0]
 8004d74:	461a      	mov	r2, r3
 8004d76:	f641 636c 	movw	r3, #7788	; 0x1e6c
 8004d7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d7e:	2100      	movs	r1, #0
 8004d80:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
      return;
 8004d84:	e012      	b.n	8004dac <uip_unlisten+0x78>
#endif /* UIP_UDP */
/*---------------------------------------------------------------------------*/
void
uip_unlisten(uint16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
 8004d86:	f241 5372 	movw	r3, #5490	; 0x1572
 8004d8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d8e:	781b      	ldrb	r3, [r3, #0]
 8004d90:	3301      	adds	r3, #1
 8004d92:	b2da      	uxtb	r2, r3
 8004d94:	f241 5372 	movw	r3, #5490	; 0x1572
 8004d98:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d9c:	701a      	strb	r2, [r3, #0]
 8004d9e:	f241 5372 	movw	r3, #5490	; 0x1572
 8004da2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004da6:	781b      	ldrb	r3, [r3, #0]
 8004da8:	2b27      	cmp	r3, #39	; 0x27
 8004daa:	d9cf      	bls.n	8004d4c <uip_unlisten+0x18>
    if(uip_listenports[c] == port) {
      uip_listenports[c] = 0;
      return;
    }
  }
}
 8004dac:	f107 070c 	add.w	r7, r7, #12
 8004db0:	46bd      	mov	sp, r7
 8004db2:	bc80      	pop	{r7}
 8004db4:	4770      	bx	lr
 8004db6:	bf00      	nop

08004db8 <uip_listen>:
/*---------------------------------------------------------------------------*/
void
uip_listen(uint16_t port)
{
 8004db8:	b480      	push	{r7}
 8004dba:	b083      	sub	sp, #12
 8004dbc:	af00      	add	r7, sp, #0
 8004dbe:	4603      	mov	r3, r0
 8004dc0:	80fb      	strh	r3, [r7, #6]
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
 8004dc2:	f241 5372 	movw	r3, #5490	; 0x1572
 8004dc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004dca:	2200      	movs	r2, #0
 8004dcc:	701a      	strb	r2, [r3, #0]
 8004dce:	e027      	b.n	8004e20 <uip_listen+0x68>
    if(uip_listenports[c] == 0) {
 8004dd0:	f241 5372 	movw	r3, #5490	; 0x1572
 8004dd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004dd8:	781b      	ldrb	r3, [r3, #0]
 8004dda:	461a      	mov	r2, r3
 8004ddc:	f641 636c 	movw	r3, #7788	; 0x1e6c
 8004de0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004de4:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8004de8:	2b00      	cmp	r3, #0
 8004dea:	d10d      	bne.n	8004e08 <uip_listen+0x50>
      uip_listenports[c] = port;
 8004dec:	f241 5372 	movw	r3, #5490	; 0x1572
 8004df0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004df4:	781b      	ldrb	r3, [r3, #0]
 8004df6:	461a      	mov	r2, r3
 8004df8:	f641 636c 	movw	r3, #7788	; 0x1e6c
 8004dfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e00:	88f9      	ldrh	r1, [r7, #6]
 8004e02:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
      return;
 8004e06:	e012      	b.n	8004e2e <uip_listen+0x76>
}
/*---------------------------------------------------------------------------*/
void
uip_listen(uint16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
 8004e08:	f241 5372 	movw	r3, #5490	; 0x1572
 8004e0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e10:	781b      	ldrb	r3, [r3, #0]
 8004e12:	3301      	adds	r3, #1
 8004e14:	b2da      	uxtb	r2, r3
 8004e16:	f241 5372 	movw	r3, #5490	; 0x1572
 8004e1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e1e:	701a      	strb	r2, [r3, #0]
 8004e20:	f241 5372 	movw	r3, #5490	; 0x1572
 8004e24:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e28:	781b      	ldrb	r3, [r3, #0]
 8004e2a:	2b27      	cmp	r3, #39	; 0x27
 8004e2c:	d9d0      	bls.n	8004dd0 <uip_listen+0x18>
    if(uip_listenports[c] == 0) {
      uip_listenports[c] = port;
      return;
    }
  }
}
 8004e2e:	f107 070c 	add.w	r7, r7, #12
 8004e32:	46bd      	mov	sp, r7
 8004e34:	bc80      	pop	{r7}
 8004e36:	4770      	bx	lr

08004e38 <uip_add_rcv_nxt>:
}
#endif /* UIP_REASSEMBLY */
/*---------------------------------------------------------------------------*/
static void
uip_add_rcv_nxt(uint16_t n)
{
 8004e38:	b580      	push	{r7, lr}
 8004e3a:	b082      	sub	sp, #8
 8004e3c:	af00      	add	r7, sp, #0
 8004e3e:	4603      	mov	r3, r0
 8004e40:	80fb      	strh	r3, [r7, #6]
  uip_add32(uip_conn->rcv_nxt, n);
 8004e42:	f641 03c8 	movw	r3, #6344	; 0x18c8
 8004e46:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e4a:	681b      	ldr	r3, [r3, #0]
 8004e4c:	f103 0208 	add.w	r2, r3, #8
 8004e50:	88fb      	ldrh	r3, [r7, #6]
 8004e52:	4610      	mov	r0, r2
 8004e54:	4619      	mov	r1, r3
 8004e56:	f7ff fd7f 	bl	8004958 <uip_add32>
  uip_conn->rcv_nxt[0] = uip_acc32[0];
 8004e5a:	f641 03c8 	movw	r3, #6344	; 0x18c8
 8004e5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e62:	681a      	ldr	r2, [r3, #0]
 8004e64:	f241 7314 	movw	r3, #5908	; 0x1714
 8004e68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e6c:	781b      	ldrb	r3, [r3, #0]
 8004e6e:	7213      	strb	r3, [r2, #8]
  uip_conn->rcv_nxt[1] = uip_acc32[1];
 8004e70:	f641 03c8 	movw	r3, #6344	; 0x18c8
 8004e74:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e78:	681a      	ldr	r2, [r3, #0]
 8004e7a:	f241 7314 	movw	r3, #5908	; 0x1714
 8004e7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e82:	785b      	ldrb	r3, [r3, #1]
 8004e84:	7253      	strb	r3, [r2, #9]
  uip_conn->rcv_nxt[2] = uip_acc32[2];
 8004e86:	f641 03c8 	movw	r3, #6344	; 0x18c8
 8004e8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e8e:	681a      	ldr	r2, [r3, #0]
 8004e90:	f241 7314 	movw	r3, #5908	; 0x1714
 8004e94:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e98:	789b      	ldrb	r3, [r3, #2]
 8004e9a:	7293      	strb	r3, [r2, #10]
  uip_conn->rcv_nxt[3] = uip_acc32[3];
 8004e9c:	f641 03c8 	movw	r3, #6344	; 0x18c8
 8004ea0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004ea4:	681a      	ldr	r2, [r3, #0]
 8004ea6:	f241 7314 	movw	r3, #5908	; 0x1714
 8004eaa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004eae:	78db      	ldrb	r3, [r3, #3]
 8004eb0:	72d3      	strb	r3, [r2, #11]
}
 8004eb2:	f107 0708 	add.w	r7, r7, #8
 8004eb6:	46bd      	mov	sp, r7
 8004eb8:	bd80      	pop	{r7, pc}
 8004eba:	bf00      	nop

08004ebc <uip_process>:
/*---------------------------------------------------------------------------*/
void
uip_process(uint8_t flag)
{
 8004ebc:	b590      	push	{r4, r7, lr}
 8004ebe:	b085      	sub	sp, #20
 8004ec0:	af00      	add	r7, sp, #0
 8004ec2:	4603      	mov	r3, r0
 8004ec4:	71fb      	strb	r3, [r7, #7]
  register struct uip_conn *uip_connr = uip_conn;
 8004ec6:	f641 03c8 	movw	r3, #6344	; 0x18c8
 8004eca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004ece:	681c      	ldr	r4, [r3, #0]

#if UIP_UDP
  if(flag == UIP_UDP_SEND_CONN) {
 8004ed0:	79fb      	ldrb	r3, [r7, #7]
 8004ed2:	2b04      	cmp	r3, #4
 8004ed4:	f000 8354 	beq.w	8005580 <uip_process+0x6c4>
    goto udp_send;
  }
#endif /* UIP_UDP */
  
  uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
 8004ed8:	f641 03c4 	movw	r3, #6340	; 0x18c4
 8004edc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004ee0:	4acc      	ldr	r2, [pc, #816]	; (8005214 <uip_process+0x358>)
 8004ee2:	601a      	str	r2, [r3, #0]
 8004ee4:	f641 03c4 	movw	r3, #6340	; 0x18c4
 8004ee8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004eec:	681a      	ldr	r2, [r3, #0]
 8004eee:	f241 7310 	movw	r3, #5904	; 0x1710
 8004ef2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004ef6:	601a      	str	r2, [r3, #0]

  /* Check if we were invoked because of a poll request for a
     particular connection. */
  if(flag == UIP_POLL_REQUEST) {
 8004ef8:	79fb      	ldrb	r3, [r7, #7]
 8004efa:	2b03      	cmp	r3, #3
 8004efc:	d120      	bne.n	8004f40 <uip_process+0x84>
    if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
 8004efe:	7e63      	ldrb	r3, [r4, #25]
 8004f00:	f003 030f 	and.w	r3, r3, #15
 8004f04:	2b03      	cmp	r3, #3
 8004f06:	d10c      	bne.n	8004f22 <uip_process+0x66>
       !uip_outstanding(uip_connr)) {
 8004f08:	8a23      	ldrh	r3, [r4, #16]
  uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];

  /* Check if we were invoked because of a poll request for a
     particular connection. */
  if(flag == UIP_POLL_REQUEST) {
    if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
 8004f0a:	2b00      	cmp	r3, #0
 8004f0c:	d109      	bne.n	8004f22 <uip_process+0x66>
       !uip_outstanding(uip_connr)) {
	uip_flags = UIP_POLL;
 8004f0e:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8004f12:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f16:	2208      	movs	r2, #8
 8004f18:	701a      	strb	r2, [r3, #0]
	UIP_APPCALL();
 8004f1a:	f001 ffe3 	bl	8006ee4 <tcpip_uipcall>
	goto appsend;
 8004f1e:	f001 badc 	b.w	80064da <uip_process+0x161e>
#if UIP_ACTIVE_OPEN
    } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) {
 8004f22:	7e63      	ldrb	r3, [r4, #25]
 8004f24:	f003 030f 	and.w	r3, r3, #15
 8004f28:	2b02      	cmp	r3, #2
 8004f2a:	f041 8537 	bne.w	800699c <uip_process+0x1ae0>
      /* In the SYN_SENT state, we retransmit out SYN. */
      BUF->flags = 0;
 8004f2e:	f241 7318 	movw	r3, #5912	; 0x1718
 8004f32:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f36:	2200      	movs	r2, #0
 8004f38:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
      goto tcp_send_syn;
 8004f3c:	f000 bef2 	b.w	8005d24 <uip_process+0xe68>
#endif /* UIP_ACTIVE_OPEN */
    }
    goto drop;
    
    /* Check if we were invoked because of the perodic timer fireing. */
  } else if(flag == UIP_TIMER) {
 8004f40:	79fb      	ldrb	r3, [r7, #7]
 8004f42:	2b02      	cmp	r3, #2
 8004f44:	f040 80e3 	bne.w	800510e <uip_process+0x252>
    if(uip_reasstmr != 0) {
      --uip_reasstmr;
    }
#endif /* UIP_REASSEMBLY */
    /* Increase the initial sequence number. */
    if(++iss[3] == 0) {
 8004f48:	f241 536c 	movw	r3, #5484	; 0x156c
 8004f4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f50:	78db      	ldrb	r3, [r3, #3]
 8004f52:	3301      	adds	r3, #1
 8004f54:	b2da      	uxtb	r2, r3
 8004f56:	f241 536c 	movw	r3, #5484	; 0x156c
 8004f5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f5e:	70da      	strb	r2, [r3, #3]
 8004f60:	f241 536c 	movw	r3, #5484	; 0x156c
 8004f64:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f68:	78db      	ldrb	r3, [r3, #3]
 8004f6a:	2b00      	cmp	r3, #0
 8004f6c:	d131      	bne.n	8004fd2 <uip_process+0x116>
      if(++iss[2] == 0) {
 8004f6e:	f241 536c 	movw	r3, #5484	; 0x156c
 8004f72:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f76:	789b      	ldrb	r3, [r3, #2]
 8004f78:	3301      	adds	r3, #1
 8004f7a:	b2da      	uxtb	r2, r3
 8004f7c:	f241 536c 	movw	r3, #5484	; 0x156c
 8004f80:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f84:	709a      	strb	r2, [r3, #2]
 8004f86:	f241 536c 	movw	r3, #5484	; 0x156c
 8004f8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f8e:	789b      	ldrb	r3, [r3, #2]
 8004f90:	2b00      	cmp	r3, #0
 8004f92:	d11e      	bne.n	8004fd2 <uip_process+0x116>
	if(++iss[1] == 0) {
 8004f94:	f241 536c 	movw	r3, #5484	; 0x156c
 8004f98:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f9c:	785b      	ldrb	r3, [r3, #1]
 8004f9e:	3301      	adds	r3, #1
 8004fa0:	b2da      	uxtb	r2, r3
 8004fa2:	f241 536c 	movw	r3, #5484	; 0x156c
 8004fa6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004faa:	705a      	strb	r2, [r3, #1]
 8004fac:	f241 536c 	movw	r3, #5484	; 0x156c
 8004fb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004fb4:	785b      	ldrb	r3, [r3, #1]
 8004fb6:	2b00      	cmp	r3, #0
 8004fb8:	d10b      	bne.n	8004fd2 <uip_process+0x116>
	  ++iss[0];
 8004fba:	f241 536c 	movw	r3, #5484	; 0x156c
 8004fbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004fc2:	781b      	ldrb	r3, [r3, #0]
 8004fc4:	3301      	adds	r3, #1
 8004fc6:	b2da      	uxtb	r2, r3
 8004fc8:	f241 536c 	movw	r3, #5484	; 0x156c
 8004fcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004fd0:	701a      	strb	r2, [r3, #0]
	}
      }
    }

    /* Reset the length variables. */
    uip_len = 0;
 8004fd2:	f241 730c 	movw	r3, #5900	; 0x170c
 8004fd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004fda:	2200      	movs	r2, #0
 8004fdc:	801a      	strh	r2, [r3, #0]
    uip_slen = 0;
 8004fde:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 8004fe2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004fe6:	2200      	movs	r2, #0
 8004fe8:	801a      	strh	r2, [r3, #0]

    /* Check if the connection is in a state in which we simply wait
       for the connection to time out. If so, we increase the
       connection's timer and remove the connection if it times
       out. */
    if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
 8004fea:	7e63      	ldrb	r3, [r4, #25]
 8004fec:	2b07      	cmp	r3, #7
 8004fee:	d002      	beq.n	8004ff6 <uip_process+0x13a>
       uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
 8004ff0:	7e63      	ldrb	r3, [r4, #25]

    /* Check if the connection is in a state in which we simply wait
       for the connection to time out. If so, we increase the
       connection's timer and remove the connection if it times
       out. */
    if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
 8004ff2:	2b05      	cmp	r3, #5
 8004ff4:	d10a      	bne.n	800500c <uip_process+0x150>
       uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
      ++(uip_connr->timer);
 8004ff6:	7ea3      	ldrb	r3, [r4, #26]
 8004ff8:	3301      	adds	r3, #1
 8004ffa:	b2db      	uxtb	r3, r3
 8004ffc:	76a3      	strb	r3, [r4, #26]
      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
 8004ffe:	7ea3      	ldrb	r3, [r4, #26]
 8005000:	2b78      	cmp	r3, #120	; 0x78
 8005002:	f040 8082 	bne.w	800510a <uip_process+0x24e>
	uip_connr->tcpstateflags = UIP_CLOSED;
 8005006:	2300      	movs	r3, #0
 8005008:	7663      	strb	r3, [r4, #25]
       connection's timer and remove the connection if it times
       out. */
    if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
       uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
      ++(uip_connr->timer);
      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
 800500a:	e07e      	b.n	800510a <uip_process+0x24e>
	uip_connr->tcpstateflags = UIP_CLOSED;
      }
    } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
 800500c:	7e63      	ldrb	r3, [r4, #25]
 800500e:	2b00      	cmp	r3, #0
 8005010:	f001 84c6 	beq.w	80069a0 <uip_process+0x1ae4>
      /* If the connection has outstanding data, we increase the
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */

      if(uip_outstanding(uip_connr)) {
 8005014:	8a23      	ldrh	r3, [r4, #16]
 8005016:	2b00      	cmp	r3, #0
 8005018:	d067      	beq.n	80050ea <uip_process+0x22e>
	if(uip_connr->timer-- == 0) {
 800501a:	7ea3      	ldrb	r3, [r4, #26]
 800501c:	2b00      	cmp	r3, #0
 800501e:	bf14      	ite	ne
 8005020:	2200      	movne	r2, #0
 8005022:	2201      	moveq	r2, #1
 8005024:	b2d2      	uxtb	r2, r2
 8005026:	3b01      	subs	r3, #1
 8005028:	b2db      	uxtb	r3, r3
 800502a:	76a3      	strb	r3, [r4, #26]
 800502c:	2a00      	cmp	r2, #0
 800502e:	f001 84b7 	beq.w	80069a0 <uip_process+0x1ae4>
	  if(uip_connr->nrtx == UIP_MAXRTX ||
 8005032:	7ee3      	ldrb	r3, [r4, #27]
 8005034:	2b08      	cmp	r3, #8
 8005036:	d008      	beq.n	800504a <uip_process+0x18e>
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
 8005038:	7e63      	ldrb	r3, [r4, #25]
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */

      if(uip_outstanding(uip_connr)) {
	if(uip_connr->timer-- == 0) {
	  if(uip_connr->nrtx == UIP_MAXRTX ||
 800503a:	2b02      	cmp	r3, #2
 800503c:	d002      	beq.n	8005044 <uip_process+0x188>
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
 800503e:	7e63      	ldrb	r3, [r4, #25]
	 in which case we retransmit. */

      if(uip_outstanding(uip_connr)) {
	if(uip_connr->timer-- == 0) {
	  if(uip_connr->nrtx == UIP_MAXRTX ||
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
 8005040:	2b01      	cmp	r3, #1
 8005042:	d115      	bne.n	8005070 <uip_process+0x1b4>
	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
 8005044:	7ee3      	ldrb	r3, [r4, #27]

      if(uip_outstanding(uip_connr)) {
	if(uip_connr->timer-- == 0) {
	  if(uip_connr->nrtx == UIP_MAXRTX ||
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
 8005046:	2b05      	cmp	r3, #5
 8005048:	d112      	bne.n	8005070 <uip_process+0x1b4>
	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
	    uip_connr->tcpstateflags = UIP_CLOSED;
 800504a:	2300      	movs	r3, #0
 800504c:	7663      	strb	r3, [r4, #25]

	    /* We call UIP_APPCALL() with uip_flags set to
	       UIP_TIMEDOUT to inform the application that the
	       connection has timed out. */
	    uip_flags = UIP_TIMEDOUT;
 800504e:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8005052:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005056:	2280      	movs	r2, #128	; 0x80
 8005058:	701a      	strb	r2, [r3, #0]
	    UIP_APPCALL();
 800505a:	f001 ff43 	bl	8006ee4 <tcpip_uipcall>

	    /* We also send a reset packet to the remote host. */
	    BUF->flags = TCP_RST | TCP_ACK;
 800505e:	f241 7318 	movw	r3, #5912	; 0x1718
 8005062:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005066:	2214      	movs	r2, #20
 8005068:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
	    goto tcp_send_nodata;
 800506c:	f001 bb87 	b.w	800677e <uip_process+0x18c2>
	  }

	  /* Exponential backoff. */
	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
 8005070:	7ee3      	ldrb	r3, [r4, #27]
 8005072:	2b04      	cmp	r3, #4
 8005074:	d805      	bhi.n	8005082 <uip_process+0x1c6>
					 4:
					 uip_connr->nrtx);
 8005076:	7ee3      	ldrb	r3, [r4, #27]
	    BUF->flags = TCP_RST | TCP_ACK;
	    goto tcp_send_nodata;
	  }

	  /* Exponential backoff. */
	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
 8005078:	2203      	movs	r2, #3
 800507a:	fa02 f303 	lsl.w	r3, r2, r3
 800507e:	b2db      	uxtb	r3, r3
 8005080:	e000      	b.n	8005084 <uip_process+0x1c8>
 8005082:	2330      	movs	r3, #48	; 0x30
 8005084:	76a3      	strb	r3, [r4, #26]
					 4:
					 uip_connr->nrtx);
	  ++(uip_connr->nrtx);
 8005086:	7ee3      	ldrb	r3, [r4, #27]
 8005088:	3301      	adds	r3, #1
 800508a:	b2db      	uxtb	r3, r3
 800508c:	76e3      	strb	r3, [r4, #27]
	     call upon the application so that it may prepare the
	     data for the retransmit. In SYN_RCVD, we resend the
	     SYNACK that we sent earlier and in LAST_ACK we have to
	     retransmit our FINACK. */
	  UIP_STAT(++uip_stat.tcp.rexmit);
	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
 800508e:	7e63      	ldrb	r3, [r4, #25]
 8005090:	f003 030f 	and.w	r3, r3, #15
 8005094:	3b01      	subs	r3, #1
 8005096:	2b07      	cmp	r3, #7
 8005098:	f201 8482 	bhi.w	80069a0 <uip_process+0x1ae4>
 800509c:	a201      	add	r2, pc, #4	; (adr r2, 80050a4 <uip_process+0x1e8>)
 800509e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80050a2:	bf00      	nop
 80050a4:	08005d0d 	.word	0x08005d0d
 80050a8:	080050c5 	.word	0x080050c5
 80050ac:	080050d7 	.word	0x080050d7
 80050b0:	08006383 	.word	0x08006383
 80050b4:	080069a1 	.word	0x080069a1
 80050b8:	08006383 	.word	0x08006383
 80050bc:	080069a1 	.word	0x080069a1
 80050c0:	08006383 	.word	0x08006383
	    goto tcp_send_synack;
	    
#if UIP_ACTIVE_OPEN
	  case UIP_SYN_SENT:
	    /* In the SYN_SENT state, we retransmit out SYN. */
	    BUF->flags = 0;
 80050c4:	f241 7318 	movw	r3, #5912	; 0x1718
 80050c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80050cc:	2200      	movs	r2, #0
 80050ce:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
	    goto tcp_send_syn;
 80050d2:	f000 be27 	b.w	8005d24 <uip_process+0xe68>
	  case UIP_ESTABLISHED:
	    /* In the ESTABLISHED state, we call upon the application
               to do the actual retransmit after which we jump into
               the code for sending out the packet (the apprexmit
               label). */
	    uip_flags = UIP_REXMIT;
 80050d6:	f641 03bc 	movw	r3, #6332	; 0x18bc
 80050da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80050de:	2204      	movs	r2, #4
 80050e0:	701a      	strb	r2, [r3, #0]
	    UIP_APPCALL();
 80050e2:	f001 feff 	bl	8006ee4 <tcpip_uipcall>
	    goto apprexmit;
 80050e6:	f001 ba60 	b.w	80065aa <uip_process+0x16ee>
	    /* In all these states we should retransmit a FINACK. */
	    goto tcp_send_finack;
	    
	  }
	}
      } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
 80050ea:	7e63      	ldrb	r3, [r4, #25]
 80050ec:	f003 030f 	and.w	r3, r3, #15
 80050f0:	2b03      	cmp	r3, #3
 80050f2:	f041 8455 	bne.w	80069a0 <uip_process+0x1ae4>
	/* If there was no need for a retransmission, we poll the
           application for new data. */
	uip_flags = UIP_POLL;
 80050f6:	f641 03bc 	movw	r3, #6332	; 0x18bc
 80050fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80050fe:	2208      	movs	r2, #8
 8005100:	701a      	strb	r2, [r3, #0]
	UIP_APPCALL();
 8005102:	f001 feef 	bl	8006ee4 <tcpip_uipcall>
	goto appsend;
 8005106:	f001 b9e8 	b.w	80064da <uip_process+0x161e>
      }
    }
    goto drop;
 800510a:	f001 bc49 	b.w	80069a0 <uip_process+0x1ae4>
  }
#if UIP_UDP
  if(flag == UIP_UDP_TIMER) {
 800510e:	79fb      	ldrb	r3, [r7, #7]
 8005110:	2b05      	cmp	r3, #5
 8005112:	d137      	bne.n	8005184 <uip_process+0x2c8>
    if(uip_udp_conn->lport != 0) {
 8005114:	f641 03c0 	movw	r3, #6336	; 0x18c0
 8005118:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800511c:	681b      	ldr	r3, [r3, #0]
 800511e:	889b      	ldrh	r3, [r3, #4]
 8005120:	2b00      	cmp	r3, #0
 8005122:	f001 843f 	beq.w	80069a4 <uip_process+0x1ae8>
      uip_conn = NULL;
 8005126:	f641 03c8 	movw	r3, #6344	; 0x18c8
 800512a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800512e:	2200      	movs	r2, #0
 8005130:	601a      	str	r2, [r3, #0]
      uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
 8005132:	f641 03c4 	movw	r3, #6340	; 0x18c4
 8005136:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800513a:	4a37      	ldr	r2, [pc, #220]	; (8005218 <uip_process+0x35c>)
 800513c:	601a      	str	r2, [r3, #0]
 800513e:	f641 03c4 	movw	r3, #6340	; 0x18c4
 8005142:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005146:	681a      	ldr	r2, [r3, #0]
 8005148:	f241 7310 	movw	r3, #5904	; 0x1710
 800514c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005150:	601a      	str	r2, [r3, #0]
      uip_len = uip_slen = 0;
 8005152:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 8005156:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800515a:	2200      	movs	r2, #0
 800515c:	801a      	strh	r2, [r3, #0]
 800515e:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 8005162:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005166:	881a      	ldrh	r2, [r3, #0]
 8005168:	f241 730c 	movw	r3, #5900	; 0x170c
 800516c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005170:	801a      	strh	r2, [r3, #0]
      uip_flags = UIP_POLL;
 8005172:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8005176:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800517a:	2208      	movs	r2, #8
 800517c:	701a      	strb	r2, [r3, #0]
      UIP_UDP_APPCALL();
 800517e:	f001 feb1 	bl	8006ee4 <tcpip_uipcall>
      goto udp_send;
 8005182:	e1fe      	b.n	8005582 <uip_process+0x6c6>
    UIP_LOG("ipv6: invalid version.");
    goto drop;
  }
#else /* UIP_CONF_IPV6 */
  /* Check validity of the IP header. */
  if(BUF->vhl != 0x45)  { /* IP version and header length. */
 8005184:	f241 7318 	movw	r3, #5912	; 0x1718
 8005188:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800518c:	781b      	ldrb	r3, [r3, #0]
 800518e:	2b45      	cmp	r3, #69	; 0x45
 8005190:	d007      	beq.n	80051a2 <uip_process+0x2e6>
    UIP_STAT(++uip_stat.ip.drop);
    UIP_STAT(++uip_stat.ip.vhlerr);
    UIP_LOG("ip: invalid version or header length.");
 8005192:	f648 7070 	movw	r0, #36720	; 0x8f70
 8005196:	f6c0 0000 	movt	r0, #2048	; 0x800
 800519a:	f7fd fe9b 	bl	8002ed4 <uip_log>
    goto drop;
 800519e:	f001 bc12 	b.w	80069c6 <uip_process+0x1b0a>
     that the packet has been corrupted in transit. If the size of
     uip_len is larger than the size reported in the IP packet header,
     the packet has been padded and we set uip_len to the correct
     value.. */

  if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
 80051a2:	f241 7318 	movw	r3, #5912	; 0x1718
 80051a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80051aa:	789b      	ldrb	r3, [r3, #2]
 80051ac:	021a      	lsls	r2, r3, #8
 80051ae:	f241 7318 	movw	r3, #5912	; 0x1718
 80051b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80051b6:	78db      	ldrb	r3, [r3, #3]
 80051b8:	18d2      	adds	r2, r2, r3
 80051ba:	f241 730c 	movw	r3, #5900	; 0x170c
 80051be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80051c2:	881b      	ldrh	r3, [r3, #0]
 80051c4:	429a      	cmp	r2, r3
 80051c6:	dc1c      	bgt.n	8005202 <uip_process+0x346>
    uip_len = (BUF->len[0] << 8) + BUF->len[1];
 80051c8:	f241 7318 	movw	r3, #5912	; 0x1718
 80051cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80051d0:	789b      	ldrb	r3, [r3, #2]
 80051d2:	021b      	lsls	r3, r3, #8
 80051d4:	b29a      	uxth	r2, r3
 80051d6:	f241 7318 	movw	r3, #5912	; 0x1718
 80051da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80051de:	78db      	ldrb	r3, [r3, #3]
 80051e0:	18d3      	adds	r3, r2, r3
 80051e2:	b29a      	uxth	r2, r3
 80051e4:	f241 730c 	movw	r3, #5900	; 0x170c
 80051e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80051ec:	801a      	strh	r2, [r3, #0]
    goto drop;
  }

#if !UIP_CONF_IPV6
  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
 80051ee:	f241 7318 	movw	r3, #5912	; 0x1718
 80051f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80051f6:	799b      	ldrb	r3, [r3, #6]
 80051f8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80051fc:	2b00      	cmp	r3, #0
 80051fe:	d114      	bne.n	800522a <uip_process+0x36e>
 8005200:	e00c      	b.n	800521c <uip_process+0x360>
		      contains the length of the entire packet. But
		      for IPv6 we need to add the size of the IPv6
		      header (40 bytes). */
#endif /* UIP_CONF_IPV6 */
  } else {
    UIP_LOG("ip: packet shorter than reported in IP header.");
 8005202:	f648 7098 	movw	r0, #36760	; 0x8f98
 8005206:	f6c0 0000 	movt	r0, #2048	; 0x800
 800520a:	f7fd fe63 	bl	8002ed4 <uip_log>
    goto drop;
 800520e:	f001 bbda 	b.w	80069c6 <uip_process+0x1b0a>
 8005212:	bf00      	nop
 8005214:	20001740 	.word	0x20001740
 8005218:	20001734 	.word	0x20001734
  }

#if !UIP_CONF_IPV6
  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
     BUF->ipoffset[1] != 0) {
 800521c:	f241 7318 	movw	r3, #5912	; 0x1718
 8005220:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005224:	79db      	ldrb	r3, [r3, #7]
    goto drop;
  }

#if !UIP_CONF_IPV6
  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
 8005226:	2b00      	cmp	r3, #0
 8005228:	d007      	beq.n	800523a <uip_process+0x37e>
      goto drop;
    }
#else /* UIP_REASSEMBLY */
    UIP_STAT(++uip_stat.ip.drop);
    UIP_STAT(++uip_stat.ip.fragerr);
    UIP_LOG("ip: fragment dropped.");
 800522a:	f648 70c8 	movw	r0, #36808	; 0x8fc8
 800522e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005232:	f7fd fe4f 	bl	8002ed4 <uip_log>
    goto drop;
 8005236:	f001 bbc6 	b.w	80069c6 <uip_process+0x1b0a>
#endif /* UIP_REASSEMBLY */
  }
#endif /* UIP_CONF_IPV6 */

  if(uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr)) {
 800523a:	f641 63c4 	movw	r3, #7876	; 0x1ec4
 800523e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005242:	881a      	ldrh	r2, [r3, #0]
 8005244:	f249 23f4 	movw	r3, #37620	; 0x92f4
 8005248:	f6c0 0300 	movt	r3, #2048	; 0x800
 800524c:	881b      	ldrh	r3, [r3, #0]
 800524e:	429a      	cmp	r2, r3
 8005250:	d10b      	bne.n	800526a <uip_process+0x3ae>
 8005252:	f641 63c4 	movw	r3, #7876	; 0x1ec4
 8005256:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800525a:	885a      	ldrh	r2, [r3, #2]
 800525c:	f249 23f4 	movw	r3, #37620	; 0x92f4
 8005260:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005264:	885b      	ldrh	r3, [r3, #2]
 8005266:	429a      	cmp	r2, r3
 8005268:	d013      	beq.n	8005292 <uip_process+0x3d6>
    }
#endif /* UIP_BROADCAST */
    
    /* Check if the packet is destined for our IP address. */
#if !UIP_CONF_IPV6
    if(!uip_ipaddr_cmp(&BUF->destipaddr, &uip_hostaddr)) {
 800526a:	4bc1      	ldr	r3, [pc, #772]	; (8005570 <uip_process+0x6b4>)
 800526c:	881a      	ldrh	r2, [r3, #0]
 800526e:	f641 63c4 	movw	r3, #7876	; 0x1ec4
 8005272:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005276:	881b      	ldrh	r3, [r3, #0]
 8005278:	429a      	cmp	r2, r3
 800527a:	f041 83a4 	bne.w	80069c6 <uip_process+0x1b0a>
 800527e:	4bbc      	ldr	r3, [pc, #752]	; (8005570 <uip_process+0x6b4>)
 8005280:	885a      	ldrh	r2, [r3, #2]
 8005282:	f641 63c4 	movw	r3, #7876	; 0x1ec4
 8005286:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800528a:	885b      	ldrh	r3, [r3, #2]
 800528c:	429a      	cmp	r2, r3
 800528e:	f041 839a 	bne.w	80069c6 <uip_process+0x1b0a>
    }
#endif /* UIP_CONF_IPV6 */
  }

#if !UIP_CONF_IPV6
  if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
 8005292:	f7ff fc57 	bl	8004b44 <uip_ipchksum>
 8005296:	4603      	mov	r3, r0
 8005298:	461a      	mov	r2, r3
 800529a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800529e:	429a      	cmp	r2, r3
 80052a0:	d007      	beq.n	80052b2 <uip_process+0x3f6>
				    checksum. */
    UIP_STAT(++uip_stat.ip.drop);
    UIP_STAT(++uip_stat.ip.chkerr);
    UIP_LOG("ip: bad checksum.");
 80052a2:	f648 70e0 	movw	r0, #36832	; 0x8fe0
 80052a6:	f6c0 0000 	movt	r0, #2048	; 0x800
 80052aa:	f7fd fe13 	bl	8002ed4 <uip_log>
    goto drop;
 80052ae:	f001 bb8a 	b.w	80069c6 <uip_process+0x1b0a>
  }
#endif /* UIP_CONF_IPV6 */

  if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
 80052b2:	f241 7318 	movw	r3, #5912	; 0x1718
 80052b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80052ba:	7a5b      	ldrb	r3, [r3, #9]
 80052bc:	2b06      	cmp	r3, #6
 80052be:	f000 8205 	beq.w	80056cc <uip_process+0x810>
				       processing. */
    goto tcp_input;
  }

#if UIP_UDP
  if(BUF->proto == UIP_PROTO_UDP) {
 80052c2:	f241 7318 	movw	r3, #5912	; 0x1718
 80052c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80052ca:	7a5b      	ldrb	r3, [r3, #9]
 80052cc:	2b11      	cmp	r3, #17
 80052ce:	d058      	beq.n	8005382 <uip_process+0x4c6>
  }
#endif /* UIP_UDP */

#if !UIP_CONF_IPV6
  /* ICMPv4 processing code follows. */
  if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
 80052d0:	f241 7318 	movw	r3, #5912	; 0x1718
 80052d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80052d8:	7a5b      	ldrb	r3, [r3, #9]
 80052da:	2b01      	cmp	r3, #1
 80052dc:	d007      	beq.n	80052ee <uip_process+0x432>
					here. */
    UIP_STAT(++uip_stat.ip.drop);
    UIP_STAT(++uip_stat.ip.protoerr);
    UIP_LOG("ip: neither tcp nor icmp.");
 80052de:	f648 70f4 	movw	r0, #36852	; 0x8ff4
 80052e2:	f6c0 0000 	movt	r0, #2048	; 0x800
 80052e6:	f7fd fdf5 	bl	8002ed4 <uip_log>
    goto drop;
 80052ea:	f001 bb6c 	b.w	80069c6 <uip_process+0x1b0a>
  UIP_STAT(++uip_stat.icmp.recv);

  /* ICMP echo (i.e., ping) processing. This is simple, we only change
     the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
     checksum before we return the packet. */
  if(ICMPBUF->type != ICMP_ECHO) {
 80052ee:	f241 7318 	movw	r3, #5912	; 0x1718
 80052f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80052f6:	7d1b      	ldrb	r3, [r3, #20]
 80052f8:	2b08      	cmp	r3, #8
 80052fa:	d007      	beq.n	800530c <uip_process+0x450>
    UIP_STAT(++uip_stat.icmp.drop);
    UIP_STAT(++uip_stat.icmp.typeerr);
    UIP_LOG("icmp: not icmp echo.");
 80052fc:	f249 0010 	movw	r0, #36880	; 0x9010
 8005300:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005304:	f7fd fde6 	bl	8002ed4 <uip_log>
    goto drop;
 8005308:	f001 bb5d 	b.w	80069c6 <uip_process+0x1b0a>
  if(uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr)) {
    uip_hostaddr = BUF->destipaddr;
  }
#endif /* UIP_PINGADDRCONF */

  ICMPBUF->type = ICMP_ECHO_REPLY;
 800530c:	f241 7318 	movw	r3, #5912	; 0x1718
 8005310:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005314:	2200      	movs	r2, #0
 8005316:	751a      	strb	r2, [r3, #20]

  if(ICMPBUF->icmpchksum >= UIP_HTONS(0xffff - (ICMP_ECHO << 8))) {
 8005318:	f241 7318 	movw	r3, #5912	; 0x1718
 800531c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005320:	8ada      	ldrh	r2, [r3, #22]
 8005322:	f64f 73f6 	movw	r3, #65526	; 0xfff6
 8005326:	429a      	cmp	r2, r3
 8005328:	d90c      	bls.n	8005344 <uip_process+0x488>
    ICMPBUF->icmpchksum += UIP_HTONS(ICMP_ECHO << 8) + 1;
 800532a:	f241 7318 	movw	r3, #5912	; 0x1718
 800532e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005332:	f241 7218 	movw	r2, #5912	; 0x1718
 8005336:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800533a:	8ad2      	ldrh	r2, [r2, #22]
 800533c:	3209      	adds	r2, #9
 800533e:	b292      	uxth	r2, r2
 8005340:	82da      	strh	r2, [r3, #22]
 8005342:	e00b      	b.n	800535c <uip_process+0x4a0>
  } else {
    ICMPBUF->icmpchksum += UIP_HTONS(ICMP_ECHO << 8);
 8005344:	f241 7318 	movw	r3, #5912	; 0x1718
 8005348:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800534c:	f241 7218 	movw	r2, #5912	; 0x1718
 8005350:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005354:	8ad2      	ldrh	r2, [r2, #22]
 8005356:	3208      	adds	r2, #8
 8005358:	b292      	uxth	r2, r2
 800535a:	82da      	strh	r2, [r3, #22]
  }

  /* Swap IP addresses. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
 800535c:	4b84      	ldr	r3, [pc, #528]	; (8005570 <uip_process+0x6b4>)
 800535e:	4a85      	ldr	r2, [pc, #532]	; (8005574 <uip_process+0x6b8>)
 8005360:	6812      	ldr	r2, [r2, #0]
 8005362:	601a      	str	r2, [r3, #0]
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
 8005364:	4a83      	ldr	r2, [pc, #524]	; (8005574 <uip_process+0x6b8>)
 8005366:	f641 63c4 	movw	r3, #7876	; 0x1ec4
 800536a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800536e:	6818      	ldr	r0, [r3, #0]
 8005370:	6010      	str	r0, [r2, #0]

  UIP_STAT(++uip_stat.icmp.sent);
  BUF->ttl = UIP_TTL;
 8005372:	f241 7318 	movw	r3, #5912	; 0x1718
 8005376:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800537a:	2240      	movs	r2, #64	; 0x40
 800537c:	721a      	strb	r2, [r3, #8]
  goto ip_send_nolen;
 800537e:	f001 baba 	b.w	80068f6 <uip_process+0x1a3a>
    goto tcp_input;
  }

#if UIP_UDP
  if(BUF->proto == UIP_PROTO_UDP) {
    goto udp_input;
 8005382:	bf00      	nop
  /* UDP processing is really just a hack. We don't do anything to the
     UDP/IP headers, but let the UDP application do all the hard
     work. If the application sets uip_slen, it has a packet to
     send. */
#if UIP_UDP_CHECKSUMS
  uip_len = uip_len - UIP_IPUDPH_LEN;
 8005384:	f241 730c 	movw	r3, #5900	; 0x170c
 8005388:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800538c:	881b      	ldrh	r3, [r3, #0]
 800538e:	3b1c      	subs	r3, #28
 8005390:	b29a      	uxth	r2, r3
 8005392:	f241 730c 	movw	r3, #5900	; 0x170c
 8005396:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800539a:	801a      	strh	r2, [r3, #0]
  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
 800539c:	f641 03c4 	movw	r3, #6340	; 0x18c4
 80053a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80053a4:	4a74      	ldr	r2, [pc, #464]	; (8005578 <uip_process+0x6bc>)
 80053a6:	601a      	str	r2, [r3, #0]
  if(UDPBUF->udpchksum != 0 && uip_udpchksum() != 0xffff) {
 80053a8:	f241 7318 	movw	r3, #5912	; 0x1718
 80053ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80053b0:	8b5b      	ldrh	r3, [r3, #26]
 80053b2:	2b00      	cmp	r3, #0
 80053b4:	d00f      	beq.n	80053d6 <uip_process+0x51a>
 80053b6:	f7ff fc2b 	bl	8004c10 <uip_udpchksum>
 80053ba:	4603      	mov	r3, r0
 80053bc:	461a      	mov	r2, r3
 80053be:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80053c2:	429a      	cmp	r2, r3
 80053c4:	d007      	beq.n	80053d6 <uip_process+0x51a>
    UIP_STAT(++uip_stat.udp.drop);
    UIP_STAT(++uip_stat.udp.chkerr);
    UIP_LOG("udp: bad checksum.");
 80053c6:	f249 0028 	movw	r0, #36904	; 0x9028
 80053ca:	f6c0 0000 	movt	r0, #2048	; 0x800
 80053ce:	f7fd fd81 	bl	8002ed4 <uip_log>
    goto drop;
 80053d2:	f001 baf8 	b.w	80069c6 <uip_process+0x1b0a>
#else /* UIP_UDP_CHECKSUMS */
  uip_len = uip_len - UIP_IPUDPH_LEN;
#endif /* UIP_UDP_CHECKSUMS */

  /* Make sure that the UDP destination port number is not zero. */
  if(UDPBUF->destport == 0) {
 80053d6:	f241 7318 	movw	r3, #5912	; 0x1718
 80053da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80053de:	8adb      	ldrh	r3, [r3, #22]
 80053e0:	2b00      	cmp	r3, #0
 80053e2:	d107      	bne.n	80053f4 <uip_process+0x538>
    UIP_LOG("udp: zero port.");
 80053e4:	f249 003c 	movw	r0, #36924	; 0x903c
 80053e8:	f6c0 0000 	movt	r0, #2048	; 0x800
 80053ec:	f7fd fd72 	bl	8002ed4 <uip_log>
    goto drop;
 80053f0:	f001 bae9 	b.w	80069c6 <uip_process+0x1b0a>
  }

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
 80053f4:	f641 03c0 	movw	r3, #6336	; 0x18c0
 80053f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80053fc:	f641 62cc 	movw	r2, #7884	; 0x1ecc
 8005400:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005404:	601a      	str	r2, [r3, #0]
 8005406:	e07d      	b.n	8005504 <uip_process+0x648>
       destination port number in the received packet. If the two port
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
 8005408:	f641 03c0 	movw	r3, #6336	; 0x18c0
 800540c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005410:	681b      	ldr	r3, [r3, #0]
 8005412:	889b      	ldrh	r3, [r3, #4]
 8005414:	2b00      	cmp	r3, #0
 8005416:	d069      	beq.n	80054ec <uip_process+0x630>
       UDPBUF->destport == uip_udp_conn->lport &&
 8005418:	f241 7318 	movw	r3, #5912	; 0x1718
 800541c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005420:	8ada      	ldrh	r2, [r3, #22]
 8005422:	f641 03c0 	movw	r3, #6336	; 0x18c0
 8005426:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800542a:	681b      	ldr	r3, [r3, #0]
 800542c:	889b      	ldrh	r3, [r3, #4]
       destination port number in the received packet. If the two port
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
 800542e:	429a      	cmp	r2, r3
 8005430:	d15c      	bne.n	80054ec <uip_process+0x630>
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
 8005432:	f641 03c0 	movw	r3, #6336	; 0x18c0
 8005436:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800543a:	681b      	ldr	r3, [r3, #0]
 800543c:	88db      	ldrh	r3, [r3, #6]
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
 800543e:	2b00      	cmp	r3, #0
 8005440:	d00c      	beq.n	800545c <uip_process+0x5a0>
       (uip_udp_conn->rport == 0 ||
        UDPBUF->srcport == uip_udp_conn->rport) &&
 8005442:	f241 7318 	movw	r3, #5912	; 0x1718
 8005446:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800544a:	8a9a      	ldrh	r2, [r3, #20]
 800544c:	f641 03c0 	movw	r3, #6336	; 0x18c0
 8005450:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005454:	681b      	ldr	r3, [r3, #0]
 8005456:	88db      	ldrh	r3, [r3, #6]
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
 8005458:	429a      	cmp	r2, r3
 800545a:	d147      	bne.n	80054ec <uip_process+0x630>
        UDPBUF->srcport == uip_udp_conn->rport) &&
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
 800545c:	f641 03c0 	movw	r3, #6336	; 0x18c0
 8005460:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005464:	681b      	ldr	r3, [r3, #0]
 8005466:	881a      	ldrh	r2, [r3, #0]
 8005468:	f249 23f4 	movw	r3, #37620	; 0x92f4
 800546c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005470:	881b      	ldrh	r3, [r3, #0]
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
        UDPBUF->srcport == uip_udp_conn->rport) &&
 8005472:	429a      	cmp	r2, r3
 8005474:	d10c      	bne.n	8005490 <uip_process+0x5d4>
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
 8005476:	f641 03c0 	movw	r3, #6336	; 0x18c0
 800547a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800547e:	681b      	ldr	r3, [r3, #0]
 8005480:	885a      	ldrh	r2, [r3, #2]
 8005482:	f249 23f4 	movw	r3, #37620	; 0x92f4
 8005486:	f6c0 0300 	movt	r3, #2048	; 0x800
 800548a:	885b      	ldrh	r3, [r3, #2]
 800548c:	429a      	cmp	r2, r3
 800548e:	d04a      	beq.n	8005526 <uip_process+0x66a>
	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
 8005490:	f641 03c0 	movw	r3, #6336	; 0x18c0
 8005494:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005498:	681b      	ldr	r3, [r3, #0]
 800549a:	881a      	ldrh	r2, [r3, #0]
 800549c:	f249 23f0 	movw	r3, #37616	; 0x92f0
 80054a0:	f6c0 0300 	movt	r3, #2048	; 0x800
 80054a4:	881b      	ldrh	r3, [r3, #0]
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
        UDPBUF->srcport == uip_udp_conn->rport) &&
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
 80054a6:	429a      	cmp	r2, r3
 80054a8:	d10c      	bne.n	80054c4 <uip_process+0x608>
	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
 80054aa:	f641 03c0 	movw	r3, #6336	; 0x18c0
 80054ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80054b2:	681b      	ldr	r3, [r3, #0]
 80054b4:	885a      	ldrh	r2, [r3, #2]
 80054b6:	f249 23f0 	movw	r3, #37616	; 0x92f0
 80054ba:	f6c0 0300 	movt	r3, #2048	; 0x800
 80054be:	885b      	ldrh	r3, [r3, #2]
 80054c0:	429a      	cmp	r2, r3
 80054c2:	d030      	beq.n	8005526 <uip_process+0x66a>
	uip_ipaddr_cmp(&BUF->srcipaddr, &uip_udp_conn->ripaddr))) {
 80054c4:	4b2b      	ldr	r3, [pc, #172]	; (8005574 <uip_process+0x6b8>)
 80054c6:	881a      	ldrh	r2, [r3, #0]
 80054c8:	f641 03c0 	movw	r3, #6336	; 0x18c0
 80054cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80054d0:	681b      	ldr	r3, [r3, #0]
 80054d2:	881b      	ldrh	r3, [r3, #0]
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
        UDPBUF->srcport == uip_udp_conn->rport) &&
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
 80054d4:	429a      	cmp	r2, r3
 80054d6:	d109      	bne.n	80054ec <uip_process+0x630>
	uip_ipaddr_cmp(&BUF->srcipaddr, &uip_udp_conn->ripaddr))) {
 80054d8:	4b26      	ldr	r3, [pc, #152]	; (8005574 <uip_process+0x6b8>)
 80054da:	885a      	ldrh	r2, [r3, #2]
 80054dc:	f641 03c0 	movw	r3, #6336	; 0x18c0
 80054e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80054e4:	681b      	ldr	r3, [r3, #0]
 80054e6:	885b      	ldrh	r3, [r3, #2]
 80054e8:	429a      	cmp	r2, r3
 80054ea:	d01c      	beq.n	8005526 <uip_process+0x66a>
  }

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
      ++uip_udp_conn) {
 80054ec:	f641 03c0 	movw	r3, #6336	; 0x18c0
 80054f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80054f4:	681b      	ldr	r3, [r3, #0]
 80054f6:	f103 0214 	add.w	r2, r3, #20
 80054fa:	f641 03c0 	movw	r3, #6336	; 0x18c0
 80054fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005502:	601a      	str	r2, [r3, #0]
    goto drop;
  }

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
 8005504:	f641 03c0 	movw	r3, #6336	; 0x18c0
 8005508:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800550c:	681a      	ldr	r2, [r3, #0]
    UIP_LOG("udp: zero port.");
    goto drop;
  }

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
 800550e:	4b1b      	ldr	r3, [pc, #108]	; (800557c <uip_process+0x6c0>)
 8005510:	429a      	cmp	r2, r3
 8005512:	f4ff af79 	bcc.w	8005408 <uip_process+0x54c>
	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
	uip_ipaddr_cmp(&BUF->srcipaddr, &uip_udp_conn->ripaddr))) {
      goto udp_found;
    }
  }
  UIP_LOG("udp: no matching connection found");
 8005516:	f249 004c 	movw	r0, #36940	; 0x904c
 800551a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800551e:	f7fd fcd9 	bl	8002ed4 <uip_log>
  ICMPBUF->ttl = UIP_TTL;
  ICMPBUF->proto = UIP_PROTO_ICMP;

  goto ip_send_nolen;
#else /* UIP_CONF_ICMP_DEST_UNREACH */
  goto drop;
 8005522:	f001 ba50 	b.w	80069c6 <uip_process+0x1b0a>
#endif /* UIP_CONF_ICMP_DEST_UNREACH */
  
 udp_found:
  uip_conn = NULL;
 8005526:	f641 03c8 	movw	r3, #6344	; 0x18c8
 800552a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800552e:	2200      	movs	r2, #0
 8005530:	601a      	str	r2, [r3, #0]
  uip_flags = UIP_NEWDATA;
 8005532:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8005536:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800553a:	2202      	movs	r2, #2
 800553c:	701a      	strb	r2, [r3, #0]
  uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
 800553e:	f641 03c4 	movw	r3, #6340	; 0x18c4
 8005542:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005546:	4a0c      	ldr	r2, [pc, #48]	; (8005578 <uip_process+0x6bc>)
 8005548:	601a      	str	r2, [r3, #0]
 800554a:	f641 03c4 	movw	r3, #6340	; 0x18c4
 800554e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005552:	681a      	ldr	r2, [r3, #0]
 8005554:	f241 7310 	movw	r3, #5904	; 0x1710
 8005558:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800555c:	601a      	str	r2, [r3, #0]
  uip_slen = 0;
 800555e:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 8005562:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005566:	2200      	movs	r2, #0
 8005568:	801a      	strh	r2, [r3, #0]
  UIP_UDP_APPCALL();
 800556a:	f001 fcbb 	bl	8006ee4 <tcpip_uipcall>
 800556e:	e008      	b.n	8005582 <uip_process+0x6c6>
 8005570:	20001728 	.word	0x20001728
 8005574:	20001724 	.word	0x20001724
 8005578:	20001734 	.word	0x20001734
 800557c:	20001f94 	.word	0x20001f94
{
  register struct uip_conn *uip_connr = uip_conn;

#if UIP_UDP
  if(flag == UIP_UDP_SEND_CONN) {
    goto udp_send;
 8005580:	bf00      	nop
  uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
  uip_slen = 0;
  UIP_UDP_APPCALL();

 udp_send:
  if(uip_slen == 0) {
 8005582:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 8005586:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800558a:	881b      	ldrh	r3, [r3, #0]
 800558c:	2b00      	cmp	r3, #0
 800558e:	f001 820b 	beq.w	80069a8 <uip_process+0x1aec>
    goto drop;
  }
  uip_len = uip_slen + UIP_IPUDPH_LEN;
 8005592:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 8005596:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800559a:	881b      	ldrh	r3, [r3, #0]
 800559c:	331c      	adds	r3, #28
 800559e:	b29a      	uxth	r2, r3
 80055a0:	f241 730c 	movw	r3, #5900	; 0x170c
 80055a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80055a8:	801a      	strh	r2, [r3, #0]
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
 80055aa:	f241 7318 	movw	r3, #5912	; 0x1718
 80055ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80055b2:	f241 720c 	movw	r2, #5900	; 0x170c
 80055b6:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80055ba:	8812      	ldrh	r2, [r2, #0]
 80055bc:	0a12      	lsrs	r2, r2, #8
 80055be:	b292      	uxth	r2, r2
 80055c0:	b2d2      	uxtb	r2, r2
 80055c2:	709a      	strb	r2, [r3, #2]
  BUF->len[1] = (uip_len & 0xff);
 80055c4:	f241 7318 	movw	r3, #5912	; 0x1718
 80055c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80055cc:	f241 720c 	movw	r2, #5900	; 0x170c
 80055d0:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80055d4:	8812      	ldrh	r2, [r2, #0]
 80055d6:	b2d2      	uxtb	r2, r2
 80055d8:	70da      	strb	r2, [r3, #3]
#endif /* UIP_CONF_IPV6 */

  BUF->ttl = uip_udp_conn->ttl;
 80055da:	f241 7318 	movw	r3, #5912	; 0x1718
 80055de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80055e2:	f641 02c0 	movw	r2, #6336	; 0x18c0
 80055e6:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80055ea:	6812      	ldr	r2, [r2, #0]
 80055ec:	7a12      	ldrb	r2, [r2, #8]
 80055ee:	721a      	strb	r2, [r3, #8]
  BUF->proto = UIP_PROTO_UDP;
 80055f0:	f241 7318 	movw	r3, #5912	; 0x1718
 80055f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80055f8:	2211      	movs	r2, #17
 80055fa:	725a      	strb	r2, [r3, #9]

  UDPBUF->udplen = UIP_HTONS(uip_slen + UIP_UDPH_LEN);
 80055fc:	f241 7318 	movw	r3, #5912	; 0x1718
 8005600:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005604:	f641 62c8 	movw	r2, #7880	; 0x1ec8
 8005608:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800560c:	8812      	ldrh	r2, [r2, #0]
 800560e:	3208      	adds	r2, #8
 8005610:	b292      	uxth	r2, r2
 8005612:	0212      	lsls	r2, r2, #8
 8005614:	b291      	uxth	r1, r2
 8005616:	f641 62c8 	movw	r2, #7880	; 0x1ec8
 800561a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800561e:	8812      	ldrh	r2, [r2, #0]
 8005620:	3208      	adds	r2, #8
 8005622:	b292      	uxth	r2, r2
 8005624:	0a12      	lsrs	r2, r2, #8
 8005626:	b292      	uxth	r2, r2
 8005628:	b292      	uxth	r2, r2
 800562a:	430a      	orrs	r2, r1
 800562c:	b292      	uxth	r2, r2
 800562e:	b292      	uxth	r2, r2
 8005630:	831a      	strh	r2, [r3, #24]
  UDPBUF->udpchksum = 0;
 8005632:	f241 7318 	movw	r3, #5912	; 0x1718
 8005636:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800563a:	2200      	movs	r2, #0
 800563c:	835a      	strh	r2, [r3, #26]

  BUF->srcport  = uip_udp_conn->lport;
 800563e:	f241 7318 	movw	r3, #5912	; 0x1718
 8005642:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005646:	f641 02c0 	movw	r2, #6336	; 0x18c0
 800564a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800564e:	6812      	ldr	r2, [r2, #0]
 8005650:	8892      	ldrh	r2, [r2, #4]
 8005652:	829a      	strh	r2, [r3, #20]
  BUF->destport = uip_udp_conn->rport;
 8005654:	f241 7318 	movw	r3, #5912	; 0x1718
 8005658:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800565c:	f641 02c0 	movw	r2, #6336	; 0x18c0
 8005660:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005664:	6812      	ldr	r2, [r2, #0]
 8005666:	88d2      	ldrh	r2, [r2, #6]
 8005668:	82da      	strh	r2, [r3, #22]

  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
 800566a:	4a61      	ldr	r2, [pc, #388]	; (80057f0 <uip_process+0x934>)
 800566c:	f641 63c4 	movw	r3, #7876	; 0x1ec4
 8005670:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005674:	6818      	ldr	r0, [r3, #0]
 8005676:	6010      	str	r0, [r2, #0]
  uip_ipaddr_copy(&BUF->destipaddr, &uip_udp_conn->ripaddr);
 8005678:	495e      	ldr	r1, [pc, #376]	; (80057f4 <uip_process+0x938>)
 800567a:	f641 03c0 	movw	r3, #6336	; 0x18c0
 800567e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005682:	681a      	ldr	r2, [r3, #0]
 8005684:	460b      	mov	r3, r1
 8005686:	6810      	ldr	r0, [r2, #0]
 8005688:	6018      	str	r0, [r3, #0]
   
  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
 800568a:	f641 03c4 	movw	r3, #6340	; 0x18c4
 800568e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005692:	4a59      	ldr	r2, [pc, #356]	; (80057f8 <uip_process+0x93c>)
 8005694:	601a      	str	r2, [r3, #0]

#if UIP_UDP_CHECKSUMS
  /* Calculate UDP checksum. */
  UDPBUF->udpchksum = ~(uip_udpchksum());
 8005696:	f241 7418 	movw	r4, #5912	; 0x1718
 800569a:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800569e:	f7ff fab7 	bl	8004c10 <uip_udpchksum>
 80056a2:	4603      	mov	r3, r0
 80056a4:	43db      	mvns	r3, r3
 80056a6:	b29b      	uxth	r3, r3
 80056a8:	8363      	strh	r3, [r4, #26]
  if(UDPBUF->udpchksum == 0) {
 80056aa:	f241 7318 	movw	r3, #5912	; 0x1718
 80056ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80056b2:	8b5b      	ldrh	r3, [r3, #26]
 80056b4:	2b00      	cmp	r3, #0
 80056b6:	f041 811d 	bne.w	80068f4 <uip_process+0x1a38>
    UDPBUF->udpchksum = 0xffff;
 80056ba:	f241 7318 	movw	r3, #5912	; 0x1718
 80056be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80056c2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80056c6:	835a      	strh	r2, [r3, #26]
  }
#endif /* UIP_UDP_CHECKSUMS */
  
  goto ip_send_nolen;
 80056c8:	f001 b914 	b.w	80068f4 <uip_process+0x1a38>
#endif /* UIP_CONF_IPV6 */

  if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
				       proceed with TCP input
				       processing. */
    goto tcp_input;
 80056cc:	bf00      	nop
 tcp_input:
  UIP_STAT(++uip_stat.tcp.recv);

  /* Start of TCP input header processing code. */
  
  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
 80056ce:	f7ff fa97 	bl	8004c00 <uip_tcpchksum>
 80056d2:	4603      	mov	r3, r0
 80056d4:	461a      	mov	r2, r3
 80056d6:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80056da:	429a      	cmp	r2, r3
 80056dc:	d007      	beq.n	80056ee <uip_process+0x832>
				       checksum. */
    UIP_STAT(++uip_stat.tcp.drop);
    UIP_STAT(++uip_stat.tcp.chkerr);
    UIP_LOG("tcp: bad checksum.");
 80056de:	f249 0070 	movw	r0, #36976	; 0x9070
 80056e2:	f6c0 0000 	movt	r0, #2048	; 0x800
 80056e6:	f7fd fbf5 	bl	8002ed4 <uip_log>
    goto drop;
 80056ea:	f001 b96c 	b.w	80069c6 <uip_process+0x1b0a>
  }

  /* Make sure that the TCP port number is not zero. */
  if(BUF->destport == 0 || BUF->srcport == 0) {
 80056ee:	f241 7318 	movw	r3, #5912	; 0x1718
 80056f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80056f6:	8adb      	ldrh	r3, [r3, #22]
 80056f8:	2b00      	cmp	r3, #0
 80056fa:	d006      	beq.n	800570a <uip_process+0x84e>
 80056fc:	f241 7318 	movw	r3, #5912	; 0x1718
 8005700:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005704:	8a9b      	ldrh	r3, [r3, #20]
 8005706:	2b00      	cmp	r3, #0
 8005708:	d107      	bne.n	800571a <uip_process+0x85e>
    UIP_LOG("tcp: zero port.");
 800570a:	f249 0084 	movw	r0, #36996	; 0x9084
 800570e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005712:	f7fd fbdf 	bl	8002ed4 <uip_log>
    goto drop;
 8005716:	f001 b956 	b.w	80069c6 <uip_process+0x1b0a>
  }
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
 800571a:	f641 04cc 	movw	r4, #6348	; 0x18cc
 800571e:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8005722:	e01e      	b.n	8005762 <uip_process+0x8a6>
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
 8005724:	7e63      	ldrb	r3, [r4, #25]
 8005726:	2b00      	cmp	r3, #0
 8005728:	d01a      	beq.n	8005760 <uip_process+0x8a4>
       BUF->destport == uip_connr->lport &&
 800572a:	f241 7318 	movw	r3, #5912	; 0x1718
 800572e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005732:	8ada      	ldrh	r2, [r3, #22]
 8005734:	88a3      	ldrh	r3, [r4, #4]
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
 8005736:	429a      	cmp	r2, r3
 8005738:	d112      	bne.n	8005760 <uip_process+0x8a4>
       BUF->destport == uip_connr->lport &&
       BUF->srcport == uip_connr->rport &&
 800573a:	f241 7318 	movw	r3, #5912	; 0x1718
 800573e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005742:	8a9a      	ldrh	r2, [r3, #20]
 8005744:	88e3      	ldrh	r3, [r4, #6]
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
       BUF->destport == uip_connr->lport &&
 8005746:	429a      	cmp	r2, r3
 8005748:	d10a      	bne.n	8005760 <uip_process+0x8a4>
       BUF->srcport == uip_connr->rport &&
       uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)) {
 800574a:	4b29      	ldr	r3, [pc, #164]	; (80057f0 <uip_process+0x934>)
 800574c:	881a      	ldrh	r2, [r3, #0]
 800574e:	8823      	ldrh	r3, [r4, #0]
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
       BUF->destport == uip_connr->lport &&
       BUF->srcport == uip_connr->rport &&
 8005750:	429a      	cmp	r2, r3
 8005752:	d105      	bne.n	8005760 <uip_process+0x8a4>
       uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)) {
 8005754:	4b26      	ldr	r3, [pc, #152]	; (80057f0 <uip_process+0x934>)
 8005756:	885a      	ldrh	r2, [r3, #2]
 8005758:	8863      	ldrh	r3, [r4, #2]
 800575a:	429a      	cmp	r2, r3
 800575c:	f000 831c 	beq.w	8005d98 <uip_process+0xedc>
  }
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
 8005760:	3424      	adds	r4, #36	; 0x24
    goto drop;
  }
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
 8005762:	4b26      	ldr	r3, [pc, #152]	; (80057fc <uip_process+0x940>)
 8005764:	429c      	cmp	r4, r3
 8005766:	d9dd      	bls.n	8005724 <uip_process+0x868>

  /* If we didn't find and active connection that expected the packet,
     either this packet is an old duplicate, or this is a SYN packet
     destined for a connection in LISTEN. If the SYN flag isn't set,
     it is an old packet and we send a RST. */
  if((BUF->flags & TCP_CTL) != TCP_SYN) {
 8005768:	f241 7318 	movw	r3, #5912	; 0x1718
 800576c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005770:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8005774:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8005778:	2b02      	cmp	r3, #2
 800577a:	d141      	bne.n	8005800 <uip_process+0x944>
    goto reset;
  }
  
  tmp16 = BUF->destport;
 800577c:	f241 7318 	movw	r3, #5912	; 0x1718
 8005780:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005784:	8ada      	ldrh	r2, [r3, #22]
 8005786:	f241 5374 	movw	r3, #5492	; 0x1574
 800578a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800578e:	801a      	strh	r2, [r3, #0]
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
 8005790:	f241 5372 	movw	r3, #5490	; 0x1572
 8005794:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005798:	2200      	movs	r2, #0
 800579a:	701a      	strb	r2, [r3, #0]
 800579c:	e01f      	b.n	80057de <uip_process+0x922>
    if(tmp16 == uip_listenports[c]) {
 800579e:	f241 5372 	movw	r3, #5490	; 0x1572
 80057a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057a6:	781b      	ldrb	r3, [r3, #0]
 80057a8:	461a      	mov	r2, r3
 80057aa:	f641 636c 	movw	r3, #7788	; 0x1e6c
 80057ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057b2:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 80057b6:	f241 5374 	movw	r3, #5492	; 0x1574
 80057ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057be:	881b      	ldrh	r3, [r3, #0]
 80057c0:	429a      	cmp	r2, r3
 80057c2:	f000 8109 	beq.w	80059d8 <uip_process+0xb1c>
    goto reset;
  }
  
  tmp16 = BUF->destport;
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
 80057c6:	f241 5372 	movw	r3, #5490	; 0x1572
 80057ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057ce:	781b      	ldrb	r3, [r3, #0]
 80057d0:	3301      	adds	r3, #1
 80057d2:	b2da      	uxtb	r2, r3
 80057d4:	f241 5372 	movw	r3, #5490	; 0x1572
 80057d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057dc:	701a      	strb	r2, [r3, #0]
 80057de:	f241 5372 	movw	r3, #5490	; 0x1572
 80057e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057e6:	781b      	ldrb	r3, [r3, #0]
 80057e8:	2b27      	cmp	r3, #39	; 0x27
 80057ea:	d9d8      	bls.n	800579e <uip_process+0x8e2>
 80057ec:	e009      	b.n	8005802 <uip_process+0x946>
 80057ee:	bf00      	nop
 80057f0:	20001724 	.word	0x20001724
 80057f4:	20001728 	.word	0x20001728
 80057f8:	20001740 	.word	0x20001740
 80057fc:	20001e48 	.word	0x20001e48
  /* If we didn't find and active connection that expected the packet,
     either this packet is an old duplicate, or this is a SYN packet
     destined for a connection in LISTEN. If the SYN flag isn't set,
     it is an old packet and we send a RST. */
  if((BUF->flags & TCP_CTL) != TCP_SYN) {
    goto reset;
 8005800:	bf00      	nop
  /* No matching connection found, so we send a RST packet. */
  UIP_STAT(++uip_stat.tcp.synrst);

 reset:
  /* We do not send resets in response to resets. */
  if(BUF->flags & TCP_RST) {
 8005802:	f241 7318 	movw	r3, #5912	; 0x1718
 8005806:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800580a:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800580e:	f003 0304 	and.w	r3, r3, #4
 8005812:	2b00      	cmp	r3, #0
 8005814:	f041 80ca 	bne.w	80069ac <uip_process+0x1af0>
    goto drop;
  }

  UIP_STAT(++uip_stat.tcp.rst);
  
  BUF->flags = TCP_RST | TCP_ACK;
 8005818:	f241 7318 	movw	r3, #5912	; 0x1718
 800581c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005820:	2214      	movs	r2, #20
 8005822:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  uip_len = UIP_IPTCPH_LEN;
 8005826:	f241 730c 	movw	r3, #5900	; 0x170c
 800582a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800582e:	2228      	movs	r2, #40	; 0x28
 8005830:	801a      	strh	r2, [r3, #0]
  BUF->tcpoffset = 5 << 4;
 8005832:	f241 7318 	movw	r3, #5912	; 0x1718
 8005836:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800583a:	2250      	movs	r2, #80	; 0x50
 800583c:	f883 2020 	strb.w	r2, [r3, #32]

  /* Flip the seqno and ackno fields in the TCP header. */
  c = BUF->seqno[3];
 8005840:	f241 7318 	movw	r3, #5912	; 0x1718
 8005844:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005848:	7eda      	ldrb	r2, [r3, #27]
 800584a:	f241 5372 	movw	r3, #5490	; 0x1572
 800584e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005852:	701a      	strb	r2, [r3, #0]
  BUF->seqno[3] = BUF->ackno[3];
 8005854:	f241 7318 	movw	r3, #5912	; 0x1718
 8005858:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800585c:	f241 7218 	movw	r2, #5912	; 0x1718
 8005860:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005864:	7fd2      	ldrb	r2, [r2, #31]
 8005866:	76da      	strb	r2, [r3, #27]
  BUF->ackno[3] = c;
 8005868:	f241 7318 	movw	r3, #5912	; 0x1718
 800586c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005870:	f241 5272 	movw	r2, #5490	; 0x1572
 8005874:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005878:	7812      	ldrb	r2, [r2, #0]
 800587a:	77da      	strb	r2, [r3, #31]
  
  c = BUF->seqno[2];
 800587c:	f241 7318 	movw	r3, #5912	; 0x1718
 8005880:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005884:	7e9a      	ldrb	r2, [r3, #26]
 8005886:	f241 5372 	movw	r3, #5490	; 0x1572
 800588a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800588e:	701a      	strb	r2, [r3, #0]
  BUF->seqno[2] = BUF->ackno[2];
 8005890:	f241 7318 	movw	r3, #5912	; 0x1718
 8005894:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005898:	f241 7218 	movw	r2, #5912	; 0x1718
 800589c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80058a0:	7f92      	ldrb	r2, [r2, #30]
 80058a2:	769a      	strb	r2, [r3, #26]
  BUF->ackno[2] = c;
 80058a4:	f241 7318 	movw	r3, #5912	; 0x1718
 80058a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80058ac:	f241 5272 	movw	r2, #5490	; 0x1572
 80058b0:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80058b4:	7812      	ldrb	r2, [r2, #0]
 80058b6:	779a      	strb	r2, [r3, #30]
  
  c = BUF->seqno[1];
 80058b8:	f241 7318 	movw	r3, #5912	; 0x1718
 80058bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80058c0:	7e5a      	ldrb	r2, [r3, #25]
 80058c2:	f241 5372 	movw	r3, #5490	; 0x1572
 80058c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80058ca:	701a      	strb	r2, [r3, #0]
  BUF->seqno[1] = BUF->ackno[1];
 80058cc:	f241 7318 	movw	r3, #5912	; 0x1718
 80058d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80058d4:	f241 7218 	movw	r2, #5912	; 0x1718
 80058d8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80058dc:	7f52      	ldrb	r2, [r2, #29]
 80058de:	765a      	strb	r2, [r3, #25]
  BUF->ackno[1] = c;
 80058e0:	f241 7318 	movw	r3, #5912	; 0x1718
 80058e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80058e8:	f241 5272 	movw	r2, #5490	; 0x1572
 80058ec:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80058f0:	7812      	ldrb	r2, [r2, #0]
 80058f2:	775a      	strb	r2, [r3, #29]
  
  c = BUF->seqno[0];
 80058f4:	f241 7318 	movw	r3, #5912	; 0x1718
 80058f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80058fc:	7e1a      	ldrb	r2, [r3, #24]
 80058fe:	f241 5372 	movw	r3, #5490	; 0x1572
 8005902:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005906:	701a      	strb	r2, [r3, #0]
  BUF->seqno[0] = BUF->ackno[0];
 8005908:	f241 7318 	movw	r3, #5912	; 0x1718
 800590c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005910:	f241 7218 	movw	r2, #5912	; 0x1718
 8005914:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005918:	7f12      	ldrb	r2, [r2, #28]
 800591a:	761a      	strb	r2, [r3, #24]
  BUF->ackno[0] = c;
 800591c:	f241 7318 	movw	r3, #5912	; 0x1718
 8005920:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005924:	f241 5272 	movw	r2, #5490	; 0x1572
 8005928:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800592c:	7812      	ldrb	r2, [r2, #0]
 800592e:	771a      	strb	r2, [r3, #28]

  /* We also have to increase the sequence number we are
     acknowledging. If the least significant byte overflowed, we need
     to propagate the carry to the other bytes as well. */
  if(++BUF->ackno[3] == 0) {
 8005930:	f241 7318 	movw	r3, #5912	; 0x1718
 8005934:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005938:	7fda      	ldrb	r2, [r3, #31]
 800593a:	3201      	adds	r2, #1
 800593c:	b2d2      	uxtb	r2, r2
 800593e:	77da      	strb	r2, [r3, #31]
 8005940:	7fdb      	ldrb	r3, [r3, #31]
 8005942:	2b00      	cmp	r3, #0
 8005944:	d11d      	bne.n	8005982 <uip_process+0xac6>
    if(++BUF->ackno[2] == 0) {
 8005946:	f241 7318 	movw	r3, #5912	; 0x1718
 800594a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800594e:	7f9a      	ldrb	r2, [r3, #30]
 8005950:	3201      	adds	r2, #1
 8005952:	b2d2      	uxtb	r2, r2
 8005954:	779a      	strb	r2, [r3, #30]
 8005956:	7f9b      	ldrb	r3, [r3, #30]
 8005958:	2b00      	cmp	r3, #0
 800595a:	d112      	bne.n	8005982 <uip_process+0xac6>
      if(++BUF->ackno[1] == 0) {
 800595c:	f241 7318 	movw	r3, #5912	; 0x1718
 8005960:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005964:	7f5a      	ldrb	r2, [r3, #29]
 8005966:	3201      	adds	r2, #1
 8005968:	b2d2      	uxtb	r2, r2
 800596a:	775a      	strb	r2, [r3, #29]
 800596c:	7f5b      	ldrb	r3, [r3, #29]
 800596e:	2b00      	cmp	r3, #0
 8005970:	d107      	bne.n	8005982 <uip_process+0xac6>
	++BUF->ackno[0];
 8005972:	f241 7318 	movw	r3, #5912	; 0x1718
 8005976:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800597a:	7f1a      	ldrb	r2, [r3, #28]
 800597c:	3201      	adds	r2, #1
 800597e:	b2d2      	uxtb	r2, r2
 8005980:	771a      	strb	r2, [r3, #28]
      }
    }
  }
 
  /* Swap port numbers. */
  tmp16 = BUF->srcport;
 8005982:	f241 7318 	movw	r3, #5912	; 0x1718
 8005986:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800598a:	8a9a      	ldrh	r2, [r3, #20]
 800598c:	f241 5374 	movw	r3, #5492	; 0x1574
 8005990:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005994:	801a      	strh	r2, [r3, #0]
  BUF->srcport = BUF->destport;
 8005996:	f241 7318 	movw	r3, #5912	; 0x1718
 800599a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800599e:	f241 7218 	movw	r2, #5912	; 0x1718
 80059a2:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80059a6:	8ad2      	ldrh	r2, [r2, #22]
 80059a8:	829a      	strh	r2, [r3, #20]
  BUF->destport = tmp16;
 80059aa:	f241 7318 	movw	r3, #5912	; 0x1718
 80059ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80059b2:	f241 5274 	movw	r2, #5492	; 0x1574
 80059b6:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80059ba:	8812      	ldrh	r2, [r2, #0]
 80059bc:	82da      	strh	r2, [r3, #22]
  
  /* Swap IP addresses. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
 80059be:	4bd1      	ldr	r3, [pc, #836]	; (8005d04 <uip_process+0xe48>)
 80059c0:	4ad1      	ldr	r2, [pc, #836]	; (8005d08 <uip_process+0xe4c>)
 80059c2:	6812      	ldr	r2, [r2, #0]
 80059c4:	601a      	str	r2, [r3, #0]
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
 80059c6:	4ad0      	ldr	r2, [pc, #832]	; (8005d08 <uip_process+0xe4c>)
 80059c8:	f641 63c4 	movw	r3, #7876	; 0x1ec4
 80059cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80059d0:	6818      	ldr	r0, [r3, #0]
 80059d2:	6010      	str	r0, [r2, #0]
  
  /* And send out the RST packet! */
  goto tcp_send_noconn;
 80059d4:	f000 bf50 	b.w	8006878 <uip_process+0x19bc>
  
  tmp16 = BUF->destport;
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    if(tmp16 == uip_listenports[c]) {
      goto found_listen;
 80059d8:	bf00      	nop
     connections are kept in the same table as used connections, but
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
 80059da:	2400      	movs	r4, #0
  for(c = 0; c < UIP_CONNS; ++c) {
 80059dc:	f241 5372 	movw	r3, #5490	; 0x1572
 80059e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80059e4:	2200      	movs	r2, #0
 80059e6:	701a      	strb	r2, [r3, #0]
 80059e8:	e066      	b.n	8005ab8 <uip_process+0xbfc>
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
 80059ea:	f241 5372 	movw	r3, #5490	; 0x1572
 80059ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80059f2:	781b      	ldrb	r3, [r3, #0]
 80059f4:	4619      	mov	r1, r3
 80059f6:	f641 02cc 	movw	r2, #6348	; 0x18cc
 80059fa:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80059fe:	460b      	mov	r3, r1
 8005a00:	00db      	lsls	r3, r3, #3
 8005a02:	185b      	adds	r3, r3, r1
 8005a04:	009b      	lsls	r3, r3, #2
 8005a06:	18d3      	adds	r3, r2, r3
 8005a08:	3318      	adds	r3, #24
 8005a0a:	785b      	ldrb	r3, [r3, #1]
 8005a0c:	2b00      	cmp	r3, #0
 8005a0e:	d10f      	bne.n	8005a30 <uip_process+0xb74>
      uip_connr = &uip_conns[c];
 8005a10:	f241 5372 	movw	r3, #5490	; 0x1572
 8005a14:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a18:	781b      	ldrb	r3, [r3, #0]
 8005a1a:	461a      	mov	r2, r3
 8005a1c:	4613      	mov	r3, r2
 8005a1e:	00db      	lsls	r3, r3, #3
 8005a20:	189b      	adds	r3, r3, r2
 8005a22:	009b      	lsls	r3, r3, #2
 8005a24:	f641 02cc 	movw	r2, #6348	; 0x18cc
 8005a28:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005a2c:	189c      	adds	r4, r3, r2
      break;
 8005a2e:	e04a      	b.n	8005ac6 <uip_process+0xc0a>
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
 8005a30:	f241 5372 	movw	r3, #5490	; 0x1572
 8005a34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a38:	781b      	ldrb	r3, [r3, #0]
 8005a3a:	4619      	mov	r1, r3
 8005a3c:	f641 02cc 	movw	r2, #6348	; 0x18cc
 8005a40:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005a44:	460b      	mov	r3, r1
 8005a46:	00db      	lsls	r3, r3, #3
 8005a48:	185b      	adds	r3, r3, r1
 8005a4a:	009b      	lsls	r3, r3, #2
 8005a4c:	18d3      	adds	r3, r2, r3
 8005a4e:	3318      	adds	r3, #24
 8005a50:	785b      	ldrb	r3, [r3, #1]
 8005a52:	2b07      	cmp	r3, #7
 8005a54:	d124      	bne.n	8005aa0 <uip_process+0xbe4>
      if(uip_connr == 0 ||
 8005a56:	2c00      	cmp	r4, #0
 8005a58:	d013      	beq.n	8005a82 <uip_process+0xbc6>
	 uip_conns[c].timer > uip_connr->timer) {
 8005a5a:	f241 5372 	movw	r3, #5490	; 0x1572
 8005a5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a62:	781b      	ldrb	r3, [r3, #0]
 8005a64:	4619      	mov	r1, r3
 8005a66:	f641 02cc 	movw	r2, #6348	; 0x18cc
 8005a6a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005a6e:	460b      	mov	r3, r1
 8005a70:	00db      	lsls	r3, r3, #3
 8005a72:	185b      	adds	r3, r3, r1
 8005a74:	009b      	lsls	r3, r3, #2
 8005a76:	18d3      	adds	r3, r2, r3
 8005a78:	3318      	adds	r3, #24
 8005a7a:	789a      	ldrb	r2, [r3, #2]
 8005a7c:	7ea3      	ldrb	r3, [r4, #26]
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
      uip_connr = &uip_conns[c];
      break;
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
      if(uip_connr == 0 ||
 8005a7e:	429a      	cmp	r2, r3
 8005a80:	d90e      	bls.n	8005aa0 <uip_process+0xbe4>
	 uip_conns[c].timer > uip_connr->timer) {
	uip_connr = &uip_conns[c];
 8005a82:	f241 5372 	movw	r3, #5490	; 0x1572
 8005a86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a8a:	781b      	ldrb	r3, [r3, #0]
 8005a8c:	461a      	mov	r2, r3
 8005a8e:	4613      	mov	r3, r2
 8005a90:	00db      	lsls	r3, r3, #3
 8005a92:	189b      	adds	r3, r3, r2
 8005a94:	009b      	lsls	r3, r3, #2
 8005a96:	f641 02cc 	movw	r2, #6348	; 0x18cc
 8005a9a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005a9e:	189c      	adds	r4, r3, r2
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
 8005aa0:	f241 5372 	movw	r3, #5490	; 0x1572
 8005aa4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005aa8:	781b      	ldrb	r3, [r3, #0]
 8005aaa:	3301      	adds	r3, #1
 8005aac:	b2da      	uxtb	r2, r3
 8005aae:	f241 5372 	movw	r3, #5490	; 0x1572
 8005ab2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ab6:	701a      	strb	r2, [r3, #0]
 8005ab8:	f241 5372 	movw	r3, #5490	; 0x1572
 8005abc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ac0:	781b      	ldrb	r3, [r3, #0]
 8005ac2:	2b27      	cmp	r3, #39	; 0x27
 8005ac4:	d991      	bls.n	80059ea <uip_process+0xb2e>
	uip_connr = &uip_conns[c];
      }
    }
  }

  if(uip_connr == 0) {
 8005ac6:	2c00      	cmp	r4, #0
 8005ac8:	d107      	bne.n	8005ada <uip_process+0xc1e>
    /* All connections are used already, we drop packet and hope that
       the remote end will retransmit the packet at a time when we
       have more spare connections. */
    UIP_STAT(++uip_stat.tcp.syndrop);
    UIP_LOG("tcp: found no unused connections.");
 8005aca:	f249 0094 	movw	r0, #37012	; 0x9094
 8005ace:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005ad2:	f7fd f9ff 	bl	8002ed4 <uip_log>
    goto drop;
 8005ad6:	f000 bf76 	b.w	80069c6 <uip_process+0x1b0a>
  }
  uip_conn = uip_connr;
 8005ada:	f641 03c8 	movw	r3, #6344	; 0x18c8
 8005ade:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ae2:	601c      	str	r4, [r3, #0]
  
  /* Fill in the necessary fields for the new connection. */
  uip_connr->rto = uip_connr->timer = UIP_RTO;
 8005ae4:	2303      	movs	r3, #3
 8005ae6:	76a3      	strb	r3, [r4, #26]
 8005ae8:	7ea3      	ldrb	r3, [r4, #26]
 8005aea:	7623      	strb	r3, [r4, #24]
  uip_connr->sa = 0;
 8005aec:	2300      	movs	r3, #0
 8005aee:	75a3      	strb	r3, [r4, #22]
  uip_connr->sv = 4;
 8005af0:	2304      	movs	r3, #4
 8005af2:	75e3      	strb	r3, [r4, #23]
  uip_connr->nrtx = 0;
 8005af4:	2300      	movs	r3, #0
 8005af6:	76e3      	strb	r3, [r4, #27]
  uip_connr->lport = BUF->destport;
 8005af8:	f241 7318 	movw	r3, #5912	; 0x1718
 8005afc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b00:	8adb      	ldrh	r3, [r3, #22]
 8005b02:	80a3      	strh	r3, [r4, #4]
  uip_connr->rport = BUF->srcport;
 8005b04:	f241 7318 	movw	r3, #5912	; 0x1718
 8005b08:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b0c:	8a9b      	ldrh	r3, [r3, #20]
 8005b0e:	80e3      	strh	r3, [r4, #6]
  uip_ipaddr_copy(&uip_connr->ripaddr, &BUF->srcipaddr);
 8005b10:	4a7d      	ldr	r2, [pc, #500]	; (8005d08 <uip_process+0xe4c>)
 8005b12:	4623      	mov	r3, r4
 8005b14:	6810      	ldr	r0, [r2, #0]
 8005b16:	6018      	str	r0, [r3, #0]
  uip_connr->tcpstateflags = UIP_SYN_RCVD;
 8005b18:	2301      	movs	r3, #1
 8005b1a:	7663      	strb	r3, [r4, #25]

  uip_connr->snd_nxt[0] = iss[0];
 8005b1c:	f241 536c 	movw	r3, #5484	; 0x156c
 8005b20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b24:	781b      	ldrb	r3, [r3, #0]
 8005b26:	7323      	strb	r3, [r4, #12]
  uip_connr->snd_nxt[1] = iss[1];
 8005b28:	f241 536c 	movw	r3, #5484	; 0x156c
 8005b2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b30:	785b      	ldrb	r3, [r3, #1]
 8005b32:	7363      	strb	r3, [r4, #13]
  uip_connr->snd_nxt[2] = iss[2];
 8005b34:	f241 536c 	movw	r3, #5484	; 0x156c
 8005b38:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b3c:	789b      	ldrb	r3, [r3, #2]
 8005b3e:	73a3      	strb	r3, [r4, #14]
  uip_connr->snd_nxt[3] = iss[3];
 8005b40:	f241 536c 	movw	r3, #5484	; 0x156c
 8005b44:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b48:	78db      	ldrb	r3, [r3, #3]
 8005b4a:	73e3      	strb	r3, [r4, #15]
  uip_connr->len = 1;
 8005b4c:	2301      	movs	r3, #1
 8005b4e:	8223      	strh	r3, [r4, #16]

  /* rcv_nxt should be the seqno from the incoming packet + 1. */
  uip_connr->rcv_nxt[3] = BUF->seqno[3];
 8005b50:	f241 7318 	movw	r3, #5912	; 0x1718
 8005b54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b58:	7edb      	ldrb	r3, [r3, #27]
 8005b5a:	72e3      	strb	r3, [r4, #11]
  uip_connr->rcv_nxt[2] = BUF->seqno[2];
 8005b5c:	f241 7318 	movw	r3, #5912	; 0x1718
 8005b60:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b64:	7e9b      	ldrb	r3, [r3, #26]
 8005b66:	72a3      	strb	r3, [r4, #10]
  uip_connr->rcv_nxt[1] = BUF->seqno[1];
 8005b68:	f241 7318 	movw	r3, #5912	; 0x1718
 8005b6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b70:	7e5b      	ldrb	r3, [r3, #25]
 8005b72:	7263      	strb	r3, [r4, #9]
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
 8005b74:	f241 7318 	movw	r3, #5912	; 0x1718
 8005b78:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b7c:	7e1b      	ldrb	r3, [r3, #24]
 8005b7e:	7223      	strb	r3, [r4, #8]
  uip_add_rcv_nxt(1);
 8005b80:	2001      	movs	r0, #1
 8005b82:	f7ff f959 	bl	8004e38 <uip_add_rcv_nxt>

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
 8005b86:	f241 7318 	movw	r3, #5912	; 0x1718
 8005b8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b8e:	f893 3020 	ldrb.w	r3, [r3, #32]
 8005b92:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8005b96:	2b50      	cmp	r3, #80	; 0x50
 8005b98:	f340 80bd 	ble.w	8005d16 <uip_process+0xe5a>
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
 8005b9c:	f241 5372 	movw	r3, #5490	; 0x1572
 8005ba0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ba4:	2200      	movs	r2, #0
 8005ba6:	701a      	strb	r2, [r3, #0]
 8005ba8:	e098      	b.n	8005cdc <uip_process+0xe20>
      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
 8005baa:	f241 5372 	movw	r3, #5490	; 0x1572
 8005bae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005bb2:	781b      	ldrb	r3, [r3, #0]
 8005bb4:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8005bb8:	f241 7318 	movw	r3, #5912	; 0x1718
 8005bbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005bc0:	5c9a      	ldrb	r2, [r3, r2]
 8005bc2:	f241 5373 	movw	r3, #5491	; 0x1573
 8005bc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005bca:	701a      	strb	r2, [r3, #0]
      if(opt == TCP_OPT_END) {
 8005bcc:	f241 5373 	movw	r3, #5491	; 0x1573
 8005bd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005bd4:	781b      	ldrb	r3, [r3, #0]
 8005bd6:	2b00      	cmp	r3, #0
 8005bd8:	f000 809a 	beq.w	8005d10 <uip_process+0xe54>
	/* End of options. */
	break;
      } else if(opt == TCP_OPT_NOOP) {
 8005bdc:	f241 5373 	movw	r3, #5491	; 0x1573
 8005be0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005be4:	781b      	ldrb	r3, [r3, #0]
 8005be6:	2b01      	cmp	r3, #1
 8005be8:	d10c      	bne.n	8005c04 <uip_process+0xd48>
	++c;
 8005bea:	f241 5372 	movw	r3, #5490	; 0x1572
 8005bee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005bf2:	781b      	ldrb	r3, [r3, #0]
 8005bf4:	3301      	adds	r3, #1
 8005bf6:	b2da      	uxtb	r2, r3
 8005bf8:	f241 5372 	movw	r3, #5490	; 0x1572
 8005bfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c00:	701a      	strb	r2, [r3, #0]
 8005c02:	e06b      	b.n	8005cdc <uip_process+0xe20>
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
 8005c04:	f241 5373 	movw	r3, #5491	; 0x1573
 8005c08:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c0c:	781b      	ldrb	r3, [r3, #0]
 8005c0e:	2b02      	cmp	r3, #2
 8005c10:	d13e      	bne.n	8005c90 <uip_process+0xdd4>
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
 8005c12:	f241 5372 	movw	r3, #5490	; 0x1572
 8005c16:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c1a:	781b      	ldrb	r3, [r3, #0]
 8005c1c:	f103 0229 	add.w	r2, r3, #41	; 0x29
 8005c20:	f241 7318 	movw	r3, #5912	; 0x1718
 8005c24:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c28:	5c9b      	ldrb	r3, [r3, r2]
	/* End of options. */
	break;
      } else if(opt == TCP_OPT_NOOP) {
	++c;
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
 8005c2a:	2b04      	cmp	r3, #4
 8005c2c:	d130      	bne.n	8005c90 <uip_process+0xdd4>
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((uint16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
 8005c2e:	f241 5372 	movw	r3, #5490	; 0x1572
 8005c32:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c36:	781b      	ldrb	r3, [r3, #0]
 8005c38:	f103 022a 	add.w	r2, r3, #42	; 0x2a
 8005c3c:	f241 7318 	movw	r3, #5912	; 0x1718
 8005c40:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c44:	5c9b      	ldrb	r3, [r3, r2]
 8005c46:	021b      	lsls	r3, r3, #8
 8005c48:	b29a      	uxth	r2, r3
	  (uint16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
 8005c4a:	f241 5372 	movw	r3, #5490	; 0x1572
 8005c4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c52:	781b      	ldrb	r3, [r3, #0]
 8005c54:	f103 012b 	add.w	r1, r3, #43	; 0x2b
 8005c58:	f241 7318 	movw	r3, #5912	; 0x1718
 8005c5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c60:	5c5b      	ldrb	r3, [r3, r1]
	++c;
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((uint16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
 8005c62:	4313      	orrs	r3, r2
 8005c64:	b29b      	uxth	r3, r3
 8005c66:	b29a      	uxth	r2, r3
 8005c68:	f241 5374 	movw	r3, #5492	; 0x1574
 8005c6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c70:	801a      	strh	r2, [r3, #0]
	  (uint16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
 8005c72:	f241 5374 	movw	r3, #5492	; 0x1574
 8005c76:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c7a:	881b      	ldrh	r3, [r3, #0]
 8005c7c:	f5b3 7fbe 	cmp.w	r3, #380	; 0x17c
 8005c80:	bf28      	it	cs
 8005c82:	f44f 73be 	movcs.w	r3, #380	; 0x17c
 8005c86:	b29b      	uxth	r3, r3
 8005c88:	8263      	strh	r3, [r4, #18]
 8005c8a:	8a63      	ldrh	r3, [r4, #18]
 8005c8c:	82a3      	strh	r3, [r4, #20]
	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
	
	/* And we are done processing options. */
	break;
 8005c8e:	e042      	b.n	8005d16 <uip_process+0xe5a>
      } else {
	/* All other options have a length field, so that we easily
	   can skip past them. */
	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
 8005c90:	f241 5372 	movw	r3, #5490	; 0x1572
 8005c94:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c98:	781b      	ldrb	r3, [r3, #0]
 8005c9a:	f103 0229 	add.w	r2, r3, #41	; 0x29
 8005c9e:	f241 7318 	movw	r3, #5912	; 0x1718
 8005ca2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ca6:	5c9b      	ldrb	r3, [r3, r2]
 8005ca8:	2b00      	cmp	r3, #0
 8005caa:	d033      	beq.n	8005d14 <uip_process+0xe58>
	  /* If the length field is zero, the options are malformed
	     and we don't process them further. */
	  break;
	}
	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
 8005cac:	f241 5372 	movw	r3, #5490	; 0x1572
 8005cb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005cb4:	781b      	ldrb	r3, [r3, #0]
 8005cb6:	f103 0229 	add.w	r2, r3, #41	; 0x29
 8005cba:	f241 7318 	movw	r3, #5912	; 0x1718
 8005cbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005cc2:	5c9a      	ldrb	r2, [r3, r2]
 8005cc4:	f241 5372 	movw	r3, #5490	; 0x1572
 8005cc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ccc:	781b      	ldrb	r3, [r3, #0]
 8005cce:	18d3      	adds	r3, r2, r3
 8005cd0:	b2da      	uxtb	r2, r3
 8005cd2:	f241 5372 	movw	r3, #5490	; 0x1572
 8005cd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005cda:	701a      	strb	r2, [r3, #0]
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
  uip_add_rcv_nxt(1);

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
 8005cdc:	f241 5372 	movw	r3, #5490	; 0x1572
 8005ce0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ce4:	781b      	ldrb	r3, [r3, #0]
 8005ce6:	461a      	mov	r2, r3
 8005ce8:	f241 7318 	movw	r3, #5912	; 0x1718
 8005cec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005cf0:	f893 3020 	ldrb.w	r3, [r3, #32]
 8005cf4:	091b      	lsrs	r3, r3, #4
 8005cf6:	b2db      	uxtb	r3, r3
 8005cf8:	3b05      	subs	r3, #5
 8005cfa:	009b      	lsls	r3, r3, #2
 8005cfc:	429a      	cmp	r2, r3
 8005cfe:	f6ff af54 	blt.w	8005baa <uip_process+0xcee>
 8005d02:	e008      	b.n	8005d16 <uip_process+0xe5a>
 8005d04:	20001728 	.word	0x20001728
 8005d08:	20001724 	.word	0x20001724
	  UIP_STAT(++uip_stat.tcp.rexmit);
	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
	  case UIP_SYN_RCVD:
	    /* In the SYN_RCVD state, we should retransmit our
               SYNACK. */
	    goto tcp_send_synack;
 8005d0c:	bf00      	nop
 8005d0e:	e002      	b.n	8005d16 <uip_process+0xe5a>
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
      if(opt == TCP_OPT_END) {
	/* End of options. */
	break;
 8005d10:	bf00      	nop
 8005d12:	e000      	b.n	8005d16 <uip_process+0xe5a>
	/* All other options have a length field, so that we easily
	   can skip past them. */
	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
	  /* If the length field is zero, the options are malformed
	     and we don't process them further. */
	  break;
 8005d14:	bf00      	nop
  }
  
  /* Our response will be a SYNACK. */
#if UIP_ACTIVE_OPEN
 tcp_send_synack:
  BUF->flags = TCP_ACK;
 8005d16:	f241 7318 	movw	r3, #5912	; 0x1718
 8005d1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005d1e:	2210      	movs	r2, #16
 8005d20:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  
 tcp_send_syn:
  BUF->flags |= TCP_SYN;
 8005d24:	f241 7318 	movw	r3, #5912	; 0x1718
 8005d28:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005d2c:	f241 7218 	movw	r2, #5912	; 0x1718
 8005d30:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005d34:	f892 2021 	ldrb.w	r2, [r2, #33]	; 0x21
 8005d38:	f042 0202 	orr.w	r2, r2, #2
 8005d3c:	b2d2      	uxtb	r2, r2
 8005d3e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  BUF->flags = TCP_SYN | TCP_ACK;
#endif /* UIP_ACTIVE_OPEN */
  
  /* We send out the TCP Maximum Segment Size option with our
     SYNACK. */
  BUF->optdata[0] = TCP_OPT_MSS;
 8005d42:	f241 7318 	movw	r3, #5912	; 0x1718
 8005d46:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005d4a:	2202      	movs	r2, #2
 8005d4c:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
  BUF->optdata[1] = TCP_OPT_MSS_LEN;
 8005d50:	f241 7318 	movw	r3, #5912	; 0x1718
 8005d54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005d58:	2204      	movs	r2, #4
 8005d5a:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  BUF->optdata[2] = (UIP_TCP_MSS) / 256;
 8005d5e:	f241 7318 	movw	r3, #5912	; 0x1718
 8005d62:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005d66:	2201      	movs	r2, #1
 8005d68:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
  BUF->optdata[3] = (UIP_TCP_MSS) & 255;
 8005d6c:	f241 7318 	movw	r3, #5912	; 0x1718
 8005d70:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005d74:	227c      	movs	r2, #124	; 0x7c
 8005d76:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
 8005d7a:	f241 730c 	movw	r3, #5900	; 0x170c
 8005d7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005d82:	222c      	movs	r2, #44	; 0x2c
 8005d84:	801a      	strh	r2, [r3, #0]
  BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
 8005d86:	f241 7318 	movw	r3, #5912	; 0x1718
 8005d8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005d8e:	2260      	movs	r2, #96	; 0x60
 8005d90:	f883 2020 	strb.w	r2, [r3, #32]
  goto tcp_send;
 8005d94:	f000 bd00 	b.w	8006798 <uip_process+0x18dc>
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
       BUF->destport == uip_connr->lport &&
       BUF->srcport == uip_connr->rport &&
       uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)) {
      goto found;
 8005d98:	bf00      	nop
  BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
  goto tcp_send;

  /* This label will be jumped to if we found an active connection. */
 found:
  uip_conn = uip_connr;
 8005d9a:	f641 03c8 	movw	r3, #6344	; 0x18c8
 8005d9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005da2:	601c      	str	r4, [r3, #0]
  uip_flags = 0;
 8005da4:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8005da8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005dac:	2200      	movs	r2, #0
 8005dae:	701a      	strb	r2, [r3, #0]
  /* We do a very naive form of TCP reset processing; we just accept
     any RST and kill our connection. We should in fact check if the
     sequence number of this reset is wihtin our advertised window
     before we accept the reset. */
  if(BUF->flags & TCP_RST) {
 8005db0:	f241 7318 	movw	r3, #5912	; 0x1718
 8005db4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005db8:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8005dbc:	f003 0304 	and.w	r3, r3, #4
 8005dc0:	2b00      	cmp	r3, #0
 8005dc2:	d011      	beq.n	8005de8 <uip_process+0xf2c>
    uip_connr->tcpstateflags = UIP_CLOSED;
 8005dc4:	2300      	movs	r3, #0
 8005dc6:	7663      	strb	r3, [r4, #25]
    UIP_LOG("tcp: got reset, aborting connection.");
 8005dc8:	f249 00b8 	movw	r0, #37048	; 0x90b8
 8005dcc:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005dd0:	f7fd f880 	bl	8002ed4 <uip_log>
    uip_flags = UIP_ABORT;
 8005dd4:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8005dd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ddc:	2220      	movs	r2, #32
 8005dde:	701a      	strb	r2, [r3, #0]
    UIP_APPCALL();
 8005de0:	f001 f880 	bl	8006ee4 <tcpip_uipcall>
    goto drop;
 8005de4:	f000 bdef 	b.w	80069c6 <uip_process+0x1b0a>
  }
  /* Calculate the length of the data, if the application has sent
     any data to us. */
  c = (BUF->tcpoffset >> 4) << 2;
 8005de8:	f241 7318 	movw	r3, #5912	; 0x1718
 8005dec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005df0:	f893 3020 	ldrb.w	r3, [r3, #32]
 8005df4:	091b      	lsrs	r3, r3, #4
 8005df6:	b2db      	uxtb	r3, r3
 8005df8:	009b      	lsls	r3, r3, #2
 8005dfa:	b2da      	uxtb	r2, r3
 8005dfc:	f241 5372 	movw	r3, #5490	; 0x1572
 8005e00:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e04:	701a      	strb	r2, [r3, #0]
  /* uip_len will contain the length of the actual TCP data. This is
     calculated by subtracing the length of the TCP header (in
     c) and the length of the IP header (20 bytes). */
  uip_len = uip_len - c - UIP_IPH_LEN;
 8005e06:	f241 730c 	movw	r3, #5900	; 0x170c
 8005e0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e0e:	881a      	ldrh	r2, [r3, #0]
 8005e10:	f241 5372 	movw	r3, #5490	; 0x1572
 8005e14:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e18:	781b      	ldrb	r3, [r3, #0]
 8005e1a:	1ad3      	subs	r3, r2, r3
 8005e1c:	b29b      	uxth	r3, r3
 8005e1e:	3b14      	subs	r3, #20
 8005e20:	b29a      	uxth	r2, r3
 8005e22:	f241 730c 	movw	r3, #5900	; 0x170c
 8005e26:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e2a:	801a      	strh	r2, [r3, #0]
  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in, unless we are in the SYN_RCVD state and
     receive a SYN, in which case we should retransmit our SYNACK
     (which is done futher down). */
  if(!((((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
 8005e2c:	7e63      	ldrb	r3, [r4, #25]
 8005e2e:	f003 030f 	and.w	r3, r3, #15
 8005e32:	2b02      	cmp	r3, #2
 8005e34:	d109      	bne.n	8005e4a <uip_process+0xf8e>
	((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) ||
 8005e36:	f241 7318 	movw	r3, #5912	; 0x1718
 8005e3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e3e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8005e42:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in, unless we are in the SYN_RCVD state and
     receive a SYN, in which case we should retransmit our SYNACK
     (which is done futher down). */
  if(!((((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
 8005e46:	2b12      	cmp	r3, #18
 8005e48:	d043      	beq.n	8005ed2 <uip_process+0x1016>
	((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) ||
       (((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_RCVD) &&
 8005e4a:	7e63      	ldrb	r3, [r4, #25]
 8005e4c:	f003 030f 	and.w	r3, r3, #15
  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in, unless we are in the SYN_RCVD state and
     receive a SYN, in which case we should retransmit our SYNACK
     (which is done futher down). */
  if(!((((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
 8005e50:	2b01      	cmp	r3, #1
 8005e52:	d109      	bne.n	8005e68 <uip_process+0xfac>
	((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) ||
       (((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_RCVD) &&
	((BUF->flags & TCP_CTL) == TCP_SYN)))) {
 8005e54:	f241 7318 	movw	r3, #5912	; 0x1718
 8005e58:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e5c:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8005e60:	f003 033f 	and.w	r3, r3, #63	; 0x3f
     correct numbers in, unless we are in the SYN_RCVD state and
     receive a SYN, in which case we should retransmit our SYNACK
     (which is done futher down). */
  if(!((((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
	((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) ||
       (((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_RCVD) &&
 8005e64:	2b02      	cmp	r3, #2
 8005e66:	d034      	beq.n	8005ed2 <uip_process+0x1016>
	((BUF->flags & TCP_CTL) == TCP_SYN)))) {
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
 8005e68:	f241 730c 	movw	r3, #5900	; 0x170c
 8005e6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e70:	881b      	ldrh	r3, [r3, #0]
 8005e72:	2b00      	cmp	r3, #0
 8005e74:	d109      	bne.n	8005e8a <uip_process+0xfce>
 8005e76:	f241 7318 	movw	r3, #5912	; 0x1718
 8005e7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e7e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8005e82:	f003 0303 	and.w	r3, r3, #3
 8005e86:	2b00      	cmp	r3, #0
 8005e88:	d023      	beq.n	8005ed2 <uip_process+0x1016>
       (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
 8005e8a:	f241 7318 	movw	r3, #5912	; 0x1718
 8005e8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e92:	7e1a      	ldrb	r2, [r3, #24]
 8005e94:	7a23      	ldrb	r3, [r4, #8]
     (which is done futher down). */
  if(!((((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
	((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) ||
       (((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_RCVD) &&
	((BUF->flags & TCP_CTL) == TCP_SYN)))) {
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
 8005e96:	429a      	cmp	r2, r3
 8005e98:	f040 846a 	bne.w	8006770 <uip_process+0x18b4>
       (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
	BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
 8005e9c:	f241 7318 	movw	r3, #5912	; 0x1718
 8005ea0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ea4:	7e5a      	ldrb	r2, [r3, #25]
 8005ea6:	7a63      	ldrb	r3, [r4, #9]
  if(!((((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
	((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) ||
       (((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_RCVD) &&
	((BUF->flags & TCP_CTL) == TCP_SYN)))) {
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
       (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
 8005ea8:	429a      	cmp	r2, r3
 8005eaa:	f040 8461 	bne.w	8006770 <uip_process+0x18b4>
	BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
	BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
 8005eae:	f241 7318 	movw	r3, #5912	; 0x1718
 8005eb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005eb6:	7e9a      	ldrb	r2, [r3, #26]
 8005eb8:	7aa3      	ldrb	r3, [r4, #10]
	((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) ||
       (((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_RCVD) &&
	((BUF->flags & TCP_CTL) == TCP_SYN)))) {
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
       (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
	BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
 8005eba:	429a      	cmp	r2, r3
 8005ebc:	f040 8458 	bne.w	8006770 <uip_process+0x18b4>
	BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
	BUF->seqno[3] != uip_connr->rcv_nxt[3])) {
 8005ec0:	f241 7318 	movw	r3, #5912	; 0x1718
 8005ec4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ec8:	7eda      	ldrb	r2, [r3, #27]
 8005eca:	7ae3      	ldrb	r3, [r4, #11]
       (((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_RCVD) &&
	((BUF->flags & TCP_CTL) == TCP_SYN)))) {
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
       (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
	BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
	BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
 8005ecc:	429a      	cmp	r2, r3
 8005ece:	f040 844f 	bne.w	8006770 <uip_process+0x18b4>

  /* Next, check if the incoming segment acknowledges any outstanding
     data. If so, we update the sequence number, reset the length of
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
 8005ed2:	f241 7318 	movw	r3, #5912	; 0x1718
 8005ed6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005eda:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8005ede:	f003 0310 	and.w	r3, r3, #16
 8005ee2:	2b00      	cmp	r3, #0
 8005ee4:	f000 808c 	beq.w	8006000 <uip_process+0x1144>
 8005ee8:	8a23      	ldrh	r3, [r4, #16]
 8005eea:	2b00      	cmp	r3, #0
 8005eec:	f000 8088 	beq.w	8006000 <uip_process+0x1144>
    uip_add32(uip_connr->snd_nxt, uip_connr->len);
 8005ef0:	f104 020c 	add.w	r2, r4, #12
 8005ef4:	8a23      	ldrh	r3, [r4, #16]
 8005ef6:	4610      	mov	r0, r2
 8005ef8:	4619      	mov	r1, r3
 8005efa:	f7fe fd2d 	bl	8004958 <uip_add32>

    if(BUF->ackno[0] == uip_acc32[0] &&
 8005efe:	f241 7318 	movw	r3, #5912	; 0x1718
 8005f02:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f06:	7f1a      	ldrb	r2, [r3, #28]
 8005f08:	f241 7314 	movw	r3, #5908	; 0x1714
 8005f0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f10:	781b      	ldrb	r3, [r3, #0]
 8005f12:	429a      	cmp	r2, r3
 8005f14:	d174      	bne.n	8006000 <uip_process+0x1144>
       BUF->ackno[1] == uip_acc32[1] &&
 8005f16:	f241 7318 	movw	r3, #5912	; 0x1718
 8005f1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f1e:	7f5a      	ldrb	r2, [r3, #29]
 8005f20:	f241 7314 	movw	r3, #5908	; 0x1714
 8005f24:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f28:	785b      	ldrb	r3, [r3, #1]
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
 8005f2a:	429a      	cmp	r2, r3
 8005f2c:	d168      	bne.n	8006000 <uip_process+0x1144>
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
 8005f2e:	f241 7318 	movw	r3, #5912	; 0x1718
 8005f32:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f36:	7f9a      	ldrb	r2, [r3, #30]
 8005f38:	f241 7314 	movw	r3, #5908	; 0x1714
 8005f3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f40:	789b      	ldrb	r3, [r3, #2]
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
       BUF->ackno[1] == uip_acc32[1] &&
 8005f42:	429a      	cmp	r2, r3
 8005f44:	d15c      	bne.n	8006000 <uip_process+0x1144>
       BUF->ackno[2] == uip_acc32[2] &&
       BUF->ackno[3] == uip_acc32[3]) {
 8005f46:	f241 7318 	movw	r3, #5912	; 0x1718
 8005f4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f4e:	7fda      	ldrb	r2, [r3, #31]
 8005f50:	f241 7314 	movw	r3, #5908	; 0x1714
 8005f54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f58:	78db      	ldrb	r3, [r3, #3]
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
 8005f5a:	429a      	cmp	r2, r3
 8005f5c:	d150      	bne.n	8006000 <uip_process+0x1144>
       BUF->ackno[3] == uip_acc32[3]) {
      /* Update sequence number. */
      uip_connr->snd_nxt[0] = uip_acc32[0];
 8005f5e:	f241 7314 	movw	r3, #5908	; 0x1714
 8005f62:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f66:	781b      	ldrb	r3, [r3, #0]
 8005f68:	7323      	strb	r3, [r4, #12]
      uip_connr->snd_nxt[1] = uip_acc32[1];
 8005f6a:	f241 7314 	movw	r3, #5908	; 0x1714
 8005f6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f72:	785b      	ldrb	r3, [r3, #1]
 8005f74:	7363      	strb	r3, [r4, #13]
      uip_connr->snd_nxt[2] = uip_acc32[2];
 8005f76:	f241 7314 	movw	r3, #5908	; 0x1714
 8005f7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f7e:	789b      	ldrb	r3, [r3, #2]
 8005f80:	73a3      	strb	r3, [r4, #14]
      uip_connr->snd_nxt[3] = uip_acc32[3];
 8005f82:	f241 7314 	movw	r3, #5908	; 0x1714
 8005f86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f8a:	78db      	ldrb	r3, [r3, #3]
 8005f8c:	73e3      	strb	r3, [r4, #15]
	
      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
 8005f8e:	7ee3      	ldrb	r3, [r4, #27]
 8005f90:	2b00      	cmp	r3, #0
 8005f92:	d12b      	bne.n	8005fec <uip_process+0x1130>
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
 8005f94:	7e22      	ldrb	r2, [r4, #24]
 8005f96:	7ea3      	ldrb	r3, [r4, #26]
 8005f98:	1ad3      	subs	r3, r2, r3
 8005f9a:	b2db      	uxtb	r3, r3
 8005f9c:	73fb      	strb	r3, [r7, #15]
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
 8005f9e:	7bfa      	ldrb	r2, [r7, #15]
 8005fa0:	7da3      	ldrb	r3, [r4, #22]
 8005fa2:	08db      	lsrs	r3, r3, #3
 8005fa4:	b2db      	uxtb	r3, r3
 8005fa6:	1ad3      	subs	r3, r2, r3
 8005fa8:	b2db      	uxtb	r3, r3
 8005faa:	73fb      	strb	r3, [r7, #15]
	uip_connr->sa += m;
 8005fac:	7da2      	ldrb	r2, [r4, #22]
 8005fae:	7bfb      	ldrb	r3, [r7, #15]
 8005fb0:	18d3      	adds	r3, r2, r3
 8005fb2:	b2db      	uxtb	r3, r3
 8005fb4:	75a3      	strb	r3, [r4, #22]
	if(m < 0) {
 8005fb6:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8005fba:	2b00      	cmp	r3, #0
 8005fbc:	da03      	bge.n	8005fc6 <uip_process+0x110a>
	  m = -m;
 8005fbe:	7bfb      	ldrb	r3, [r7, #15]
 8005fc0:	425b      	negs	r3, r3
 8005fc2:	b2db      	uxtb	r3, r3
 8005fc4:	73fb      	strb	r3, [r7, #15]
	}
	m = m - (uip_connr->sv >> 2);
 8005fc6:	7bfa      	ldrb	r2, [r7, #15]
 8005fc8:	7de3      	ldrb	r3, [r4, #23]
 8005fca:	089b      	lsrs	r3, r3, #2
 8005fcc:	b2db      	uxtb	r3, r3
 8005fce:	1ad3      	subs	r3, r2, r3
 8005fd0:	b2db      	uxtb	r3, r3
 8005fd2:	73fb      	strb	r3, [r7, #15]
	uip_connr->sv += m;
 8005fd4:	7de2      	ldrb	r2, [r4, #23]
 8005fd6:	7bfb      	ldrb	r3, [r7, #15]
 8005fd8:	18d3      	adds	r3, r2, r3
 8005fda:	b2db      	uxtb	r3, r3
 8005fdc:	75e3      	strb	r3, [r4, #23]
	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
 8005fde:	7da3      	ldrb	r3, [r4, #22]
 8005fe0:	08db      	lsrs	r3, r3, #3
 8005fe2:	b2da      	uxtb	r2, r3
 8005fe4:	7de3      	ldrb	r3, [r4, #23]
 8005fe6:	18d3      	adds	r3, r2, r3
 8005fe8:	b2db      	uxtb	r3, r3
 8005fea:	7623      	strb	r3, [r4, #24]

      }
      /* Set the acknowledged flag. */
      uip_flags = UIP_ACKDATA;
 8005fec:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8005ff0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ff4:	2201      	movs	r2, #1
 8005ff6:	701a      	strb	r2, [r3, #0]
      /* Reset the retransmission timer. */
      uip_connr->timer = uip_connr->rto;
 8005ff8:	7e23      	ldrb	r3, [r4, #24]
 8005ffa:	76a3      	strb	r3, [r4, #26]

      /* Reset length of outstanding data. */
      uip_connr->len = 0;
 8005ffc:	2300      	movs	r3, #0
 8005ffe:	8223      	strh	r3, [r4, #16]
    }
    
  }

  /* Do different things depending on in what state the connection is. */
  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
 8006000:	7e63      	ldrb	r3, [r4, #25]
 8006002:	f003 030f 	and.w	r3, r3, #15
 8006006:	3b01      	subs	r3, #1
 8006008:	2b07      	cmp	r3, #7
 800600a:	f200 84d1 	bhi.w	80069b0 <uip_process+0x1af4>
 800600e:	a201      	add	r2, pc, #4	; (adr r2, 8006014 <uip_process+0x1158>)
 8006010:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006014:	08006035 	.word	0x08006035
 8006018:	080060bd 	.word	0x080060bd
 800601c:	080062f5 	.word	0x080062f5
 8006020:	0800664d 	.word	0x0800664d
 8006024:	080066e9 	.word	0x080066e9
 8006028:	0800674d 	.word	0x0800674d
 800602c:	0800676f 	.word	0x0800676f
 8006030:	08006623 	.word	0x08006623
  case UIP_SYN_RCVD:
    /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
       we are waiting for an ACK that acknowledges the data we sent
       out the last time. Therefore, we want to have the UIP_ACKDATA
       flag set. If so, we enter the ESTABLISHED state. */
    if(uip_flags & UIP_ACKDATA) {
 8006034:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8006038:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800603c:	781b      	ldrb	r3, [r3, #0]
 800603e:	f003 0301 	and.w	r3, r3, #1
 8006042:	2b00      	cmp	r3, #0
 8006044:	d02e      	beq.n	80060a4 <uip_process+0x11e8>
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
 8006046:	2303      	movs	r3, #3
 8006048:	7663      	strb	r3, [r4, #25]
      uip_flags = UIP_CONNECTED;
 800604a:	f641 03bc 	movw	r3, #6332	; 0x18bc
 800604e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006052:	2240      	movs	r2, #64	; 0x40
 8006054:	701a      	strb	r2, [r3, #0]
      uip_connr->len = 0;
 8006056:	2300      	movs	r3, #0
 8006058:	8223      	strh	r3, [r4, #16]
      if(uip_len > 0) {
 800605a:	f241 730c 	movw	r3, #5900	; 0x170c
 800605e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006062:	881b      	ldrh	r3, [r3, #0]
 8006064:	2b00      	cmp	r3, #0
 8006066:	d014      	beq.n	8006092 <uip_process+0x11d6>
        uip_flags |= UIP_NEWDATA;
 8006068:	f641 03bc 	movw	r3, #6332	; 0x18bc
 800606c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006070:	781b      	ldrb	r3, [r3, #0]
 8006072:	f043 0302 	orr.w	r3, r3, #2
 8006076:	b2da      	uxtb	r2, r3
 8006078:	f641 03bc 	movw	r3, #6332	; 0x18bc
 800607c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006080:	701a      	strb	r2, [r3, #0]
        uip_add_rcv_nxt(uip_len);
 8006082:	f241 730c 	movw	r3, #5900	; 0x170c
 8006086:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800608a:	881b      	ldrh	r3, [r3, #0]
 800608c:	4618      	mov	r0, r3
 800608e:	f7fe fed3 	bl	8004e38 <uip_add_rcv_nxt>
      }
      uip_slen = 0;
 8006092:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 8006096:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800609a:	2200      	movs	r2, #0
 800609c:	801a      	strh	r2, [r3, #0]
      UIP_APPCALL();
 800609e:	f000 ff21 	bl	8006ee4 <tcpip_uipcall>
      goto appsend;
 80060a2:	e21a      	b.n	80064da <uip_process+0x161e>
    }
    /* We need to retransmit the SYNACK */
    if((BUF->flags & TCP_CTL) == TCP_SYN) {
 80060a4:	f241 7318 	movw	r3, #5912	; 0x1718
 80060a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80060ac:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 80060b0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80060b4:	2b02      	cmp	r3, #2
 80060b6:	f040 847d 	bne.w	80069b4 <uip_process+0x1af8>
      goto tcp_send_synack;
 80060ba:	e62c      	b.n	8005d16 <uip_process+0xe5a>
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
 80060bc:	f641 03bc 	movw	r3, #6332	; 0x18bc
 80060c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80060c4:	781b      	ldrb	r3, [r3, #0]
 80060c6:	f003 0301 	and.w	r3, r3, #1
 80060ca:	2b00      	cmp	r3, #0
 80060cc:	f000 8101 	beq.w	80062d2 <uip_process+0x1416>
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
 80060d0:	f241 7318 	movw	r3, #5912	; 0x1718
 80060d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80060d8:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 80060dc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
 80060e0:	2b12      	cmp	r3, #18
 80060e2:	f040 80f6 	bne.w	80062d2 <uip_process+0x1416>
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
 80060e6:	f241 7318 	movw	r3, #5912	; 0x1718
 80060ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80060ee:	f893 3020 	ldrb.w	r3, [r3, #32]
 80060f2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80060f6:	2b50      	cmp	r3, #80	; 0x50
 80060f8:	f340 80b7 	ble.w	800626a <uip_process+0x13ae>
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
 80060fc:	f241 5372 	movw	r3, #5490	; 0x1572
 8006100:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006104:	2200      	movs	r2, #0
 8006106:	701a      	strb	r2, [r3, #0]
 8006108:	e098      	b.n	800623c <uip_process+0x1380>
	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
 800610a:	f241 5372 	movw	r3, #5490	; 0x1572
 800610e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006112:	781b      	ldrb	r3, [r3, #0]
 8006114:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8006118:	f241 7318 	movw	r3, #5912	; 0x1718
 800611c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006120:	5c9a      	ldrb	r2, [r3, r2]
 8006122:	f241 5373 	movw	r3, #5491	; 0x1573
 8006126:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800612a:	701a      	strb	r2, [r3, #0]
	  if(opt == TCP_OPT_END) {
 800612c:	f241 5373 	movw	r3, #5491	; 0x1573
 8006130:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006134:	781b      	ldrb	r3, [r3, #0]
 8006136:	2b00      	cmp	r3, #0
 8006138:	f000 8094 	beq.w	8006264 <uip_process+0x13a8>
	    /* End of options. */
	    break;
	  } else if(opt == TCP_OPT_NOOP) {
 800613c:	f241 5373 	movw	r3, #5491	; 0x1573
 8006140:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006144:	781b      	ldrb	r3, [r3, #0]
 8006146:	2b01      	cmp	r3, #1
 8006148:	d10c      	bne.n	8006164 <uip_process+0x12a8>
	    ++c;
 800614a:	f241 5372 	movw	r3, #5490	; 0x1572
 800614e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006152:	781b      	ldrb	r3, [r3, #0]
 8006154:	3301      	adds	r3, #1
 8006156:	b2da      	uxtb	r2, r3
 8006158:	f241 5372 	movw	r3, #5490	; 0x1572
 800615c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006160:	701a      	strb	r2, [r3, #0]
 8006162:	e06b      	b.n	800623c <uip_process+0x1380>
	    /* NOP option. */
	  } else if(opt == TCP_OPT_MSS &&
 8006164:	f241 5373 	movw	r3, #5491	; 0x1573
 8006168:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800616c:	781b      	ldrb	r3, [r3, #0]
 800616e:	2b02      	cmp	r3, #2
 8006170:	d13e      	bne.n	80061f0 <uip_process+0x1334>
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
 8006172:	f241 5372 	movw	r3, #5490	; 0x1572
 8006176:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800617a:	781b      	ldrb	r3, [r3, #0]
 800617c:	f103 0229 	add.w	r2, r3, #41	; 0x29
 8006180:	f241 7318 	movw	r3, #5912	; 0x1718
 8006184:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006188:	5c9b      	ldrb	r3, [r3, r2]
	    /* End of options. */
	    break;
	  } else if(opt == TCP_OPT_NOOP) {
	    ++c;
	    /* NOP option. */
	  } else if(opt == TCP_OPT_MSS &&
 800618a:	2b04      	cmp	r3, #4
 800618c:	d130      	bne.n	80061f0 <uip_process+0x1334>
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
 800618e:	f241 5372 	movw	r3, #5490	; 0x1572
 8006192:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006196:	781b      	ldrb	r3, [r3, #0]
 8006198:	f103 022a 	add.w	r2, r3, #42	; 0x2a
 800619c:	f241 7318 	movw	r3, #5912	; 0x1718
 80061a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80061a4:	5c9b      	ldrb	r3, [r3, r2]
 80061a6:	021b      	lsls	r3, r3, #8
 80061a8:	b29a      	uxth	r2, r3
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
 80061aa:	f241 5372 	movw	r3, #5490	; 0x1572
 80061ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80061b2:	781b      	ldrb	r3, [r3, #0]
 80061b4:	f103 012b 	add.w	r1, r3, #43	; 0x2b
 80061b8:	f241 7318 	movw	r3, #5912	; 0x1718
 80061bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80061c0:	5c5b      	ldrb	r3, [r3, r1]
	    ++c;
	    /* NOP option. */
	  } else if(opt == TCP_OPT_MSS &&
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
 80061c2:	4313      	orrs	r3, r2
 80061c4:	b29b      	uxth	r3, r3
 80061c6:	b29a      	uxth	r2, r3
 80061c8:	f241 5374 	movw	r3, #5492	; 0x1574
 80061cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80061d0:	801a      	strh	r2, [r3, #0]
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
 80061d2:	f241 5374 	movw	r3, #5492	; 0x1574
 80061d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80061da:	881b      	ldrh	r3, [r3, #0]
 80061dc:	f5b3 7fbe 	cmp.w	r3, #380	; 0x17c
 80061e0:	bf28      	it	cs
 80061e2:	f44f 73be 	movcs.w	r3, #380	; 0x17c
 80061e6:	b29b      	uxth	r3, r3
 80061e8:	8263      	strh	r3, [r4, #18]
 80061ea:	8a63      	ldrh	r3, [r4, #18]
	  } else if(opt == TCP_OPT_MSS &&
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
 80061ec:	82a3      	strh	r3, [r4, #20]
	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;

	    /* And we are done processing options. */
	    break;
 80061ee:	e03c      	b.n	800626a <uip_process+0x13ae>
	  } else {
	    /* All other options have a length field, so that we easily
	       can skip past them. */
	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
 80061f0:	f241 5372 	movw	r3, #5490	; 0x1572
 80061f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80061f8:	781b      	ldrb	r3, [r3, #0]
 80061fa:	f103 0229 	add.w	r2, r3, #41	; 0x29
 80061fe:	f241 7318 	movw	r3, #5912	; 0x1718
 8006202:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006206:	5c9b      	ldrb	r3, [r3, r2]
 8006208:	2b00      	cmp	r3, #0
 800620a:	d02d      	beq.n	8006268 <uip_process+0x13ac>
	      /* If the length field is zero, the options are malformed
		 and we don't process them further. */
	      break;
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
 800620c:	f241 5372 	movw	r3, #5490	; 0x1572
 8006210:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006214:	781b      	ldrb	r3, [r3, #0]
 8006216:	f103 0229 	add.w	r2, r3, #41	; 0x29
 800621a:	f241 7318 	movw	r3, #5912	; 0x1718
 800621e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006222:	5c9a      	ldrb	r2, [r3, r2]
 8006224:	f241 5372 	movw	r3, #5490	; 0x1572
 8006228:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800622c:	781b      	ldrb	r3, [r3, #0]
 800622e:	18d3      	adds	r3, r2, r3
 8006230:	b2da      	uxtb	r2, r3
 8006232:	f241 5372 	movw	r3, #5490	; 0x1572
 8006236:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800623a:	701a      	strb	r2, [r3, #0]
    if((uip_flags & UIP_ACKDATA) &&
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
 800623c:	f241 5372 	movw	r3, #5490	; 0x1572
 8006240:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006244:	781b      	ldrb	r3, [r3, #0]
 8006246:	461a      	mov	r2, r3
 8006248:	f241 7318 	movw	r3, #5912	; 0x1718
 800624c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006250:	f893 3020 	ldrb.w	r3, [r3, #32]
 8006254:	091b      	lsrs	r3, r3, #4
 8006256:	b2db      	uxtb	r3, r3
 8006258:	3b05      	subs	r3, #5
 800625a:	009b      	lsls	r3, r3, #2
 800625c:	429a      	cmp	r2, r3
 800625e:	f6ff af54 	blt.w	800610a <uip_process+0x124e>
 8006262:	e002      	b.n	800626a <uip_process+0x13ae>
	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
	  if(opt == TCP_OPT_END) {
	    /* End of options. */
	    break;
 8006264:	bf00      	nop
 8006266:	e000      	b.n	800626a <uip_process+0x13ae>
	    /* All other options have a length field, so that we easily
	       can skip past them. */
	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
	      /* If the length field is zero, the options are malformed
		 and we don't process them further. */
	      break;
 8006268:	bf00      	nop
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
	  }
	}
      }
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
 800626a:	2303      	movs	r3, #3
 800626c:	7663      	strb	r3, [r4, #25]
      uip_connr->rcv_nxt[0] = BUF->seqno[0];
 800626e:	f241 7318 	movw	r3, #5912	; 0x1718
 8006272:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006276:	7e1b      	ldrb	r3, [r3, #24]
 8006278:	7223      	strb	r3, [r4, #8]
      uip_connr->rcv_nxt[1] = BUF->seqno[1];
 800627a:	f241 7318 	movw	r3, #5912	; 0x1718
 800627e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006282:	7e5b      	ldrb	r3, [r3, #25]
 8006284:	7263      	strb	r3, [r4, #9]
      uip_connr->rcv_nxt[2] = BUF->seqno[2];
 8006286:	f241 7318 	movw	r3, #5912	; 0x1718
 800628a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800628e:	7e9b      	ldrb	r3, [r3, #26]
 8006290:	72a3      	strb	r3, [r4, #10]
      uip_connr->rcv_nxt[3] = BUF->seqno[3];
 8006292:	f241 7318 	movw	r3, #5912	; 0x1718
 8006296:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800629a:	7edb      	ldrb	r3, [r3, #27]
 800629c:	72e3      	strb	r3, [r4, #11]
      uip_add_rcv_nxt(1);
 800629e:	2001      	movs	r0, #1
 80062a0:	f7fe fdca 	bl	8004e38 <uip_add_rcv_nxt>
      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
 80062a4:	f641 03bc 	movw	r3, #6332	; 0x18bc
 80062a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80062ac:	2242      	movs	r2, #66	; 0x42
 80062ae:	701a      	strb	r2, [r3, #0]
      uip_connr->len = 0;
 80062b0:	2300      	movs	r3, #0
 80062b2:	8223      	strh	r3, [r4, #16]
      uip_len = 0;
 80062b4:	f241 730c 	movw	r3, #5900	; 0x170c
 80062b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80062bc:	2200      	movs	r2, #0
 80062be:	801a      	strh	r2, [r3, #0]
      uip_slen = 0;
 80062c0:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 80062c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80062c8:	2200      	movs	r2, #0
 80062ca:	801a      	strh	r2, [r3, #0]
      UIP_APPCALL();
 80062cc:	f000 fe0a 	bl	8006ee4 <tcpip_uipcall>
      goto appsend;
 80062d0:	e103      	b.n	80064da <uip_process+0x161e>
    }
    /* Inform the application that the connection failed */
    uip_flags = UIP_ABORT;
 80062d2:	f641 03bc 	movw	r3, #6332	; 0x18bc
 80062d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80062da:	2220      	movs	r2, #32
 80062dc:	701a      	strb	r2, [r3, #0]
    UIP_APPCALL();
 80062de:	f000 fe01 	bl	8006ee4 <tcpip_uipcall>
    /* The connection is closed after we send the RST */
    uip_conn->tcpstateflags = UIP_CLOSED;
 80062e2:	f641 03c8 	movw	r3, #6344	; 0x18c8
 80062e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80062ea:	681b      	ldr	r3, [r3, #0]
 80062ec:	2200      	movs	r2, #0
 80062ee:	765a      	strb	r2, [r3, #25]
    goto reset;
 80062f0:	f7ff ba87 	b.w	8005802 <uip_process+0x946>
    If the incoming packet is a FIN, we should close the connection on
    this side as well, and we send out a FIN and enter the LAST_ACK
    state. We require that there is no outstanding data; otherwise the
    sequence numbers will be screwed up. */

    if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
 80062f4:	f241 7318 	movw	r3, #5912	; 0x1718
 80062f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80062fc:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8006300:	f003 0301 	and.w	r3, r3, #1
 8006304:	2b00      	cmp	r3, #0
 8006306:	d045      	beq.n	8006394 <uip_process+0x14d8>
 8006308:	7e63      	ldrb	r3, [r4, #25]
 800630a:	f003 0310 	and.w	r3, r3, #16
 800630e:	2b00      	cmp	r3, #0
 8006310:	d140      	bne.n	8006394 <uip_process+0x14d8>
      if(uip_outstanding(uip_connr)) {
 8006312:	8a23      	ldrh	r3, [r4, #16]
 8006314:	2b00      	cmp	r3, #0
 8006316:	f040 834f 	bne.w	80069b8 <uip_process+0x1afc>
	goto drop;
      }
      uip_add_rcv_nxt(1 + uip_len);
 800631a:	f241 730c 	movw	r3, #5900	; 0x170c
 800631e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006322:	881b      	ldrh	r3, [r3, #0]
 8006324:	3301      	adds	r3, #1
 8006326:	b29b      	uxth	r3, r3
 8006328:	4618      	mov	r0, r3
 800632a:	f7fe fd85 	bl	8004e38 <uip_add_rcv_nxt>
      uip_flags |= UIP_CLOSE;
 800632e:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8006332:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006336:	781b      	ldrb	r3, [r3, #0]
 8006338:	f043 0310 	orr.w	r3, r3, #16
 800633c:	b2da      	uxtb	r2, r3
 800633e:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8006342:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006346:	701a      	strb	r2, [r3, #0]
      if(uip_len > 0) {
 8006348:	f241 730c 	movw	r3, #5900	; 0x170c
 800634c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006350:	881b      	ldrh	r3, [r3, #0]
 8006352:	2b00      	cmp	r3, #0
 8006354:	d00c      	beq.n	8006370 <uip_process+0x14b4>
	uip_flags |= UIP_NEWDATA;
 8006356:	f641 03bc 	movw	r3, #6332	; 0x18bc
 800635a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800635e:	781b      	ldrb	r3, [r3, #0]
 8006360:	f043 0302 	orr.w	r3, r3, #2
 8006364:	b2da      	uxtb	r2, r3
 8006366:	f641 03bc 	movw	r3, #6332	; 0x18bc
 800636a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800636e:	701a      	strb	r2, [r3, #0]
      }
      UIP_APPCALL();
 8006370:	f000 fdb8 	bl	8006ee4 <tcpip_uipcall>
      uip_connr->len = 1;
 8006374:	2301      	movs	r3, #1
 8006376:	8223      	strh	r3, [r4, #16]
      uip_connr->tcpstateflags = UIP_LAST_ACK;
 8006378:	2308      	movs	r3, #8
 800637a:	7663      	strb	r3, [r4, #25]
      uip_connr->nrtx = 0;
 800637c:	2300      	movs	r3, #0
 800637e:	76e3      	strb	r3, [r4, #27]
 8006380:	e000      	b.n	8006384 <uip_process+0x14c8>
	    
	  case UIP_FIN_WAIT_1:
	  case UIP_CLOSING:
	  case UIP_LAST_ACK:
	    /* In all these states we should retransmit a FINACK. */
	    goto tcp_send_finack;
 8006382:	bf00      	nop
      UIP_APPCALL();
      uip_connr->len = 1;
      uip_connr->tcpstateflags = UIP_LAST_ACK;
      uip_connr->nrtx = 0;
    tcp_send_finack:
      BUF->flags = TCP_FIN | TCP_ACK;
 8006384:	f241 7318 	movw	r3, #5912	; 0x1718
 8006388:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800638c:	2211      	movs	r2, #17
 800638e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
      goto tcp_send_nodata;
 8006392:	e1f4      	b.n	800677e <uip_process+0x18c2>
    }

    /* Check the URG flag. If this is set, the segment carries urgent
       data that we must pass to the application. */
    if((BUF->flags & TCP_URG) != 0) {
 8006394:	f241 7318 	movw	r3, #5912	; 0x1718
 8006398:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800639c:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 80063a0:	f003 0320 	and.w	r3, r3, #32
 80063a4:	2b00      	cmp	r3, #0
 80063a6:	d035      	beq.n	8006414 <uip_process+0x1558>
      uip_urgdata = uip_appdata;
      uip_appdata += uip_urglen;
    } else {
      uip_urglen = 0;
#else /* UIP_URGDATA > 0 */
      uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
 80063a8:	f641 03c4 	movw	r3, #6340	; 0x18c4
 80063ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80063b0:	681a      	ldr	r2, [r3, #0]
 80063b2:	f241 7318 	movw	r3, #5912	; 0x1718
 80063b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80063ba:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 80063be:	0219      	lsls	r1, r3, #8
 80063c0:	f241 7318 	movw	r3, #5912	; 0x1718
 80063c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80063c8:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 80063cc:	430b      	orrs	r3, r1
 80063ce:	18d2      	adds	r2, r2, r3
 80063d0:	f641 03c4 	movw	r3, #6340	; 0x18c4
 80063d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80063d8:	601a      	str	r2, [r3, #0]
      uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
 80063da:	f241 730c 	movw	r3, #5900	; 0x170c
 80063de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80063e2:	881a      	ldrh	r2, [r3, #0]
 80063e4:	f241 7318 	movw	r3, #5912	; 0x1718
 80063e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80063ec:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 80063f0:	021b      	lsls	r3, r3, #8
 80063f2:	b299      	uxth	r1, r3
 80063f4:	f241 7318 	movw	r3, #5912	; 0x1718
 80063f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80063fc:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8006400:	430b      	orrs	r3, r1
 8006402:	b29b      	uxth	r3, r3
 8006404:	b29b      	uxth	r3, r3
 8006406:	1ad3      	subs	r3, r2, r3
 8006408:	b29a      	uxth	r2, r3
 800640a:	f241 730c 	movw	r3, #5900	; 0x170c
 800640e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006412:	801a      	strh	r2, [r3, #0]
    /* If uip_len > 0 we have TCP data in the packet, and we flag this
       by setting the UIP_NEWDATA flag and update the sequence number
       we acknowledge. If the application has stopped the dataflow
       using uip_stop(), we must not accept any data packets from the
       remote host. */
    if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
 8006414:	f241 730c 	movw	r3, #5900	; 0x170c
 8006418:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800641c:	881b      	ldrh	r3, [r3, #0]
 800641e:	2b00      	cmp	r3, #0
 8006420:	d019      	beq.n	8006456 <uip_process+0x159a>
 8006422:	7e63      	ldrb	r3, [r4, #25]
 8006424:	f003 0310 	and.w	r3, r3, #16
 8006428:	2b00      	cmp	r3, #0
 800642a:	d114      	bne.n	8006456 <uip_process+0x159a>
      uip_flags |= UIP_NEWDATA;
 800642c:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8006430:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006434:	781b      	ldrb	r3, [r3, #0]
 8006436:	f043 0302 	orr.w	r3, r3, #2
 800643a:	b2da      	uxtb	r2, r3
 800643c:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8006440:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006444:	701a      	strb	r2, [r3, #0]
      uip_add_rcv_nxt(uip_len);
 8006446:	f241 730c 	movw	r3, #5900	; 0x170c
 800644a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800644e:	881b      	ldrh	r3, [r3, #0]
 8006450:	4618      	mov	r0, r3
 8006452:	f7fe fcf1 	bl	8004e38 <uip_add_rcv_nxt>
       the initial MSS so that the application will send an entire MSS
       of data. This data will not be acknowledged by the receiver,
       and the application will retransmit it. This is called the
       "persistent timer" and uses the retransmission mechanim.
    */
    tmp16 = ((uint16_t)BUF->wnd[0] << 8) + (uint16_t)BUF->wnd[1];
 8006456:	f241 7318 	movw	r3, #5912	; 0x1718
 800645a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800645e:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8006462:	021b      	lsls	r3, r3, #8
 8006464:	b29a      	uxth	r2, r3
 8006466:	f241 7318 	movw	r3, #5912	; 0x1718
 800646a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800646e:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 8006472:	18d3      	adds	r3, r2, r3
 8006474:	b29a      	uxth	r2, r3
 8006476:	f241 5374 	movw	r3, #5492	; 0x1574
 800647a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800647e:	801a      	strh	r2, [r3, #0]
    if(tmp16 > uip_connr->initialmss ||
 8006480:	8aa2      	ldrh	r2, [r4, #20]
 8006482:	f241 5374 	movw	r3, #5492	; 0x1574
 8006486:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800648a:	881b      	ldrh	r3, [r3, #0]
 800648c:	429a      	cmp	r2, r3
 800648e:	d306      	bcc.n	800649e <uip_process+0x15e2>
       tmp16 == 0) {
 8006490:	f241 5374 	movw	r3, #5492	; 0x1574
 8006494:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006498:	881b      	ldrh	r3, [r3, #0]
       of data. This data will not be acknowledged by the receiver,
       and the application will retransmit it. This is called the
       "persistent timer" and uses the retransmission mechanim.
    */
    tmp16 = ((uint16_t)BUF->wnd[0] << 8) + (uint16_t)BUF->wnd[1];
    if(tmp16 > uip_connr->initialmss ||
 800649a:	2b00      	cmp	r3, #0
 800649c:	d105      	bne.n	80064aa <uip_process+0x15ee>
       tmp16 == 0) {
      tmp16 = uip_connr->initialmss;
 800649e:	8aa2      	ldrh	r2, [r4, #20]
 80064a0:	f241 5374 	movw	r3, #5492	; 0x1574
 80064a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80064a8:	801a      	strh	r2, [r3, #0]
    }
    uip_connr->mss = tmp16;
 80064aa:	f241 5374 	movw	r3, #5492	; 0x1574
 80064ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80064b2:	881b      	ldrh	r3, [r3, #0]
 80064b4:	8263      	strh	r3, [r4, #18]

       If the application wishes to send any data, this data should be
       put into the uip_appdata and the length of the data should be
       put into uip_len. If the application don't have any data to
       send, uip_len must be set to 0. */
    if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
 80064b6:	f641 03bc 	movw	r3, #6332	; 0x18bc
 80064ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80064be:	781b      	ldrb	r3, [r3, #0]
 80064c0:	f003 0303 	and.w	r3, r3, #3
 80064c4:	2b00      	cmp	r3, #0
 80064c6:	f000 8279 	beq.w	80069bc <uip_process+0x1b00>
      uip_slen = 0;
 80064ca:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 80064ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80064d2:	2200      	movs	r2, #0
 80064d4:	801a      	strh	r2, [r3, #0]
      UIP_APPCALL();
 80064d6:	f000 fd05 	bl	8006ee4 <tcpip_uipcall>

    appsend:
      
      if(uip_flags & UIP_ABORT) {
 80064da:	f641 03bc 	movw	r3, #6332	; 0x18bc
 80064de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80064e2:	781b      	ldrb	r3, [r3, #0]
 80064e4:	f003 0320 	and.w	r3, r3, #32
 80064e8:	2b00      	cmp	r3, #0
 80064ea:	d00f      	beq.n	800650c <uip_process+0x1650>
	uip_slen = 0;
 80064ec:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 80064f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80064f4:	2200      	movs	r2, #0
 80064f6:	801a      	strh	r2, [r3, #0]
	uip_connr->tcpstateflags = UIP_CLOSED;
 80064f8:	2300      	movs	r3, #0
 80064fa:	7663      	strb	r3, [r4, #25]
	BUF->flags = TCP_RST | TCP_ACK;
 80064fc:	f241 7318 	movw	r3, #5912	; 0x1718
 8006500:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006504:	2214      	movs	r2, #20
 8006506:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
	goto tcp_send_nodata;
 800650a:	e138      	b.n	800677e <uip_process+0x18c2>
      }

      if(uip_flags & UIP_CLOSE) {
 800650c:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8006510:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006514:	781b      	ldrb	r3, [r3, #0]
 8006516:	f003 0310 	and.w	r3, r3, #16
 800651a:	2b00      	cmp	r3, #0
 800651c:	d013      	beq.n	8006546 <uip_process+0x168a>
	uip_slen = 0;
 800651e:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 8006522:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006526:	2200      	movs	r2, #0
 8006528:	801a      	strh	r2, [r3, #0]
	uip_connr->len = 1;
 800652a:	2301      	movs	r3, #1
 800652c:	8223      	strh	r3, [r4, #16]
	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
 800652e:	2304      	movs	r3, #4
 8006530:	7663      	strb	r3, [r4, #25]
	uip_connr->nrtx = 0;
 8006532:	2300      	movs	r3, #0
 8006534:	76e3      	strb	r3, [r4, #27]
	BUF->flags = TCP_FIN | TCP_ACK;
 8006536:	f241 7318 	movw	r3, #5912	; 0x1718
 800653a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800653e:	2211      	movs	r2, #17
 8006540:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
	goto tcp_send_nodata;
 8006544:	e11b      	b.n	800677e <uip_process+0x18c2>
      }

      /* If uip_slen > 0, the application has data to be sent. */
      if(uip_slen > 0) {
 8006546:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 800654a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800654e:	881b      	ldrh	r3, [r3, #0]
 8006550:	2b00      	cmp	r3, #0
 8006552:	d028      	beq.n	80065a6 <uip_process+0x16ea>

	/* If the connection has acknowledged data, the contents of
	   the ->len variable should be discarded. */
	if((uip_flags & UIP_ACKDATA) != 0) {
 8006554:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8006558:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800655c:	781b      	ldrb	r3, [r3, #0]
 800655e:	f003 0301 	and.w	r3, r3, #1
 8006562:	2b00      	cmp	r3, #0
 8006564:	d001      	beq.n	800656a <uip_process+0x16ae>
	  uip_connr->len = 0;
 8006566:	2300      	movs	r3, #0
 8006568:	8223      	strh	r3, [r4, #16]
	}

	/* If the ->len variable is non-zero the connection has
	   already data in transit and cannot send anymore right
	   now. */
	if(uip_connr->len == 0) {
 800656a:	8a23      	ldrh	r3, [r4, #16]
 800656c:	2b00      	cmp	r3, #0
 800656e:	d114      	bne.n	800659a <uip_process+0x16de>

	  /* The application cannot send more than what is allowed by
	     the mss (the minumum of the MSS and the available
	     window). */
	  if(uip_slen > uip_connr->mss) {
 8006570:	8a62      	ldrh	r2, [r4, #18]
 8006572:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 8006576:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800657a:	881b      	ldrh	r3, [r3, #0]
 800657c:	429a      	cmp	r2, r3
 800657e:	d205      	bcs.n	800658c <uip_process+0x16d0>
	    uip_slen = uip_connr->mss;
 8006580:	8a62      	ldrh	r2, [r4, #18]
 8006582:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 8006586:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800658a:	801a      	strh	r2, [r3, #0]
	  }

	  /* Remember how much data we send out now so that we know
	     when everything has been acknowledged. */
	  uip_connr->len = uip_slen;
 800658c:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 8006590:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006594:	881b      	ldrh	r3, [r3, #0]
 8006596:	8223      	strh	r3, [r4, #16]
 8006598:	e005      	b.n	80065a6 <uip_process+0x16ea>
	} else {

	  /* If the application already had unacknowledged data, we
	     make sure that the application does not send (i.e.,
	     retransmit) out more than it previously sent out. */
	  uip_slen = uip_connr->len;
 800659a:	8a22      	ldrh	r2, [r4, #16]
 800659c:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 80065a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80065a4:	801a      	strh	r2, [r3, #0]
	}
      }
      uip_connr->nrtx = 0;
 80065a6:	2300      	movs	r3, #0
 80065a8:	76e3      	strb	r3, [r4, #27]
    apprexmit:
      uip_appdata = uip_sappdata;
 80065aa:	f241 7310 	movw	r3, #5904	; 0x1710
 80065ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80065b2:	681a      	ldr	r2, [r3, #0]
 80065b4:	f641 03c4 	movw	r3, #6340	; 0x18c4
 80065b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80065bc:	601a      	str	r2, [r3, #0]
      
      /* If the application has data to be sent, or if the incoming
         packet had new data in it, we must send out a packet. */
      if(uip_slen > 0 && uip_connr->len > 0) {
 80065be:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 80065c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80065c6:	881b      	ldrh	r3, [r3, #0]
 80065c8:	2b00      	cmp	r3, #0
 80065ca:	d012      	beq.n	80065f2 <uip_process+0x1736>
 80065cc:	8a23      	ldrh	r3, [r4, #16]
 80065ce:	2b00      	cmp	r3, #0
 80065d0:	d00f      	beq.n	80065f2 <uip_process+0x1736>
	/* Add the length of the IP and TCP headers. */
	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
 80065d2:	8a23      	ldrh	r3, [r4, #16]
 80065d4:	3328      	adds	r3, #40	; 0x28
 80065d6:	b29a      	uxth	r2, r3
 80065d8:	f241 730c 	movw	r3, #5900	; 0x170c
 80065dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80065e0:	801a      	strh	r2, [r3, #0]
	/* We always set the ACK flag in response packets. */
	BUF->flags = TCP_ACK | TCP_PSH;
 80065e2:	f241 7318 	movw	r3, #5912	; 0x1718
 80065e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80065ea:	2218      	movs	r2, #24
 80065ec:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
	/* Send the packet. */
	goto tcp_send_noopts;
 80065f0:	e0cb      	b.n	800678a <uip_process+0x18ce>
      }
      /* If there is no data to send, just send out a pure ACK if
	 there is newdata. */
      if(uip_flags & UIP_NEWDATA) {
 80065f2:	f641 03bc 	movw	r3, #6332	; 0x18bc
 80065f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80065fa:	781b      	ldrb	r3, [r3, #0]
 80065fc:	f003 0302 	and.w	r3, r3, #2
 8006600:	2b00      	cmp	r3, #0
 8006602:	f000 81db 	beq.w	80069bc <uip_process+0x1b00>
	uip_len = UIP_TCPIP_HLEN;
 8006606:	f241 730c 	movw	r3, #5900	; 0x170c
 800660a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800660e:	2228      	movs	r2, #40	; 0x28
 8006610:	801a      	strh	r2, [r3, #0]
	BUF->flags = TCP_ACK;
 8006612:	f241 7318 	movw	r3, #5912	; 0x1718
 8006616:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800661a:	2210      	movs	r2, #16
 800661c:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
	goto tcp_send_noopts;
 8006620:	e0b3      	b.n	800678a <uip_process+0x18ce>
    }
    goto drop;
  case UIP_LAST_ACK:
    /* We can close this connection if the peer has acknowledged our
       FIN. This is indicated by the UIP_ACKDATA flag. */
    if(uip_flags & UIP_ACKDATA) {
 8006622:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8006626:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800662a:	781b      	ldrb	r3, [r3, #0]
 800662c:	f003 0301 	and.w	r3, r3, #1
 8006630:	2b00      	cmp	r3, #0
 8006632:	f000 809a 	beq.w	800676a <uip_process+0x18ae>
      uip_connr->tcpstateflags = UIP_CLOSED;
 8006636:	2300      	movs	r3, #0
 8006638:	7663      	strb	r3, [r4, #25]
      uip_flags = UIP_CLOSE;
 800663a:	f641 03bc 	movw	r3, #6332	; 0x18bc
 800663e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006642:	2210      	movs	r2, #16
 8006644:	701a      	strb	r2, [r3, #0]
      UIP_APPCALL();
 8006646:	f000 fc4d 	bl	8006ee4 <tcpip_uipcall>
    }
    break;
 800664a:	e08e      	b.n	800676a <uip_process+0x18ae>
    
  case UIP_FIN_WAIT_1:
    /* The application has closed the connection, but the remote host
       hasn't closed its end yet. Thus we do nothing but wait for a
       FIN from the other side. */
    if(uip_len > 0) {
 800664c:	f241 730c 	movw	r3, #5900	; 0x170c
 8006650:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006654:	881b      	ldrh	r3, [r3, #0]
 8006656:	2b00      	cmp	r3, #0
 8006658:	d007      	beq.n	800666a <uip_process+0x17ae>
      uip_add_rcv_nxt(uip_len);
 800665a:	f241 730c 	movw	r3, #5900	; 0x170c
 800665e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006662:	881b      	ldrh	r3, [r3, #0]
 8006664:	4618      	mov	r0, r3
 8006666:	f7fe fbe7 	bl	8004e38 <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
 800666a:	f241 7318 	movw	r3, #5912	; 0x1718
 800666e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006672:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8006676:	f003 0301 	and.w	r3, r3, #1
 800667a:	2b00      	cmp	r3, #0
 800667c:	d01d      	beq.n	80066ba <uip_process+0x17fe>
      if(uip_flags & UIP_ACKDATA) {
 800667e:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8006682:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006686:	781b      	ldrb	r3, [r3, #0]
 8006688:	f003 0301 	and.w	r3, r3, #1
 800668c:	2b00      	cmp	r3, #0
 800668e:	d006      	beq.n	800669e <uip_process+0x17e2>
	uip_connr->tcpstateflags = UIP_TIME_WAIT;
 8006690:	2307      	movs	r3, #7
 8006692:	7663      	strb	r3, [r4, #25]
	uip_connr->timer = 0;
 8006694:	2300      	movs	r3, #0
 8006696:	76a3      	strb	r3, [r4, #26]
	uip_connr->len = 0;
 8006698:	2300      	movs	r3, #0
 800669a:	8223      	strh	r3, [r4, #16]
 800669c:	e001      	b.n	80066a2 <uip_process+0x17e6>
      } else {
	uip_connr->tcpstateflags = UIP_CLOSING;
 800669e:	2306      	movs	r3, #6
 80066a0:	7663      	strb	r3, [r4, #25]
      }
      uip_add_rcv_nxt(1);
 80066a2:	2001      	movs	r0, #1
 80066a4:	f7fe fbc8 	bl	8004e38 <uip_add_rcv_nxt>
      uip_flags = UIP_CLOSE;
 80066a8:	f641 03bc 	movw	r3, #6332	; 0x18bc
 80066ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80066b0:	2210      	movs	r2, #16
 80066b2:	701a      	strb	r2, [r3, #0]
      UIP_APPCALL();
 80066b4:	f000 fc16 	bl	8006ee4 <tcpip_uipcall>
      goto tcp_send_ack;
 80066b8:	e05a      	b.n	8006770 <uip_process+0x18b4>
    } else if(uip_flags & UIP_ACKDATA) {
 80066ba:	f641 03bc 	movw	r3, #6332	; 0x18bc
 80066be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80066c2:	781b      	ldrb	r3, [r3, #0]
 80066c4:	f003 0301 	and.w	r3, r3, #1
 80066c8:	2b00      	cmp	r3, #0
 80066ca:	d004      	beq.n	80066d6 <uip_process+0x181a>
      uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
 80066cc:	2305      	movs	r3, #5
 80066ce:	7663      	strb	r3, [r4, #25]
      uip_connr->len = 0;
 80066d0:	2300      	movs	r3, #0
 80066d2:	8223      	strh	r3, [r4, #16]
      goto drop;
 80066d4:	e177      	b.n	80069c6 <uip_process+0x1b0a>
    }
    if(uip_len > 0) {
 80066d6:	f241 730c 	movw	r3, #5900	; 0x170c
 80066da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80066de:	881b      	ldrh	r3, [r3, #0]
 80066e0:	2b00      	cmp	r3, #0
 80066e2:	f000 816d 	beq.w	80069c0 <uip_process+0x1b04>
      goto tcp_send_ack;
 80066e6:	e043      	b.n	8006770 <uip_process+0x18b4>
    }
    goto drop;
      
  case UIP_FIN_WAIT_2:
    if(uip_len > 0) {
 80066e8:	f241 730c 	movw	r3, #5900	; 0x170c
 80066ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80066f0:	881b      	ldrh	r3, [r3, #0]
 80066f2:	2b00      	cmp	r3, #0
 80066f4:	d007      	beq.n	8006706 <uip_process+0x184a>
      uip_add_rcv_nxt(uip_len);
 80066f6:	f241 730c 	movw	r3, #5900	; 0x170c
 80066fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80066fe:	881b      	ldrh	r3, [r3, #0]
 8006700:	4618      	mov	r0, r3
 8006702:	f7fe fb99 	bl	8004e38 <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
 8006706:	f241 7318 	movw	r3, #5912	; 0x1718
 800670a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800670e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8006712:	f003 0301 	and.w	r3, r3, #1
 8006716:	2b00      	cmp	r3, #0
 8006718:	d00f      	beq.n	800673a <uip_process+0x187e>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
 800671a:	2307      	movs	r3, #7
 800671c:	7663      	strb	r3, [r4, #25]
      uip_connr->timer = 0;
 800671e:	2300      	movs	r3, #0
 8006720:	76a3      	strb	r3, [r4, #26]
      uip_add_rcv_nxt(1);
 8006722:	2001      	movs	r0, #1
 8006724:	f7fe fb88 	bl	8004e38 <uip_add_rcv_nxt>
      uip_flags = UIP_CLOSE;
 8006728:	f641 03bc 	movw	r3, #6332	; 0x18bc
 800672c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006730:	2210      	movs	r2, #16
 8006732:	701a      	strb	r2, [r3, #0]
      UIP_APPCALL();
 8006734:	f000 fbd6 	bl	8006ee4 <tcpip_uipcall>
      goto tcp_send_ack;
 8006738:	e01a      	b.n	8006770 <uip_process+0x18b4>
    }
    if(uip_len > 0) {
 800673a:	f241 730c 	movw	r3, #5900	; 0x170c
 800673e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006742:	881b      	ldrh	r3, [r3, #0]
 8006744:	2b00      	cmp	r3, #0
 8006746:	f000 813d 	beq.w	80069c4 <uip_process+0x1b08>
      goto tcp_send_ack;
 800674a:	e011      	b.n	8006770 <uip_process+0x18b4>

  case UIP_TIME_WAIT:
    goto tcp_send_ack;
    
  case UIP_CLOSING:
    if(uip_flags & UIP_ACKDATA) {
 800674c:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8006750:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006754:	781b      	ldrb	r3, [r3, #0]
 8006756:	f003 0301 	and.w	r3, r3, #1
 800675a:	2b00      	cmp	r3, #0
 800675c:	f000 8128 	beq.w	80069b0 <uip_process+0x1af4>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
 8006760:	2307      	movs	r3, #7
 8006762:	7663      	strb	r3, [r4, #25]
      uip_connr->timer = 0;
 8006764:	2300      	movs	r3, #0
 8006766:	76a3      	strb	r3, [r4, #26]
    }
  }
  goto drop;
 8006768:	e122      	b.n	80069b0 <uip_process+0x1af4>
    if(uip_flags & UIP_ACKDATA) {
      uip_connr->tcpstateflags = UIP_CLOSED;
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
    }
    break;
 800676a:	bf00      	nop
    if(uip_flags & UIP_ACKDATA) {
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
      uip_connr->timer = 0;
    }
  }
  goto drop;
 800676c:	e120      	b.n	80069b0 <uip_process+0x1af4>
      goto tcp_send_ack;
    }
    goto drop;

  case UIP_TIME_WAIT:
    goto tcp_send_ack;
 800676e:	bf00      	nop
  goto drop;
  
  /* We jump here when we are ready to send the packet, and just want
     to set the appropriate TCP sequence numbers in the TCP header. */
 tcp_send_ack:
  BUF->flags = TCP_ACK;
 8006770:	f241 7318 	movw	r3, #5912	; 0x1718
 8006774:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006778:	2210      	movs	r2, #16
 800677a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  
 tcp_send_nodata:
  uip_len = UIP_IPTCPH_LEN;
 800677e:	f241 730c 	movw	r3, #5900	; 0x170c
 8006782:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006786:	2228      	movs	r2, #40	; 0x28
 8006788:	801a      	strh	r2, [r3, #0]

 tcp_send_noopts:
  BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
 800678a:	f241 7318 	movw	r3, #5912	; 0x1718
 800678e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006792:	2250      	movs	r2, #80	; 0x50
 8006794:	f883 2020 	strb.w	r2, [r3, #32]
  /* We're done with the input processing. We are now ready to send a
     reply. Our job is to fill in all the fields of the TCP and IP
     headers before calculating the checksum and finally send the
     packet. */
 tcp_send:
  BUF->ackno[0] = uip_connr->rcv_nxt[0];
 8006798:	f241 7318 	movw	r3, #5912	; 0x1718
 800679c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80067a0:	7a22      	ldrb	r2, [r4, #8]
 80067a2:	771a      	strb	r2, [r3, #28]
  BUF->ackno[1] = uip_connr->rcv_nxt[1];
 80067a4:	f241 7318 	movw	r3, #5912	; 0x1718
 80067a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80067ac:	7a62      	ldrb	r2, [r4, #9]
 80067ae:	775a      	strb	r2, [r3, #29]
  BUF->ackno[2] = uip_connr->rcv_nxt[2];
 80067b0:	f241 7318 	movw	r3, #5912	; 0x1718
 80067b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80067b8:	7aa2      	ldrb	r2, [r4, #10]
 80067ba:	779a      	strb	r2, [r3, #30]
  BUF->ackno[3] = uip_connr->rcv_nxt[3];
 80067bc:	f241 7318 	movw	r3, #5912	; 0x1718
 80067c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80067c4:	7ae2      	ldrb	r2, [r4, #11]
 80067c6:	77da      	strb	r2, [r3, #31]
  
  BUF->seqno[0] = uip_connr->snd_nxt[0];
 80067c8:	f241 7318 	movw	r3, #5912	; 0x1718
 80067cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80067d0:	7b22      	ldrb	r2, [r4, #12]
 80067d2:	761a      	strb	r2, [r3, #24]
  BUF->seqno[1] = uip_connr->snd_nxt[1];
 80067d4:	f241 7318 	movw	r3, #5912	; 0x1718
 80067d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80067dc:	7b62      	ldrb	r2, [r4, #13]
 80067de:	765a      	strb	r2, [r3, #25]
  BUF->seqno[2] = uip_connr->snd_nxt[2];
 80067e0:	f241 7318 	movw	r3, #5912	; 0x1718
 80067e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80067e8:	7ba2      	ldrb	r2, [r4, #14]
 80067ea:	769a      	strb	r2, [r3, #26]
  BUF->seqno[3] = uip_connr->snd_nxt[3];
 80067ec:	f241 7318 	movw	r3, #5912	; 0x1718
 80067f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80067f4:	7be2      	ldrb	r2, [r4, #15]
 80067f6:	76da      	strb	r2, [r3, #27]

  BUF->proto = UIP_PROTO_TCP;
 80067f8:	f241 7318 	movw	r3, #5912	; 0x1718
 80067fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006800:	2206      	movs	r2, #6
 8006802:	725a      	strb	r2, [r3, #9]
  
  BUF->srcport  = uip_connr->lport;
 8006804:	f241 7318 	movw	r3, #5912	; 0x1718
 8006808:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800680c:	88a2      	ldrh	r2, [r4, #4]
 800680e:	829a      	strh	r2, [r3, #20]
  BUF->destport = uip_connr->rport;
 8006810:	f241 7318 	movw	r3, #5912	; 0x1718
 8006814:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006818:	88e2      	ldrh	r2, [r4, #6]
 800681a:	82da      	strh	r2, [r3, #22]

  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
 800681c:	4a72      	ldr	r2, [pc, #456]	; (80069e8 <uip_process+0x1b2c>)
 800681e:	f641 63c4 	movw	r3, #7876	; 0x1ec4
 8006822:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006826:	6818      	ldr	r0, [r3, #0]
 8006828:	6010      	str	r0, [r2, #0]
  uip_ipaddr_copy(&BUF->destipaddr, &uip_connr->ripaddr);
 800682a:	4b70      	ldr	r3, [pc, #448]	; (80069ec <uip_process+0x1b30>)
 800682c:	4622      	mov	r2, r4
 800682e:	6810      	ldr	r0, [r2, #0]
 8006830:	6018      	str	r0, [r3, #0]

  if(uip_connr->tcpstateflags & UIP_STOPPED) {
 8006832:	7e63      	ldrb	r3, [r4, #25]
 8006834:	f003 0310 	and.w	r3, r3, #16
 8006838:	2b00      	cmp	r3, #0
 800683a:	d00f      	beq.n	800685c <uip_process+0x19a0>
    /* If the connection has issued uip_stop(), we advertise a zero
       window so that the remote host will stop sending data. */
    BUF->wnd[0] = BUF->wnd[1] = 0;
 800683c:	f241 7218 	movw	r2, #5912	; 0x1718
 8006840:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8006844:	f241 7318 	movw	r3, #5912	; 0x1718
 8006848:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800684c:	2100      	movs	r1, #0
 800684e:	f883 1023 	strb.w	r1, [r3, #35]	; 0x23
 8006852:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 8006856:	f882 3022 	strb.w	r3, [r2, #34]	; 0x22
 800685a:	e00d      	b.n	8006878 <uip_process+0x19bc>
  } else {
    BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
 800685c:	f241 7318 	movw	r3, #5912	; 0x1718
 8006860:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006864:	2201      	movs	r2, #1
 8006866:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
    BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
 800686a:	f241 7318 	movw	r3, #5912	; 0x1718
 800686e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006872:	227c      	movs	r2, #124	; 0x7c
 8006874:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
  }
  
 tcp_send_noconn:
  BUF->ttl = UIP_TTL;
 8006878:	f241 7318 	movw	r3, #5912	; 0x1718
 800687c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006880:	2240      	movs	r2, #64	; 0x40
 8006882:	721a      	strb	r2, [r3, #8]
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
 8006884:	f241 7318 	movw	r3, #5912	; 0x1718
 8006888:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800688c:	f241 720c 	movw	r2, #5900	; 0x170c
 8006890:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8006894:	8812      	ldrh	r2, [r2, #0]
 8006896:	0a12      	lsrs	r2, r2, #8
 8006898:	b292      	uxth	r2, r2
 800689a:	b2d2      	uxtb	r2, r2
 800689c:	709a      	strb	r2, [r3, #2]
  BUF->len[1] = (uip_len & 0xff);
 800689e:	f241 7318 	movw	r3, #5912	; 0x1718
 80068a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80068a6:	f241 720c 	movw	r2, #5900	; 0x170c
 80068aa:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80068ae:	8812      	ldrh	r2, [r2, #0]
 80068b0:	b2d2      	uxtb	r2, r2
 80068b2:	70da      	strb	r2, [r3, #3]
#endif /* UIP_CONF_IPV6 */

  BUF->urgp[0] = BUF->urgp[1] = 0;
 80068b4:	f241 7218 	movw	r2, #5912	; 0x1718
 80068b8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80068bc:	f241 7318 	movw	r3, #5912	; 0x1718
 80068c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80068c4:	2100      	movs	r1, #0
 80068c6:	f883 1027 	strb.w	r1, [r3, #39]	; 0x27
 80068ca:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 80068ce:	f882 3026 	strb.w	r3, [r2, #38]	; 0x26
  
  /* Calculate TCP checksum. */
  BUF->tcpchksum = 0;
 80068d2:	f241 7318 	movw	r3, #5912	; 0x1718
 80068d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80068da:	2200      	movs	r2, #0
 80068dc:	849a      	strh	r2, [r3, #36]	; 0x24
  BUF->tcpchksum = ~(uip_tcpchksum());
 80068de:	f241 7418 	movw	r4, #5912	; 0x1718
 80068e2:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80068e6:	f7fe f98b 	bl	8004c00 <uip_tcpchksum>
 80068ea:	4603      	mov	r3, r0
 80068ec:	43db      	mvns	r3, r3
 80068ee:	b29b      	uxth	r3, r3
 80068f0:	84a3      	strh	r3, [r4, #36]	; 0x24
 80068f2:	e000      	b.n	80068f6 <uip_process+0x1a3a>
  if(UDPBUF->udpchksum == 0) {
    UDPBUF->udpchksum = 0xffff;
  }
#endif /* UIP_UDP_CHECKSUMS */
  
  goto ip_send_nolen;
 80068f4:	bf00      	nop
#if UIP_CONF_IPV6
  BUF->vtc = 0x60;
  BUF->tcflow = 0x00;
  BUF->flow = 0x00;
#else /* UIP_CONF_IPV6 */
  BUF->vhl = 0x45;
 80068f6:	f241 7318 	movw	r3, #5912	; 0x1718
 80068fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80068fe:	2245      	movs	r2, #69	; 0x45
 8006900:	701a      	strb	r2, [r3, #0]
  BUF->tos = 0;
 8006902:	f241 7318 	movw	r3, #5912	; 0x1718
 8006906:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800690a:	2200      	movs	r2, #0
 800690c:	705a      	strb	r2, [r3, #1]
  BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
 800690e:	f241 7218 	movw	r2, #5912	; 0x1718
 8006912:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8006916:	f241 7318 	movw	r3, #5912	; 0x1718
 800691a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800691e:	2100      	movs	r1, #0
 8006920:	71d9      	strb	r1, [r3, #7]
 8006922:	79db      	ldrb	r3, [r3, #7]
 8006924:	7193      	strb	r3, [r2, #6]
  ++ipid;
 8006926:	f241 536a 	movw	r3, #5482	; 0x156a
 800692a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800692e:	881b      	ldrh	r3, [r3, #0]
 8006930:	3301      	adds	r3, #1
 8006932:	b29a      	uxth	r2, r3
 8006934:	f241 536a 	movw	r3, #5482	; 0x156a
 8006938:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800693c:	801a      	strh	r2, [r3, #0]
  BUF->ipid[0] = ipid >> 8;
 800693e:	f241 7318 	movw	r3, #5912	; 0x1718
 8006942:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006946:	f241 526a 	movw	r2, #5482	; 0x156a
 800694a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800694e:	8812      	ldrh	r2, [r2, #0]
 8006950:	0a12      	lsrs	r2, r2, #8
 8006952:	b292      	uxth	r2, r2
 8006954:	b2d2      	uxtb	r2, r2
 8006956:	711a      	strb	r2, [r3, #4]
  BUF->ipid[1] = ipid & 0xff;
 8006958:	f241 7318 	movw	r3, #5912	; 0x1718
 800695c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006960:	f241 526a 	movw	r2, #5482	; 0x156a
 8006964:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8006968:	8812      	ldrh	r2, [r2, #0]
 800696a:	b2d2      	uxtb	r2, r2
 800696c:	715a      	strb	r2, [r3, #5]
  /* Calculate IP checksum. */
  BUF->ipchksum = 0;
 800696e:	f241 7318 	movw	r3, #5912	; 0x1718
 8006972:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006976:	2200      	movs	r2, #0
 8006978:	815a      	strh	r2, [r3, #10]
  BUF->ipchksum = ~(uip_ipchksum());
 800697a:	f241 7418 	movw	r4, #5912	; 0x1718
 800697e:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8006982:	f7fe f8df 	bl	8004b44 <uip_ipchksum>
 8006986:	4603      	mov	r3, r0
 8006988:	43db      	mvns	r3, r3
 800698a:	b29b      	uxth	r3, r3
 800698c:	8163      	strh	r3, [r4, #10]
  DEBUG_PRINTF("Sending packet with length %d (%d)\n", uip_len,
	       (BUF->len[0] << 8) | BUF->len[1]);
  
  UIP_STAT(++uip_stat.ip.sent);
  /* Return and let the caller do the actual transmission. */
  uip_flags = 0;
 800698e:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8006992:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006996:	2200      	movs	r2, #0
 8006998:	701a      	strb	r2, [r3, #0]
  return;
 800699a:	e021      	b.n	80069e0 <uip_process+0x1b24>
      /* In the SYN_SENT state, we retransmit out SYN. */
      BUF->flags = 0;
      goto tcp_send_syn;
#endif /* UIP_ACTIVE_OPEN */
    }
    goto drop;
 800699c:	bf00      	nop
 800699e:	e012      	b.n	80069c6 <uip_process+0x1b0a>
	uip_flags = UIP_POLL;
	UIP_APPCALL();
	goto appsend;
      }
    }
    goto drop;
 80069a0:	bf00      	nop
 80069a2:	e010      	b.n	80069c6 <uip_process+0x1b0a>
      uip_len = uip_slen = 0;
      uip_flags = UIP_POLL;
      UIP_UDP_APPCALL();
      goto udp_send;
    } else {
      goto drop;
 80069a4:	bf00      	nop
 80069a6:	e00e      	b.n	80069c6 <uip_process+0x1b0a>
  uip_slen = 0;
  UIP_UDP_APPCALL();

 udp_send:
  if(uip_slen == 0) {
    goto drop;
 80069a8:	bf00      	nop
 80069aa:	e00c      	b.n	80069c6 <uip_process+0x1b0a>
  UIP_STAT(++uip_stat.tcp.synrst);

 reset:
  /* We do not send resets in response to resets. */
  if(BUF->flags & TCP_RST) {
    goto drop;
 80069ac:	bf00      	nop
 80069ae:	e00a      	b.n	80069c6 <uip_process+0x1b0a>
    if(uip_flags & UIP_ACKDATA) {
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
      uip_connr->timer = 0;
    }
  }
  goto drop;
 80069b0:	bf00      	nop
 80069b2:	e008      	b.n	80069c6 <uip_process+0x1b0a>
    }
    /* We need to retransmit the SYNACK */
    if((BUF->flags & TCP_CTL) == TCP_SYN) {
      goto tcp_send_synack;
    }
    goto drop;
 80069b4:	bf00      	nop
 80069b6:	e006      	b.n	80069c6 <uip_process+0x1b0a>
    state. We require that there is no outstanding data; otherwise the
    sequence numbers will be screwed up. */

    if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
      if(uip_outstanding(uip_connr)) {
	goto drop;
 80069b8:	bf00      	nop
 80069ba:	e004      	b.n	80069c6 <uip_process+0x1b0a>
	uip_len = UIP_TCPIP_HLEN;
	BUF->flags = TCP_ACK;
	goto tcp_send_noopts;
      }
    }
    goto drop;
 80069bc:	bf00      	nop
 80069be:	e002      	b.n	80069c6 <uip_process+0x1b0a>
      goto drop;
    }
    if(uip_len > 0) {
      goto tcp_send_ack;
    }
    goto drop;
 80069c0:	bf00      	nop
 80069c2:	e000      	b.n	80069c6 <uip_process+0x1b0a>
      goto tcp_send_ack;
    }
    if(uip_len > 0) {
      goto tcp_send_ack;
    }
    goto drop;
 80069c4:	bf00      	nop
  /* Return and let the caller do the actual transmission. */
  uip_flags = 0;
  return;

 drop:
  uip_len = 0;
 80069c6:	f241 730c 	movw	r3, #5900	; 0x170c
 80069ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80069ce:	2200      	movs	r2, #0
 80069d0:	801a      	strh	r2, [r3, #0]
  uip_flags = 0;
 80069d2:	f641 03bc 	movw	r3, #6332	; 0x18bc
 80069d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80069da:	2200      	movs	r2, #0
 80069dc:	701a      	strb	r2, [r3, #0]
  return;
 80069de:	bf00      	nop
}
 80069e0:	f107 0714 	add.w	r7, r7, #20
 80069e4:	46bd      	mov	sp, r7
 80069e6:	bd90      	pop	{r4, r7, pc}
 80069e8:	20001724 	.word	0x20001724
 80069ec:	20001728 	.word	0x20001728

080069f0 <uip_htons>:
/*---------------------------------------------------------------------------*/
uint16_t
uip_htons(uint16_t val)
{
 80069f0:	b480      	push	{r7}
 80069f2:	b083      	sub	sp, #12
 80069f4:	af00      	add	r7, sp, #0
 80069f6:	4603      	mov	r3, r0
 80069f8:	80fb      	strh	r3, [r7, #6]
  return UIP_HTONS(val);
 80069fa:	88fb      	ldrh	r3, [r7, #6]
 80069fc:	021b      	lsls	r3, r3, #8
 80069fe:	b29a      	uxth	r2, r3
 8006a00:	88fb      	ldrh	r3, [r7, #6]
 8006a02:	0a1b      	lsrs	r3, r3, #8
 8006a04:	b29b      	uxth	r3, r3
 8006a06:	b29b      	uxth	r3, r3
 8006a08:	4313      	orrs	r3, r2
 8006a0a:	b29b      	uxth	r3, r3
 8006a0c:	b29b      	uxth	r3, r3
}
 8006a0e:	4618      	mov	r0, r3
 8006a10:	f107 070c 	add.w	r7, r7, #12
 8006a14:	46bd      	mov	sp, r7
 8006a16:	bc80      	pop	{r7}
 8006a18:	4770      	bx	lr
 8006a1a:	bf00      	nop

08006a1c <uip_send>:
  return UIP_HTONL(val);
}
/*---------------------------------------------------------------------------*/
void
uip_send(const void *data, int len)
{
 8006a1c:	b580      	push	{r7, lr}
 8006a1e:	b084      	sub	sp, #16
 8006a20:	af00      	add	r7, sp, #0
 8006a22:	6078      	str	r0, [r7, #4]
 8006a24:	6039      	str	r1, [r7, #0]
  int copylen;
#define MIN(a,b) ((a) < (b)? (a): (b))
  copylen = MIN(len, UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN -
 8006a26:	4b19      	ldr	r3, [pc, #100]	; (8006a8c <uip_send+0x70>)
 8006a28:	f503 72be 	add.w	r2, r3, #380	; 0x17c
 8006a2c:	f241 7310 	movw	r3, #5904	; 0x1710
 8006a30:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006a34:	681b      	ldr	r3, [r3, #0]
 8006a36:	1ad2      	subs	r2, r2, r3
 8006a38:	683b      	ldr	r3, [r7, #0]
 8006a3a:	429a      	cmp	r2, r3
 8006a3c:	bfb8      	it	lt
 8006a3e:	4613      	movlt	r3, r2
 8006a40:	60fb      	str	r3, [r7, #12]
		(int)((char *)uip_sappdata - (char *)&uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN]));
  if(copylen > 0) {
 8006a42:	68fb      	ldr	r3, [r7, #12]
 8006a44:	2b00      	cmp	r3, #0
 8006a46:	dd1d      	ble.n	8006a84 <uip_send+0x68>
    uip_slen = copylen;
 8006a48:	68fb      	ldr	r3, [r7, #12]
 8006a4a:	b29a      	uxth	r2, r3
 8006a4c:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 8006a50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006a54:	801a      	strh	r2, [r3, #0]
    if(data != uip_sappdata) {
 8006a56:	f241 7310 	movw	r3, #5904	; 0x1710
 8006a5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006a5e:	681b      	ldr	r3, [r3, #0]
 8006a60:	687a      	ldr	r2, [r7, #4]
 8006a62:	429a      	cmp	r2, r3
 8006a64:	d00e      	beq.n	8006a84 <uip_send+0x68>
      memcpy(uip_sappdata, (data), uip_slen);
 8006a66:	f241 7310 	movw	r3, #5904	; 0x1710
 8006a6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006a6e:	681a      	ldr	r2, [r3, #0]
 8006a70:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 8006a74:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006a78:	881b      	ldrh	r3, [r3, #0]
 8006a7a:	4610      	mov	r0, r2
 8006a7c:	6879      	ldr	r1, [r7, #4]
 8006a7e:	461a      	mov	r2, r3
 8006a80:	f7f9 fc1b 	bl	80002ba <memcpy>
    }
  }
}
 8006a84:	f107 0710 	add.w	r7, r7, #16
 8006a88:	46bd      	mov	sp, r7
 8006a8a:	bd80      	pop	{r7, pc}
 8006a8c:	20001740 	.word	0x20001740

08006a90 <uiplib_ipaddrconv>:
#include "net/uip-debug.h"

/*-----------------------------------------------------------------------------------*/
int
uiplib_ipaddrconv(const char *addrstr, uip_ipaddr_t *ipaddr)
{
 8006a90:	b480      	push	{r7}
 8006a92:	b085      	sub	sp, #20
 8006a94:	af00      	add	r7, sp, #0
 8006a96:	6078      	str	r0, [r7, #4]
 8006a98:	6039      	str	r1, [r7, #0]

  unsigned char tmp;
  char c;
  unsigned char i, j;

  tmp = 0;
 8006a9a:	2300      	movs	r3, #0
 8006a9c:	73fb      	strb	r3, [r7, #15]
  
  for(i = 0; i < 4; ++i) {
 8006a9e:	2300      	movs	r3, #0
 8006aa0:	73bb      	strb	r3, [r7, #14]
 8006aa2:	e039      	b.n	8006b18 <uiplib_ipaddrconv+0x88>
    j = 0;
 8006aa4:	2300      	movs	r3, #0
 8006aa6:	737b      	strb	r3, [r7, #13]
    do {
      c = *addrstr;
 8006aa8:	687b      	ldr	r3, [r7, #4]
 8006aaa:	781b      	ldrb	r3, [r3, #0]
 8006aac:	733b      	strb	r3, [r7, #12]
      ++j;
 8006aae:	7b7b      	ldrb	r3, [r7, #13]
 8006ab0:	3301      	adds	r3, #1
 8006ab2:	737b      	strb	r3, [r7, #13]
      if(j > 4) {
 8006ab4:	7b7b      	ldrb	r3, [r7, #13]
 8006ab6:	2b04      	cmp	r3, #4
 8006ab8:	d901      	bls.n	8006abe <uiplib_ipaddrconv+0x2e>
	return 0;
 8006aba:	2300      	movs	r3, #0
 8006abc:	e030      	b.n	8006b20 <uiplib_ipaddrconv+0x90>
      }
      if(c == '.' || c == 0) {
 8006abe:	7b3b      	ldrb	r3, [r7, #12]
 8006ac0:	2b2e      	cmp	r3, #46	; 0x2e
 8006ac2:	d002      	beq.n	8006aca <uiplib_ipaddrconv+0x3a>
 8006ac4:	7b3b      	ldrb	r3, [r7, #12]
 8006ac6:	2b00      	cmp	r3, #0
 8006ac8:	d106      	bne.n	8006ad8 <uiplib_ipaddrconv+0x48>
	ipaddr->u8[i] = tmp;
 8006aca:	7bbb      	ldrb	r3, [r7, #14]
 8006acc:	683a      	ldr	r2, [r7, #0]
 8006ace:	7bf9      	ldrb	r1, [r7, #15]
 8006ad0:	54d1      	strb	r1, [r2, r3]
	tmp = 0;
 8006ad2:	2300      	movs	r3, #0
 8006ad4:	73fb      	strb	r3, [r7, #15]
 8006ad6:	e013      	b.n	8006b00 <uiplib_ipaddrconv+0x70>
      } else if(c >= '0' && c <= '9') {
 8006ad8:	7b3b      	ldrb	r3, [r7, #12]
 8006ada:	2b2f      	cmp	r3, #47	; 0x2f
 8006adc:	d90e      	bls.n	8006afc <uiplib_ipaddrconv+0x6c>
 8006ade:	7b3b      	ldrb	r3, [r7, #12]
 8006ae0:	2b39      	cmp	r3, #57	; 0x39
 8006ae2:	d80b      	bhi.n	8006afc <uiplib_ipaddrconv+0x6c>
	tmp = (tmp * 10) + (c - '0');
 8006ae4:	7bfb      	ldrb	r3, [r7, #15]
 8006ae6:	461a      	mov	r2, r3
 8006ae8:	0092      	lsls	r2, r2, #2
 8006aea:	18d3      	adds	r3, r2, r3
 8006aec:	005b      	lsls	r3, r3, #1
 8006aee:	b2da      	uxtb	r2, r3
 8006af0:	7b3b      	ldrb	r3, [r7, #12]
 8006af2:	18d3      	adds	r3, r2, r3
 8006af4:	b2db      	uxtb	r3, r3
 8006af6:	3b30      	subs	r3, #48	; 0x30
 8006af8:	73fb      	strb	r3, [r7, #15]
 8006afa:	e001      	b.n	8006b00 <uiplib_ipaddrconv+0x70>
      } else {
	return 0;
 8006afc:	2300      	movs	r3, #0
 8006afe:	e00f      	b.n	8006b20 <uiplib_ipaddrconv+0x90>
      }
      ++addrstr;
 8006b00:	687b      	ldr	r3, [r7, #4]
 8006b02:	3301      	adds	r3, #1
 8006b04:	607b      	str	r3, [r7, #4]
    } while(c != '.' && c != 0);
 8006b06:	7b3b      	ldrb	r3, [r7, #12]
 8006b08:	2b2e      	cmp	r3, #46	; 0x2e
 8006b0a:	d002      	beq.n	8006b12 <uiplib_ipaddrconv+0x82>
 8006b0c:	7b3b      	ldrb	r3, [r7, #12]
 8006b0e:	2b00      	cmp	r3, #0
 8006b10:	d1ca      	bne.n	8006aa8 <uiplib_ipaddrconv+0x18>
  char c;
  unsigned char i, j;

  tmp = 0;
  
  for(i = 0; i < 4; ++i) {
 8006b12:	7bbb      	ldrb	r3, [r7, #14]
 8006b14:	3301      	adds	r3, #1
 8006b16:	73bb      	strb	r3, [r7, #14]
 8006b18:	7bbb      	ldrb	r3, [r7, #14]
 8006b1a:	2b03      	cmp	r3, #3
 8006b1c:	d9c2      	bls.n	8006aa4 <uiplib_ipaddrconv+0x14>
      }
      ++addrstr;
    } while(c != '.' && c != 0);
  }
#endif /* UIP_CONF_IPV6 */
  return 1;
 8006b1e:	2301      	movs	r3, #1
}
 8006b20:	4618      	mov	r0, r3
 8006b22:	f107 0714 	add.w	r7, r7, #20
 8006b26:	46bd      	mov	sp, r7
 8006b28:	bc80      	pop	{r7}
 8006b2a:	4770      	bx	lr

08006b2c <tcpip_output>:
#else

static uint8_t (* outputfunc)(void);
uint8_t
tcpip_output(void)
{
 8006b2c:	b580      	push	{r7, lr}
 8006b2e:	af00      	add	r7, sp, #0
  if(outputfunc != NULL) {
 8006b30:	f241 63cc 	movw	r3, #5836	; 0x16cc
 8006b34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006b38:	681b      	ldr	r3, [r3, #0]
 8006b3a:	2b00      	cmp	r3, #0
 8006b3c:	d007      	beq.n	8006b4e <tcpip_output+0x22>
    return outputfunc();
 8006b3e:	f241 63cc 	movw	r3, #5836	; 0x16cc
 8006b42:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006b46:	681b      	ldr	r3, [r3, #0]
 8006b48:	4798      	blx	r3
 8006b4a:	4603      	mov	r3, r0
 8006b4c:	e006      	b.n	8006b5c <tcpip_output+0x30>
  }
  UIP_LOG("tcpip_output: Use tcpip_set_outputfunc() to set an output function");
 8006b4e:	f249 00e0 	movw	r0, #37088	; 0x90e0
 8006b52:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006b56:	f7fc f9bd 	bl	8002ed4 <uip_log>
  return 0;
 8006b5a:	2300      	movs	r3, #0
}
 8006b5c:	4618      	mov	r0, r3
 8006b5e:	bd80      	pop	{r7, pc}

08006b60 <tcpip_set_outputfunc>:

void
tcpip_set_outputfunc(uint8_t (*f)(void))
{
 8006b60:	b480      	push	{r7}
 8006b62:	b083      	sub	sp, #12
 8006b64:	af00      	add	r7, sp, #0
 8006b66:	6078      	str	r0, [r7, #4]
  outputfunc = f;
 8006b68:	f241 63cc 	movw	r3, #5836	; 0x16cc
 8006b6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006b70:	687a      	ldr	r2, [r7, #4]
 8006b72:	601a      	str	r2, [r3, #0]
}
 8006b74:	f107 070c 	add.w	r7, r7, #12
 8006b78:	46bd      	mov	sp, r7
 8006b7a:	bc80      	pop	{r7}
 8006b7c:	4770      	bx	lr
 8006b7e:	bf00      	nop

08006b80 <start_periodic_tcp_timer>:
PROCESS(tcpip_process, "TCP/IP stack");

/*---------------------------------------------------------------------------*/
static void
start_periodic_tcp_timer(void)
{
 8006b80:	b580      	push	{r7, lr}
 8006b82:	af00      	add	r7, sp, #0
  if(etimer_expired(&periodic)) {
 8006b84:	f241 5078 	movw	r0, #5496	; 0x1578
 8006b88:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006b8c:	f7fd fe1e 	bl	80047cc <etimer_expired>
 8006b90:	4603      	mov	r3, r0
 8006b92:	2b00      	cmp	r3, #0
 8006b94:	d005      	beq.n	8006ba2 <start_periodic_tcp_timer+0x22>
    etimer_restart(&periodic);
 8006b96:	f241 5078 	movw	r0, #5496	; 0x1578
 8006b9a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006b9e:	f7fd fe05 	bl	80047ac <etimer_restart>
  }
}
 8006ba2:	bd80      	pop	{r7, pc}

08006ba4 <check_for_tcp_syn>:
/*---------------------------------------------------------------------------*/
static void
check_for_tcp_syn(void)
{
 8006ba4:	b580      	push	{r7, lr}
 8006ba6:	af00      	add	r7, sp, #0
     an incoming packet contains a SYN: since uIP does not inform the
     application if a SYN arrives, we have no other way of starting
     this timer.  This function is called for every incoming IP packet
     to check for such SYNs. */
#define TCP_SYN 0x02
  if(UIP_IP_BUF->proto == UIP_PROTO_TCP &&
 8006ba8:	f241 7318 	movw	r3, #5912	; 0x1718
 8006bac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006bb0:	7a5b      	ldrb	r3, [r3, #9]
 8006bb2:	2b06      	cmp	r3, #6
 8006bb4:	d10b      	bne.n	8006bce <check_for_tcp_syn+0x2a>
     (UIP_TCP_BUF->flags & TCP_SYN) == TCP_SYN) {
 8006bb6:	f241 7318 	movw	r3, #5912	; 0x1718
 8006bba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006bbe:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8006bc2:	f003 0302 	and.w	r3, r3, #2
     an incoming packet contains a SYN: since uIP does not inform the
     application if a SYN arrives, we have no other way of starting
     this timer.  This function is called for every incoming IP packet
     to check for such SYNs. */
#define TCP_SYN 0x02
  if(UIP_IP_BUF->proto == UIP_PROTO_TCP &&
 8006bc6:	2b00      	cmp	r3, #0
 8006bc8:	d001      	beq.n	8006bce <check_for_tcp_syn+0x2a>
     (UIP_TCP_BUF->flags & TCP_SYN) == TCP_SYN) {
    start_periodic_tcp_timer();
 8006bca:	f7ff ffd9 	bl	8006b80 <start_periodic_tcp_timer>
  }
}
 8006bce:	bd80      	pop	{r7, pc}

08006bd0 <packet_input>:
/*---------------------------------------------------------------------------*/
static void
packet_input(void)
{
 8006bd0:	b580      	push	{r7, lr}
 8006bd2:	af00      	add	r7, sp, #0
      }
    }
    tcpip_is_forwarding = 0;
  }
#else /* UIP_CONF_IP_FORWARD */
  if(uip_len > 0) {
 8006bd4:	f241 730c 	movw	r3, #5900	; 0x170c
 8006bd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006bdc:	881b      	ldrh	r3, [r3, #0]
 8006bde:	2b00      	cmp	r3, #0
 8006be0:	d00d      	beq.n	8006bfe <packet_input+0x2e>
    check_for_tcp_syn();
 8006be2:	f7ff ffdf 	bl	8006ba4 <check_for_tcp_syn>
    uip_input();
 8006be6:	2001      	movs	r0, #1
 8006be8:	f7fe f968 	bl	8004ebc <uip_process>
    if(uip_len > 0) {
 8006bec:	f241 730c 	movw	r3, #5900	; 0x170c
 8006bf0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006bf4:	881b      	ldrh	r3, [r3, #0]
 8006bf6:	2b00      	cmp	r3, #0
 8006bf8:	d001      	beq.n	8006bfe <packet_input+0x2e>
#if UIP_CONF_TCP_SPLIT
      uip_split_output();
 8006bfa:	f000 fa49 	bl	8007090 <uip_split_output>
#endif
#endif /* UIP_CONF_TCP_SPLIT */
    }
  }
#endif /* UIP_CONF_IP_FORWARD */
}
 8006bfe:	bd80      	pop	{r7, pc}

08006c00 <tcp_listen>:
  }
}
/*---------------------------------------------------------------------------*/
void
tcp_listen(uint16_t port)
{
 8006c00:	b580      	push	{r7, lr}
 8006c02:	b084      	sub	sp, #16
 8006c04:	af00      	add	r7, sp, #0
 8006c06:	4603      	mov	r3, r0
 8006c08:	80fb      	strh	r3, [r7, #6]
  static unsigned char i;
  struct listenport *l;

  l = s.listenports;
 8006c0a:	f241 5388 	movw	r3, #5512	; 0x1588
 8006c0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006c12:	60fb      	str	r3, [r7, #12]
  for(i = 0; i < UIP_LISTENPORTS; ++i) {
 8006c14:	f241 63d3 	movw	r3, #5843	; 0x16d3
 8006c18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006c1c:	2200      	movs	r2, #0
 8006c1e:	701a      	strb	r2, [r3, #0]
 8006c20:	e021      	b.n	8006c66 <tcp_listen+0x66>
    if(l->port == 0) {
 8006c22:	68fb      	ldr	r3, [r7, #12]
 8006c24:	881b      	ldrh	r3, [r3, #0]
 8006c26:	2b00      	cmp	r3, #0
 8006c28:	d10e      	bne.n	8006c48 <tcp_listen+0x48>
      l->port = port;
 8006c2a:	68fb      	ldr	r3, [r7, #12]
 8006c2c:	88fa      	ldrh	r2, [r7, #6]
 8006c2e:	801a      	strh	r2, [r3, #0]
      l->p = PROCESS_CURRENT();
 8006c30:	f241 33c4 	movw	r3, #5060	; 0x13c4
 8006c34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006c38:	681a      	ldr	r2, [r3, #0]
 8006c3a:	68fb      	ldr	r3, [r7, #12]
 8006c3c:	605a      	str	r2, [r3, #4]
      uip_listen(port);
 8006c3e:	88fb      	ldrh	r3, [r7, #6]
 8006c40:	4618      	mov	r0, r3
 8006c42:	f7fe f8b9 	bl	8004db8 <uip_listen>
      break;
 8006c46:	e015      	b.n	8006c74 <tcp_listen+0x74>
    }
    ++l;
 8006c48:	68fb      	ldr	r3, [r7, #12]
 8006c4a:	3308      	adds	r3, #8
 8006c4c:	60fb      	str	r3, [r7, #12]
{
  static unsigned char i;
  struct listenport *l;

  l = s.listenports;
  for(i = 0; i < UIP_LISTENPORTS; ++i) {
 8006c4e:	f241 63d3 	movw	r3, #5843	; 0x16d3
 8006c52:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006c56:	781b      	ldrb	r3, [r3, #0]
 8006c58:	3301      	adds	r3, #1
 8006c5a:	b2da      	uxtb	r2, r3
 8006c5c:	f241 63d3 	movw	r3, #5843	; 0x16d3
 8006c60:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006c64:	701a      	strb	r2, [r3, #0]
 8006c66:	f241 63d3 	movw	r3, #5843	; 0x16d3
 8006c6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006c6e:	781b      	ldrb	r3, [r3, #0]
 8006c70:	2b27      	cmp	r3, #39	; 0x27
 8006c72:	d9d6      	bls.n	8006c22 <tcp_listen+0x22>
      uip_listen(port);
      break;
    }
    ++l;
  }
}
 8006c74:	f107 0710 	add.w	r7, r7, #16
 8006c78:	46bd      	mov	sp, r7
 8006c7a:	bd80      	pop	{r7, pc}

08006c7c <tcp_attach>:
/*---------------------------------------------------------------------------*/
void
tcp_attach(struct uip_conn *conn,
	   void *appstate)
{
 8006c7c:	b490      	push	{r4, r7}
 8006c7e:	b082      	sub	sp, #8
 8006c80:	af00      	add	r7, sp, #0
 8006c82:	6078      	str	r0, [r7, #4]
 8006c84:	6039      	str	r1, [r7, #0]
  register uip_tcp_appstate_t *s;

  s = &conn->appstate;
 8006c86:	687b      	ldr	r3, [r7, #4]
 8006c88:	f103 041c 	add.w	r4, r3, #28
  s->p = PROCESS_CURRENT();
 8006c8c:	f241 33c4 	movw	r3, #5060	; 0x13c4
 8006c90:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006c94:	681b      	ldr	r3, [r3, #0]
 8006c96:	6023      	str	r3, [r4, #0]
  s->state = appstate;
 8006c98:	683b      	ldr	r3, [r7, #0]
 8006c9a:	6063      	str	r3, [r4, #4]
}
 8006c9c:	f107 0708 	add.w	r7, r7, #8
 8006ca0:	46bd      	mov	sp, r7
 8006ca2:	bc90      	pop	{r4, r7}
 8006ca4:	4770      	bx	lr
 8006ca6:	bf00      	nop

08006ca8 <eventhandler>:
}
#endif /* UIP_CONF_ICMP6 */
/*---------------------------------------------------------------------------*/
static void
eventhandler(process_event_t ev, process_data_t data)
{
 8006ca8:	b590      	push	{r4, r7, lr}
 8006caa:	b085      	sub	sp, #20
 8006cac:	af00      	add	r7, sp, #0
 8006cae:	4603      	mov	r3, r0
 8006cb0:	6039      	str	r1, [r7, #0]
 8006cb2:	71fb      	strb	r3, [r7, #7]
  static unsigned char i;
  register struct listenport *l;
#endif /*UIP_TCP*/
  struct process *p;
   
  switch(ev) {
 8006cb4:	79fb      	ldrb	r3, [r7, #7]
 8006cb6:	2b02      	cmp	r3, #2
 8006cb8:	f000 80f0 	beq.w	8006e9c <eventhandler+0x1f4>
 8006cbc:	2b02      	cmp	r3, #2
 8006cbe:	dc06      	bgt.n	8006cce <eventhandler+0x26>
 8006cc0:	2b00      	cmp	r3, #0
 8006cc2:	f000 80bd 	beq.w	8006e40 <eventhandler+0x198>
 8006cc6:	2b01      	cmp	r3, #1
 8006cc8:	f000 80d2 	beq.w	8006e70 <eventhandler+0x1c8>
 8006ccc:	e0ef      	b.n	8006eae <eventhandler+0x206>
 8006cce:	2b87      	cmp	r3, #135	; 0x87
 8006cd0:	d002      	beq.n	8006cd8 <eventhandler+0x30>
 8006cd2:	2b88      	cmp	r3, #136	; 0x88
 8006cd4:	d04e      	beq.n	8006d74 <eventhandler+0xcc>
 8006cd6:	e0ea      	b.n	8006eae <eventhandler+0x206>
      /* This is the event we get if a process has exited. We go through
         the TCP/IP tables to see if this process had any open
         connections or listening TCP ports. If so, we'll close those
         connections. */

      p = (struct process *)data;
 8006cd8:	683b      	ldr	r3, [r7, #0]
 8006cda:	60fb      	str	r3, [r7, #12]
#if UIP_TCP
      l = s.listenports;
 8006cdc:	f241 5488 	movw	r4, #5512	; 0x1588
 8006ce0:	f2c2 0400 	movt	r4, #8192	; 0x2000
      for(i = 0; i < UIP_LISTENPORTS; ++i) {
 8006ce4:	f241 63d2 	movw	r3, #5842	; 0x16d2
 8006ce8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006cec:	2200      	movs	r2, #0
 8006cee:	701a      	strb	r2, [r3, #0]
 8006cf0:	e018      	b.n	8006d24 <eventhandler+0x7c>
        if(l->p == p) {
 8006cf2:	6862      	ldr	r2, [r4, #4]
 8006cf4:	68fb      	ldr	r3, [r7, #12]
 8006cf6:	429a      	cmp	r2, r3
 8006cf8:	d107      	bne.n	8006d0a <eventhandler+0x62>
          uip_unlisten(l->port);
 8006cfa:	8823      	ldrh	r3, [r4, #0]
 8006cfc:	4618      	mov	r0, r3
 8006cfe:	f7fe f819 	bl	8004d34 <uip_unlisten>
          l->port = 0;
 8006d02:	2300      	movs	r3, #0
 8006d04:	8023      	strh	r3, [r4, #0]
          l->p = PROCESS_NONE;
 8006d06:	2300      	movs	r3, #0
 8006d08:	6063      	str	r3, [r4, #4]
        }
        ++l;
 8006d0a:	3408      	adds	r4, #8
         connections. */

      p = (struct process *)data;
#if UIP_TCP
      l = s.listenports;
      for(i = 0; i < UIP_LISTENPORTS; ++i) {
 8006d0c:	f241 63d2 	movw	r3, #5842	; 0x16d2
 8006d10:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006d14:	781b      	ldrb	r3, [r3, #0]
 8006d16:	3301      	adds	r3, #1
 8006d18:	b2da      	uxtb	r2, r3
 8006d1a:	f241 63d2 	movw	r3, #5842	; 0x16d2
 8006d1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006d22:	701a      	strb	r2, [r3, #0]
 8006d24:	f241 63d2 	movw	r3, #5842	; 0x16d2
 8006d28:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006d2c:	781b      	ldrb	r3, [r3, #0]
 8006d2e:	2b27      	cmp	r3, #39	; 0x27
 8006d30:	d9df      	bls.n	8006cf2 <eventhandler+0x4a>
      }
	 
      {
        register struct uip_conn *cptr;
	    
        for(cptr = &uip_conns[0]; cptr < &uip_conns[UIP_CONNS]; ++cptr) {
 8006d32:	f641 04cc 	movw	r4, #6348	; 0x18cc
 8006d36:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8006d3a:	e008      	b.n	8006d4e <eventhandler+0xa6>
          if(cptr->appstate.p == p) {
 8006d3c:	69e2      	ldr	r2, [r4, #28]
 8006d3e:	68fb      	ldr	r3, [r7, #12]
 8006d40:	429a      	cmp	r2, r3
 8006d42:	d103      	bne.n	8006d4c <eventhandler+0xa4>
            cptr->appstate.p = PROCESS_NONE;
 8006d44:	2300      	movs	r3, #0
 8006d46:	61e3      	str	r3, [r4, #28]
            cptr->tcpstateflags = UIP_CLOSED;
 8006d48:	2300      	movs	r3, #0
 8006d4a:	7663      	strb	r3, [r4, #25]
      }
	 
      {
        register struct uip_conn *cptr;
	    
        for(cptr = &uip_conns[0]; cptr < &uip_conns[UIP_CONNS]; ++cptr) {
 8006d4c:	3424      	adds	r4, #36	; 0x24
 8006d4e:	4b5a      	ldr	r3, [pc, #360]	; (8006eb8 <eventhandler+0x210>)
 8006d50:	429c      	cmp	r4, r3
 8006d52:	d3f3      	bcc.n	8006d3c <eventhandler+0x94>
#endif /* UIP_TCP */
#if UIP_UDP
      {
        register struct uip_udp_conn *cptr;

        for(cptr = &uip_udp_conns[0];
 8006d54:	f641 64cc 	movw	r4, #7884	; 0x1ecc
 8006d58:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8006d5c:	e006      	b.n	8006d6c <eventhandler+0xc4>
            cptr < &uip_udp_conns[UIP_UDP_CONNS]; ++cptr) {
          if(cptr->appstate.p == p) {
 8006d5e:	68e2      	ldr	r2, [r4, #12]
 8006d60:	68fb      	ldr	r3, [r7, #12]
 8006d62:	429a      	cmp	r2, r3
 8006d64:	d101      	bne.n	8006d6a <eventhandler+0xc2>
            cptr->lport = 0;
 8006d66:	2300      	movs	r3, #0
 8006d68:	80a3      	strh	r3, [r4, #4]
#if UIP_UDP
      {
        register struct uip_udp_conn *cptr;

        for(cptr = &uip_udp_conns[0];
            cptr < &uip_udp_conns[UIP_UDP_CONNS]; ++cptr) {
 8006d6a:	3414      	adds	r4, #20
#endif /* UIP_TCP */
#if UIP_UDP
      {
        register struct uip_udp_conn *cptr;

        for(cptr = &uip_udp_conns[0];
 8006d6c:	4b53      	ldr	r3, [pc, #332]	; (8006ebc <eventhandler+0x214>)
 8006d6e:	429c      	cmp	r4, r3
 8006d70:	d3f5      	bcc.n	8006d5e <eventhandler+0xb6>
            cptr->lport = 0;
          }
        }
      }
#endif /* UIP_UDP */
      break;
 8006d72:	e09c      	b.n	8006eae <eventhandler+0x206>
    case PROCESS_EVENT_TIMER:
      /* We get this event if one of our timers have expired. */
      {
        /* Check the clock so see if we should call the periodic uIP
           processing. */
        if(data == &periodic &&
 8006d74:	683a      	ldr	r2, [r7, #0]
 8006d76:	f241 5378 	movw	r3, #5496	; 0x1578
 8006d7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006d7e:	429a      	cmp	r2, r3
 8006d80:	f040 8090 	bne.w	8006ea4 <eventhandler+0x1fc>
           etimer_expired(&periodic)) {
 8006d84:	f241 5078 	movw	r0, #5496	; 0x1578
 8006d88:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006d8c:	f7fd fd1e 	bl	80047cc <etimer_expired>
 8006d90:	4603      	mov	r3, r0
    case PROCESS_EVENT_TIMER:
      /* We get this event if one of our timers have expired. */
      {
        /* Check the clock so see if we should call the periodic uIP
           processing. */
        if(data == &periodic &&
 8006d92:	2b00      	cmp	r3, #0
 8006d94:	f000 8086 	beq.w	8006ea4 <eventhandler+0x1fc>
           etimer_expired(&periodic)) {
#if UIP_TCP
          for(i = 0; i < UIP_CONNS; ++i) {
 8006d98:	f241 63d2 	movw	r3, #5842	; 0x16d2
 8006d9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006da0:	2200      	movs	r2, #0
 8006da2:	701a      	strb	r2, [r3, #0]
 8006da4:	e044      	b.n	8006e30 <eventhandler+0x188>
            if(uip_conn_active(i)) {
 8006da6:	f241 63d2 	movw	r3, #5842	; 0x16d2
 8006daa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006dae:	781b      	ldrb	r3, [r3, #0]
 8006db0:	4619      	mov	r1, r3
 8006db2:	f641 02cc 	movw	r2, #6348	; 0x18cc
 8006db6:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8006dba:	460b      	mov	r3, r1
 8006dbc:	00db      	lsls	r3, r3, #3
 8006dbe:	185b      	adds	r3, r3, r1
 8006dc0:	009b      	lsls	r3, r3, #2
 8006dc2:	18d3      	adds	r3, r2, r3
 8006dc4:	3318      	adds	r3, #24
 8006dc6:	785b      	ldrb	r3, [r3, #1]
 8006dc8:	2b00      	cmp	r3, #0
 8006dca:	d025      	beq.n	8006e18 <eventhandler+0x170>
              /* Only restart the timer if there are active
                 connections. */
              etimer_restart(&periodic);
 8006dcc:	f241 5078 	movw	r0, #5496	; 0x1578
 8006dd0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006dd4:	f7fd fcea 	bl	80047ac <etimer_restart>
              uip_periodic(i);
 8006dd8:	f241 63d2 	movw	r3, #5842	; 0x16d2
 8006ddc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006de0:	781b      	ldrb	r3, [r3, #0]
 8006de2:	461a      	mov	r2, r3
 8006de4:	4613      	mov	r3, r2
 8006de6:	00db      	lsls	r3, r3, #3
 8006de8:	189b      	adds	r3, r3, r2
 8006dea:	009b      	lsls	r3, r3, #2
 8006dec:	f641 02cc 	movw	r2, #6348	; 0x18cc
 8006df0:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8006df4:	189a      	adds	r2, r3, r2
 8006df6:	f641 03c8 	movw	r3, #6344	; 0x18c8
 8006dfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006dfe:	601a      	str	r2, [r3, #0]
 8006e00:	2002      	movs	r0, #2
 8006e02:	f7fe f85b 	bl	8004ebc <uip_process>
#if UIP_CONF_IPV6
              tcpip_ipv6_output();
#else
              if(uip_len > 0) {
 8006e06:	f241 730c 	movw	r3, #5900	; 0x170c
 8006e0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006e0e:	881b      	ldrh	r3, [r3, #0]
 8006e10:	2b00      	cmp	r3, #0
 8006e12:	d001      	beq.n	8006e18 <eventhandler+0x170>
		PRINTF("tcpip_output from periodic len %d\n", uip_len);
                tcpip_output();
 8006e14:	f7ff fe8a 	bl	8006b2c <tcpip_output>
        /* Check the clock so see if we should call the periodic uIP
           processing. */
        if(data == &periodic &&
           etimer_expired(&periodic)) {
#if UIP_TCP
          for(i = 0; i < UIP_CONNS; ++i) {
 8006e18:	f241 63d2 	movw	r3, #5842	; 0x16d2
 8006e1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006e20:	781b      	ldrb	r3, [r3, #0]
 8006e22:	3301      	adds	r3, #1
 8006e24:	b2da      	uxtb	r2, r3
 8006e26:	f241 63d2 	movw	r3, #5842	; 0x16d2
 8006e2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006e2e:	701a      	strb	r2, [r3, #0]
 8006e30:	f241 63d2 	movw	r3, #5842	; 0x16d2
 8006e34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006e38:	781b      	ldrb	r3, [r3, #0]
 8006e3a:	2b27      	cmp	r3, #39	; 0x27
 8006e3c:	d9b3      	bls.n	8006da6 <eventhandler+0xfe>
          uip_ds6_periodic();
          tcpip_ipv6_output();
        }
#endif /* UIP_CONF_IPV6 */
      }
      break;
 8006e3e:	e031      	b.n	8006ea4 <eventhandler+0x1fc>
	 
#if UIP_TCP
    case TCP_POLL:
      if(data != NULL) {
 8006e40:	683b      	ldr	r3, [r7, #0]
 8006e42:	2b00      	cmp	r3, #0
 8006e44:	d030      	beq.n	8006ea8 <eventhandler+0x200>
        uip_poll_conn(data);
 8006e46:	f641 03c8 	movw	r3, #6344	; 0x18c8
 8006e4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006e4e:	683a      	ldr	r2, [r7, #0]
 8006e50:	601a      	str	r2, [r3, #0]
 8006e52:	2003      	movs	r0, #3
 8006e54:	f7fe f832 	bl	8004ebc <uip_process>
#if UIP_CONF_IPV6
        tcpip_ipv6_output();
#else /* UIP_CONF_IPV6 */
        if(uip_len > 0) {
 8006e58:	f241 730c 	movw	r3, #5900	; 0x170c
 8006e5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006e60:	881b      	ldrh	r3, [r3, #0]
 8006e62:	2b00      	cmp	r3, #0
 8006e64:	d001      	beq.n	8006e6a <eventhandler+0x1c2>
	  PRINTF("tcpip_output from tcp poll len %d\n", uip_len);
          tcpip_output();
 8006e66:	f7ff fe61 	bl	8006b2c <tcpip_output>
        }
#endif /* UIP_CONF_IPV6 */
        /* Start the periodic polling, if it isn't already active. */
        start_periodic_tcp_timer();
 8006e6a:	f7ff fe89 	bl	8006b80 <start_periodic_tcp_timer>
      }
      break;
 8006e6e:	e01b      	b.n	8006ea8 <eventhandler+0x200>
#endif /* UIP_TCP */
#if UIP_UDP
    case UDP_POLL:
      if(data != NULL) {
 8006e70:	683b      	ldr	r3, [r7, #0]
 8006e72:	2b00      	cmp	r3, #0
 8006e74:	d01a      	beq.n	8006eac <eventhandler+0x204>
        uip_udp_periodic_conn(data);
 8006e76:	f641 03c0 	movw	r3, #6336	; 0x18c0
 8006e7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006e7e:	683a      	ldr	r2, [r7, #0]
 8006e80:	601a      	str	r2, [r3, #0]
 8006e82:	2005      	movs	r0, #5
 8006e84:	f7fe f81a 	bl	8004ebc <uip_process>
#if UIP_CONF_IPV6
        tcpip_ipv6_output();
#else
        if(uip_len > 0) {
 8006e88:	f241 730c 	movw	r3, #5900	; 0x170c
 8006e8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006e90:	881b      	ldrh	r3, [r3, #0]
 8006e92:	2b00      	cmp	r3, #0
 8006e94:	d00a      	beq.n	8006eac <eventhandler+0x204>
          tcpip_output();
 8006e96:	f7ff fe49 	bl	8006b2c <tcpip_output>
        }
#endif /* UIP_UDP */
      }
      break;
 8006e9a:	e007      	b.n	8006eac <eventhandler+0x204>
#endif /* UIP_UDP */

    case PACKET_INPUT:
      packet_input();
 8006e9c:	f7ff fe98 	bl	8006bd0 <packet_input>
      break;
 8006ea0:	bf00      	nop
 8006ea2:	e004      	b.n	8006eae <eventhandler+0x206>
          uip_ds6_periodic();
          tcpip_ipv6_output();
        }
#endif /* UIP_CONF_IPV6 */
      }
      break;
 8006ea4:	bf00      	nop
 8006ea6:	e002      	b.n	8006eae <eventhandler+0x206>
        }
#endif /* UIP_CONF_IPV6 */
        /* Start the periodic polling, if it isn't already active. */
        start_periodic_tcp_timer();
      }
      break;
 8006ea8:	bf00      	nop
 8006eaa:	e000      	b.n	8006eae <eventhandler+0x206>
        if(uip_len > 0) {
          tcpip_output();
        }
#endif /* UIP_UDP */
      }
      break;
 8006eac:	bf00      	nop

    case PACKET_INPUT:
      packet_input();
      break;
  };
}
 8006eae:	f107 0714 	add.w	r7, r7, #20
 8006eb2:	46bd      	mov	sp, r7
 8006eb4:	bd90      	pop	{r4, r7, pc}
 8006eb6:	bf00      	nop
 8006eb8:	20001e6c 	.word	0x20001e6c
 8006ebc:	20001f94 	.word	0x20001f94

08006ec0 <tcpip_input>:
/*---------------------------------------------------------------------------*/
void
tcpip_input(void)
{
 8006ec0:	b580      	push	{r7, lr}
 8006ec2:	af00      	add	r7, sp, #0
  process_post_synch(&tcpip_process, PACKET_INPUT, NULL);
 8006ec4:	f640 0050 	movw	r0, #2128	; 0x850
 8006ec8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006ecc:	2102      	movs	r1, #2
 8006ece:	2200      	movs	r2, #0
 8006ed0:	f7fd f9ee 	bl	80042b0 <process_post_synch>
  uip_len = 0;
 8006ed4:	f241 730c 	movw	r3, #5900	; 0x170c
 8006ed8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006edc:	2200      	movs	r2, #0
 8006ede:	801a      	strh	r2, [r3, #0]
#if UIP_CONF_IPV6
  uip_ext_len = 0;
#endif /*UIP_CONF_IPV6*/
}
 8006ee0:	bd80      	pop	{r7, pc}
 8006ee2:	bf00      	nop

08006ee4 <tcpip_uipcall>:
}
#endif /* UIP_TCP */
/*---------------------------------------------------------------------------*/
void
tcpip_uipcall(void)
{
 8006ee4:	b5b0      	push	{r4, r5, r7, lr}
 8006ee6:	af00      	add	r7, sp, #0
  register uip_udp_appstate_t *ts;
  
#if UIP_UDP
  if(uip_conn != NULL) {
 8006ee8:	f641 03c8 	movw	r3, #6344	; 0x18c8
 8006eec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006ef0:	681b      	ldr	r3, [r3, #0]
 8006ef2:	2b00      	cmp	r3, #0
 8006ef4:	d007      	beq.n	8006f06 <tcpip_uipcall+0x22>
    ts = &uip_conn->appstate;
 8006ef6:	f641 03c8 	movw	r3, #6344	; 0x18c8
 8006efa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006efe:	681b      	ldr	r3, [r3, #0]
 8006f00:	f103 051c 	add.w	r5, r3, #28
 8006f04:	e006      	b.n	8006f14 <tcpip_uipcall+0x30>
  } else {
    ts = &uip_udp_conn->appstate;
 8006f06:	f641 03c0 	movw	r3, #6336	; 0x18c0
 8006f0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006f0e:	681b      	ldr	r3, [r3, #0]
 8006f10:	f103 050c 	add.w	r5, r3, #12
   static unsigned char i;
   register struct listenport *l;
   
   /* If this is a connection request for a listening port, we must
      mark the connection with the right process ID. */
   if(uip_connected()) {
 8006f14:	f641 03bc 	movw	r3, #6332	; 0x18bc
 8006f18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006f1c:	781b      	ldrb	r3, [r3, #0]
 8006f1e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006f22:	2b00      	cmp	r3, #0
 8006f24:	d031      	beq.n	8006f8a <tcpip_uipcall+0xa6>
     l = &s.listenports[0];
 8006f26:	f241 5488 	movw	r4, #5512	; 0x1588
 8006f2a:	f2c2 0400 	movt	r4, #8192	; 0x2000
     for(i = 0; i < UIP_LISTENPORTS; ++i) {
 8006f2e:	f241 63d1 	movw	r3, #5841	; 0x16d1
 8006f32:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006f36:	2200      	movs	r2, #0
 8006f38:	701a      	strb	r2, [r3, #0]
 8006f3a:	e01d      	b.n	8006f78 <tcpip_uipcall+0x94>
       if(l->port == uip_conn->lport &&
 8006f3c:	8822      	ldrh	r2, [r4, #0]
 8006f3e:	f641 03c8 	movw	r3, #6344	; 0x18c8
 8006f42:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006f46:	681b      	ldr	r3, [r3, #0]
 8006f48:	889b      	ldrh	r3, [r3, #4]
 8006f4a:	429a      	cmp	r2, r3
 8006f4c:	d107      	bne.n	8006f5e <tcpip_uipcall+0x7a>
	  l->p != PROCESS_NONE) {
 8006f4e:	6863      	ldr	r3, [r4, #4]
   /* If this is a connection request for a listening port, we must
      mark the connection with the right process ID. */
   if(uip_connected()) {
     l = &s.listenports[0];
     for(i = 0; i < UIP_LISTENPORTS; ++i) {
       if(l->port == uip_conn->lport &&
 8006f50:	2b00      	cmp	r3, #0
 8006f52:	d004      	beq.n	8006f5e <tcpip_uipcall+0x7a>
	  l->p != PROCESS_NONE) {
	 ts->p = l->p;
 8006f54:	6863      	ldr	r3, [r4, #4]
 8006f56:	602b      	str	r3, [r5, #0]
	 ts->state = NULL;
 8006f58:	2300      	movs	r3, #0
 8006f5a:	606b      	str	r3, [r5, #4]
	 break;
 8006f5c:	e013      	b.n	8006f86 <tcpip_uipcall+0xa2>
       }
       ++l;
 8006f5e:	3408      	adds	r4, #8
   
   /* If this is a connection request for a listening port, we must
      mark the connection with the right process ID. */
   if(uip_connected()) {
     l = &s.listenports[0];
     for(i = 0; i < UIP_LISTENPORTS; ++i) {
 8006f60:	f241 63d1 	movw	r3, #5841	; 0x16d1
 8006f64:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006f68:	781b      	ldrb	r3, [r3, #0]
 8006f6a:	3301      	adds	r3, #1
 8006f6c:	b2da      	uxtb	r2, r3
 8006f6e:	f241 63d1 	movw	r3, #5841	; 0x16d1
 8006f72:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006f76:	701a      	strb	r2, [r3, #0]
 8006f78:	f241 63d1 	movw	r3, #5841	; 0x16d1
 8006f7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006f80:	781b      	ldrb	r3, [r3, #0]
 8006f82:	2b27      	cmp	r3, #39	; 0x27
 8006f84:	d9da      	bls.n	8006f3c <tcpip_uipcall+0x58>
       }
       ++l;
     }
     
     /* Start the periodic polling, if it isn't already active. */
     start_periodic_tcp_timer();
 8006f86:	f7ff fdfb 	bl	8006b80 <start_periodic_tcp_timer>
   }
 }
#endif /* UIP_TCP */
  
  if(ts->p != NULL) {
 8006f8a:	682b      	ldr	r3, [r5, #0]
 8006f8c:	2b00      	cmp	r3, #0
 8006f8e:	d00b      	beq.n	8006fa8 <tcpip_uipcall+0xc4>
    process_post_synch(ts->p, tcpip_event, ts->state);
 8006f90:	6829      	ldr	r1, [r5, #0]
 8006f92:	f641 7394 	movw	r3, #8084	; 0x1f94
 8006f96:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006f9a:	781a      	ldrb	r2, [r3, #0]
 8006f9c:	686b      	ldr	r3, [r5, #4]
 8006f9e:	4608      	mov	r0, r1
 8006fa0:	4611      	mov	r1, r2
 8006fa2:	461a      	mov	r2, r3
 8006fa4:	f7fd f984 	bl	80042b0 <process_post_synch>
  }
}
 8006fa8:	bdb0      	pop	{r4, r5, r7, pc}
 8006faa:	bf00      	nop

08006fac <process_thread_tcpip_process>:
/*---------------------------------------------------------------------------*/
PROCESS_THREAD(tcpip_process, ev, data)
{
 8006fac:	b580      	push	{r7, lr}
 8006fae:	b086      	sub	sp, #24
 8006fb0:	af00      	add	r7, sp, #0
 8006fb2:	60f8      	str	r0, [r7, #12]
 8006fb4:	460b      	mov	r3, r1
 8006fb6:	607a      	str	r2, [r7, #4]
 8006fb8:	72fb      	strb	r3, [r7, #11]
  PROCESS_BEGIN();
 8006fba:	2301      	movs	r3, #1
 8006fbc:	75fb      	strb	r3, [r7, #23]
 8006fbe:	68fb      	ldr	r3, [r7, #12]
 8006fc0:	881b      	ldrh	r3, [r3, #0]
 8006fc2:	2b00      	cmp	r3, #0
 8006fc4:	d003      	beq.n	8006fce <process_thread_tcpip_process+0x22>
 8006fc6:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8006fca:	d04b      	beq.n	8007064 <process_thread_tcpip_process+0xb8>
 8006fcc:	e055      	b.n	800707a <process_thread_tcpip_process+0xce>
  
#if UIP_TCP
 {
   static unsigned char i;
   
   for(i = 0; i < UIP_LISTENPORTS; ++i) {
 8006fce:	f241 63d0 	movw	r3, #5840	; 0x16d0
 8006fd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006fd6:	2200      	movs	r2, #0
 8006fd8:	701a      	strb	r2, [r3, #0]
 8006fda:	e018      	b.n	800700e <process_thread_tcpip_process+0x62>
     s.listenports[i].port = 0;
 8006fdc:	f241 63d0 	movw	r3, #5840	; 0x16d0
 8006fe0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006fe4:	781b      	ldrb	r3, [r3, #0]
 8006fe6:	461a      	mov	r2, r3
 8006fe8:	f241 5388 	movw	r3, #5512	; 0x1588
 8006fec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006ff0:	2100      	movs	r1, #0
 8006ff2:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
  
#if UIP_TCP
 {
   static unsigned char i;
   
   for(i = 0; i < UIP_LISTENPORTS; ++i) {
 8006ff6:	f241 63d0 	movw	r3, #5840	; 0x16d0
 8006ffa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006ffe:	781b      	ldrb	r3, [r3, #0]
 8007000:	3301      	adds	r3, #1
 8007002:	b2da      	uxtb	r2, r3
 8007004:	f241 63d0 	movw	r3, #5840	; 0x16d0
 8007008:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800700c:	701a      	strb	r2, [r3, #0]
 800700e:	f241 63d0 	movw	r3, #5840	; 0x16d0
 8007012:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007016:	781b      	ldrb	r3, [r3, #0]
 8007018:	2b27      	cmp	r3, #39	; 0x27
 800701a:	d9df      	bls.n	8006fdc <process_thread_tcpip_process+0x30>
     s.listenports[i].port = 0;
   }
   s.p = PROCESS_CURRENT();
 800701c:	f241 33c4 	movw	r3, #5060	; 0x13c4
 8007020:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007024:	681a      	ldr	r2, [r3, #0]
 8007026:	f241 5388 	movw	r3, #5512	; 0x1588
 800702a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800702e:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
 }
#endif

  tcpip_event = process_alloc_event();
 8007032:	f7fc fe79 	bl	8003d28 <process_alloc_event>
 8007036:	4603      	mov	r3, r0
 8007038:	461a      	mov	r2, r3
 800703a:	f641 7394 	movw	r3, #8084	; 0x1f94
 800703e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007042:	701a      	strb	r2, [r3, #0]
#if UIP_CONF_ICMP6
  tcpip_icmp6_event = process_alloc_event();
#endif /* UIP_CONF_ICMP6 */
  etimer_set(&periodic, CLOCK_SECOND / 2);
 8007044:	f241 5078 	movw	r0, #5496	; 0x1578
 8007048:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800704c:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8007050:	f7fd fb8a 	bl	8004768 <etimer_set>

  uip_init();
 8007054:	f7fd fde4 	bl	8004c20 <uip_init>
#if UIP_CONF_IPV6_RPL
  rpl_init();
#endif /* UIP_CONF_IPV6_RPL */

  while(1) {
    PROCESS_YIELD();
 8007058:	2300      	movs	r3, #0
 800705a:	75fb      	strb	r3, [r7, #23]
 800705c:	68fb      	ldr	r3, [r7, #12]
 800705e:	f44f 7240 	mov.w	r2, #768	; 0x300
 8007062:	801a      	strh	r2, [r3, #0]
 8007064:	7dfb      	ldrb	r3, [r7, #23]
 8007066:	2b00      	cmp	r3, #0
 8007068:	d101      	bne.n	800706e <process_thread_tcpip_process+0xc2>
 800706a:	2301      	movs	r3, #1
 800706c:	e00b      	b.n	8007086 <process_thread_tcpip_process+0xda>
    eventhandler(ev, data);
 800706e:	7afb      	ldrb	r3, [r7, #11]
 8007070:	4618      	mov	r0, r3
 8007072:	6879      	ldr	r1, [r7, #4]
 8007074:	f7ff fe18 	bl	8006ca8 <eventhandler>
  }
 8007078:	e7ee      	b.n	8007058 <process_thread_tcpip_process+0xac>
  
  PROCESS_END();
 800707a:	2300      	movs	r3, #0
 800707c:	75fb      	strb	r3, [r7, #23]
 800707e:	68fb      	ldr	r3, [r7, #12]
 8007080:	2200      	movs	r2, #0
 8007082:	801a      	strh	r2, [r3, #0]
 8007084:	2303      	movs	r3, #3
}
 8007086:	4618      	mov	r0, r3
 8007088:	f107 0718 	add.w	r7, r7, #24
 800708c:	46bd      	mov	sp, r7
 800708e:	bd80      	pop	{r7, pc}

08007090 <uip_split_output>:
#define BUF ((struct uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN])

/*-----------------------------------------------------------------------------*/
void
uip_split_output(void)
{
 8007090:	b590      	push	{r4, r7, lr}
 8007092:	b083      	sub	sp, #12
 8007094:	af00      	add	r7, sp, #0
#if UIP_TCP
  uint16_t tcplen, len1, len2;

  /* We only try to split maximum sized TCP segments. */
  if(BUF->proto == UIP_PROTO_TCP &&
 8007096:	f241 7318 	movw	r3, #5912	; 0x1718
 800709a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800709e:	7a5b      	ldrb	r3, [r3, #9]
 80070a0:	2b06      	cmp	r3, #6
 80070a2:	f040 80e2 	bne.w	800726a <uip_split_output+0x1da>
     uip_len == UIP_TCP_MSS + UIP_TCPIP_HLEN) {
 80070a6:	f241 730c 	movw	r3, #5900	; 0x170c
 80070aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80070ae:	881b      	ldrh	r3, [r3, #0]
{
#if UIP_TCP
  uint16_t tcplen, len1, len2;

  /* We only try to split maximum sized TCP segments. */
  if(BUF->proto == UIP_PROTO_TCP &&
 80070b0:	f5b3 7fd2 	cmp.w	r3, #420	; 0x1a4
 80070b4:	f040 80d9 	bne.w	800726a <uip_split_output+0x1da>
     uip_len == UIP_TCP_MSS + UIP_TCPIP_HLEN) {

    tcplen = uip_len - UIP_TCPIP_HLEN;
 80070b8:	f241 730c 	movw	r3, #5900	; 0x170c
 80070bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80070c0:	881b      	ldrh	r3, [r3, #0]
 80070c2:	3b28      	subs	r3, #40	; 0x28
 80070c4:	80bb      	strh	r3, [r7, #4]
    /* Split the segment in two. If the original packet length was
       odd, we make the second packet one byte larger. */
    len1 = len2 = tcplen / 2;
 80070c6:	88bb      	ldrh	r3, [r7, #4]
 80070c8:	085b      	lsrs	r3, r3, #1
 80070ca:	80fb      	strh	r3, [r7, #6]
 80070cc:	88fb      	ldrh	r3, [r7, #6]
 80070ce:	807b      	strh	r3, [r7, #2]
    if(len1 + len2 < tcplen) {
 80070d0:	887a      	ldrh	r2, [r7, #2]
 80070d2:	88fb      	ldrh	r3, [r7, #6]
 80070d4:	18d2      	adds	r2, r2, r3
 80070d6:	88bb      	ldrh	r3, [r7, #4]
 80070d8:	429a      	cmp	r2, r3
 80070da:	da02      	bge.n	80070e2 <uip_split_output+0x52>
      ++len2;
 80070dc:	88fb      	ldrh	r3, [r7, #6]
 80070de:	3301      	adds	r3, #1
 80070e0:	80fb      	strh	r3, [r7, #6]
    }

    /* Create the first packet. This is done by altering the length
       field of the IP header and updating the checksums. */
    uip_len = len1 + UIP_TCPIP_HLEN;
 80070e2:	887b      	ldrh	r3, [r7, #2]
 80070e4:	3328      	adds	r3, #40	; 0x28
 80070e6:	b29a      	uxth	r2, r3
 80070e8:	f241 730c 	movw	r3, #5900	; 0x170c
 80070ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80070f0:	801a      	strh	r2, [r3, #0]
    /* For IPv6, the IP length field does not include the IPv6 IP header
       length. */
    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
    BUF->len[0] = uip_len >> 8;
 80070f2:	f241 7318 	movw	r3, #5912	; 0x1718
 80070f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80070fa:	f241 720c 	movw	r2, #5900	; 0x170c
 80070fe:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8007102:	8812      	ldrh	r2, [r2, #0]
 8007104:	0a12      	lsrs	r2, r2, #8
 8007106:	b292      	uxth	r2, r2
 8007108:	b2d2      	uxtb	r2, r2
 800710a:	709a      	strb	r2, [r3, #2]
    BUF->len[1] = uip_len & 0xff;
 800710c:	f241 7318 	movw	r3, #5912	; 0x1718
 8007110:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007114:	f241 720c 	movw	r2, #5900	; 0x170c
 8007118:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800711c:	8812      	ldrh	r2, [r2, #0]
 800711e:	b2d2      	uxtb	r2, r2
 8007120:	70da      	strb	r2, [r3, #3]
#endif /* UIP_CONF_IPV6 */
    
    /* Recalculate the TCP checksum. */
    BUF->tcpchksum = 0;
 8007122:	f241 7318 	movw	r3, #5912	; 0x1718
 8007126:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800712a:	2200      	movs	r2, #0
 800712c:	849a      	strh	r2, [r3, #36]	; 0x24
    BUF->tcpchksum = ~(uip_tcpchksum());
 800712e:	f241 7418 	movw	r4, #5912	; 0x1718
 8007132:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8007136:	f7fd fd63 	bl	8004c00 <uip_tcpchksum>
 800713a:	4603      	mov	r3, r0
 800713c:	43db      	mvns	r3, r3
 800713e:	b29b      	uxth	r3, r3
 8007140:	84a3      	strh	r3, [r4, #36]	; 0x24

#if !UIP_CONF_IPV6
    /* Recalculate the IP checksum. */
    BUF->ipchksum = 0;
 8007142:	f241 7318 	movw	r3, #5912	; 0x1718
 8007146:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800714a:	2200      	movs	r2, #0
 800714c:	815a      	strh	r2, [r3, #10]
    BUF->ipchksum = ~(uip_ipchksum());
 800714e:	f241 7418 	movw	r4, #5912	; 0x1718
 8007152:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8007156:	f7fd fcf5 	bl	8004b44 <uip_ipchksum>
 800715a:	4603      	mov	r3, r0
 800715c:	43db      	mvns	r3, r3
 800715e:	b29b      	uxth	r3, r3
 8007160:	8163      	strh	r3, [r4, #10]
    /* Transmit the first packet. */
    /*    uip_fw_output();*/
#if UIP_CONF_IPV6
    tcpip_ipv6_output();
#else
    tcpip_output();
 8007162:	f7ff fce3 	bl	8006b2c <tcpip_output>
    /* Now, create the second packet. To do this, it is not enough to
       just alter the length field, but we must also update the TCP
       sequence number and point the uip_appdata to a new place in
       memory. This place is detemined by the length of the first
       packet (len1). */
    uip_len = len2 + UIP_TCPIP_HLEN;
 8007166:	88fb      	ldrh	r3, [r7, #6]
 8007168:	3328      	adds	r3, #40	; 0x28
 800716a:	b29a      	uxth	r2, r3
 800716c:	f241 730c 	movw	r3, #5900	; 0x170c
 8007170:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007174:	801a      	strh	r2, [r3, #0]
    /* For IPv6, the IP length field does not include the IPv6 IP header
       length. */
    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
    BUF->len[0] = uip_len >> 8;
 8007176:	f241 7318 	movw	r3, #5912	; 0x1718
 800717a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800717e:	f241 720c 	movw	r2, #5900	; 0x170c
 8007182:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8007186:	8812      	ldrh	r2, [r2, #0]
 8007188:	0a12      	lsrs	r2, r2, #8
 800718a:	b292      	uxth	r2, r2
 800718c:	b2d2      	uxtb	r2, r2
 800718e:	709a      	strb	r2, [r3, #2]
    BUF->len[1] = uip_len & 0xff;
 8007190:	f241 7318 	movw	r3, #5912	; 0x1718
 8007194:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007198:	f241 720c 	movw	r2, #5900	; 0x170c
 800719c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80071a0:	8812      	ldrh	r2, [r2, #0]
 80071a2:	b2d2      	uxtb	r2, r2
 80071a4:	70da      	strb	r2, [r3, #3]
#endif /* UIP_CONF_IPV6 */
    
    /*    uip_appdata += len1;*/
    memcpy(uip_appdata, (uint8_t *)uip_appdata + len1, len2);
 80071a6:	f641 03c4 	movw	r3, #6340	; 0x18c4
 80071aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80071ae:	6819      	ldr	r1, [r3, #0]
 80071b0:	f641 03c4 	movw	r3, #6340	; 0x18c4
 80071b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80071b8:	681a      	ldr	r2, [r3, #0]
 80071ba:	887b      	ldrh	r3, [r7, #2]
 80071bc:	18d2      	adds	r2, r2, r3
 80071be:	88fb      	ldrh	r3, [r7, #6]
 80071c0:	4608      	mov	r0, r1
 80071c2:	4611      	mov	r1, r2
 80071c4:	461a      	mov	r2, r3
 80071c6:	f7f9 f878 	bl	80002ba <memcpy>

    uip_add32(BUF->seqno, len1);
 80071ca:	887b      	ldrh	r3, [r7, #2]
 80071cc:	482a      	ldr	r0, [pc, #168]	; (8007278 <uip_split_output+0x1e8>)
 80071ce:	4619      	mov	r1, r3
 80071d0:	f7fd fbc2 	bl	8004958 <uip_add32>
    BUF->seqno[0] = uip_acc32[0];
 80071d4:	f241 7318 	movw	r3, #5912	; 0x1718
 80071d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80071dc:	f241 7214 	movw	r2, #5908	; 0x1714
 80071e0:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80071e4:	7812      	ldrb	r2, [r2, #0]
 80071e6:	761a      	strb	r2, [r3, #24]
    BUF->seqno[1] = uip_acc32[1];
 80071e8:	f241 7318 	movw	r3, #5912	; 0x1718
 80071ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80071f0:	f241 7214 	movw	r2, #5908	; 0x1714
 80071f4:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80071f8:	7852      	ldrb	r2, [r2, #1]
 80071fa:	765a      	strb	r2, [r3, #25]
    BUF->seqno[2] = uip_acc32[2];
 80071fc:	f241 7318 	movw	r3, #5912	; 0x1718
 8007200:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007204:	f241 7214 	movw	r2, #5908	; 0x1714
 8007208:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800720c:	7892      	ldrb	r2, [r2, #2]
 800720e:	769a      	strb	r2, [r3, #26]
    BUF->seqno[3] = uip_acc32[3];
 8007210:	f241 7318 	movw	r3, #5912	; 0x1718
 8007214:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007218:	f241 7214 	movw	r2, #5908	; 0x1714
 800721c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8007220:	78d2      	ldrb	r2, [r2, #3]
 8007222:	76da      	strb	r2, [r3, #27]
    
    /* Recalculate the TCP checksum. */
    BUF->tcpchksum = 0;
 8007224:	f241 7318 	movw	r3, #5912	; 0x1718
 8007228:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800722c:	2200      	movs	r2, #0
 800722e:	849a      	strh	r2, [r3, #36]	; 0x24
    BUF->tcpchksum = ~(uip_tcpchksum());
 8007230:	f241 7418 	movw	r4, #5912	; 0x1718
 8007234:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8007238:	f7fd fce2 	bl	8004c00 <uip_tcpchksum>
 800723c:	4603      	mov	r3, r0
 800723e:	43db      	mvns	r3, r3
 8007240:	b29b      	uxth	r3, r3
 8007242:	84a3      	strh	r3, [r4, #36]	; 0x24

#if !UIP_CONF_IPV6
    /* Recalculate the IP checksum. */
    BUF->ipchksum = 0;
 8007244:	f241 7318 	movw	r3, #5912	; 0x1718
 8007248:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800724c:	2200      	movs	r2, #0
 800724e:	815a      	strh	r2, [r3, #10]
    BUF->ipchksum = ~(uip_ipchksum());
 8007250:	f241 7418 	movw	r4, #5912	; 0x1718
 8007254:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8007258:	f7fd fc74 	bl	8004b44 <uip_ipchksum>
 800725c:	4603      	mov	r3, r0
 800725e:	43db      	mvns	r3, r3
 8007260:	b29b      	uxth	r3, r3
 8007262:	8163      	strh	r3, [r4, #10]
    /* Transmit the second packet. */
    /*    uip_fw_output();*/
#if UIP_CONF_IPV6
    tcpip_ipv6_output();
#else
    tcpip_output();
 8007264:	f7ff fc62 	bl	8006b2c <tcpip_output>
#endif /* UIP_CONF_IPV6 */
    return;
 8007268:	e001      	b.n	800726e <uip_split_output+0x1de>

  /*    uip_fw_output();*/
#if UIP_CONF_IPV6
     tcpip_ipv6_output();
#else
     tcpip_output();
 800726a:	f7ff fc5f 	bl	8006b2c <tcpip_output>
#endif /* UIP_CONF_IPV6 */
}
 800726e:	f107 070c 	add.w	r7, r7, #12
 8007272:	46bd      	mov	sp, r7
 8007274:	bd90      	pop	{r4, r7, pc}
 8007276:	bf00      	nop
 8007278:	20001730 	.word	0x20001730

0800727c <uip_fw_init>:
 * Initialize the uIP packet forwarding module.
 */
/*------------------------------------------------------------------------------*/
void
uip_fw_init(void)
{
 800727c:	b480      	push	{r7}
 800727e:	b083      	sub	sp, #12
 8007280:	af00      	add	r7, sp, #0
  struct uip_fw_netif *t;
  defaultnetif = NULL;
 8007282:	f241 63d8 	movw	r3, #5848	; 0x16d8
 8007286:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800728a:	2200      	movs	r2, #0
 800728c:	601a      	str	r2, [r3, #0]
  while(netifs != NULL) {
 800728e:	e013      	b.n	80072b8 <uip_fw_init+0x3c>
    t = netifs;
 8007290:	f241 63d4 	movw	r3, #5844	; 0x16d4
 8007294:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007298:	681b      	ldr	r3, [r3, #0]
 800729a:	607b      	str	r3, [r7, #4]
    netifs = netifs->next;
 800729c:	f241 63d4 	movw	r3, #5844	; 0x16d4
 80072a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80072a4:	681b      	ldr	r3, [r3, #0]
 80072a6:	681a      	ldr	r2, [r3, #0]
 80072a8:	f241 63d4 	movw	r3, #5844	; 0x16d4
 80072ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80072b0:	601a      	str	r2, [r3, #0]
    t->next = NULL;
 80072b2:	687b      	ldr	r3, [r7, #4]
 80072b4:	2200      	movs	r2, #0
 80072b6:	601a      	str	r2, [r3, #0]
void
uip_fw_init(void)
{
  struct uip_fw_netif *t;
  defaultnetif = NULL;
  while(netifs != NULL) {
 80072b8:	f241 63d4 	movw	r3, #5844	; 0x16d4
 80072bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80072c0:	681b      	ldr	r3, [r3, #0]
 80072c2:	2b00      	cmp	r3, #0
 80072c4:	d1e4      	bne.n	8007290 <uip_fw_init+0x14>
    t = netifs;
    netifs = netifs->next;
    t->next = NULL;
  }
}
 80072c6:	f107 070c 	add.w	r7, r7, #12
 80072ca:	46bd      	mov	sp, r7
 80072cc:	bc80      	pop	{r7}
 80072ce:	4770      	bx	lr

080072d0 <ipaddr_maskcmp>:
/*------------------------------------------------------------------------------*/
static unsigned char
ipaddr_maskcmp(uip_ipaddr_t *ipaddr,
	       uip_ipaddr_t *netipaddr,
	       uip_ipaddr_t *netmask)
{
 80072d0:	b480      	push	{r7}
 80072d2:	b085      	sub	sp, #20
 80072d4:	af00      	add	r7, sp, #0
 80072d6:	60f8      	str	r0, [r7, #12]
 80072d8:	60b9      	str	r1, [r7, #8]
 80072da:	607a      	str	r2, [r7, #4]
  return (ipaddr->u16[0] & netmask->u16[0]) == (netipaddr->u16[0] & netmask->u16[0]) &&
 80072dc:	68fb      	ldr	r3, [r7, #12]
 80072de:	881a      	ldrh	r2, [r3, #0]
 80072e0:	68bb      	ldr	r3, [r7, #8]
 80072e2:	881b      	ldrh	r3, [r3, #0]
 80072e4:	4053      	eors	r3, r2
 80072e6:	b29a      	uxth	r2, r3
 80072e8:	687b      	ldr	r3, [r7, #4]
 80072ea:	881b      	ldrh	r3, [r3, #0]
 80072ec:	4013      	ands	r3, r2
 80072ee:	b29b      	uxth	r3, r3
 80072f0:	2b00      	cmp	r3, #0
 80072f2:	d10d      	bne.n	8007310 <ipaddr_maskcmp+0x40>
    (ipaddr->u16[1] & netmask->u16[1]) == (netipaddr->u16[1] & netmask->u16[1]);
 80072f4:	68fb      	ldr	r3, [r7, #12]
 80072f6:	885a      	ldrh	r2, [r3, #2]
 80072f8:	68bb      	ldr	r3, [r7, #8]
 80072fa:	885b      	ldrh	r3, [r3, #2]
 80072fc:	4053      	eors	r3, r2
 80072fe:	b29a      	uxth	r2, r3
 8007300:	687b      	ldr	r3, [r7, #4]
 8007302:	885b      	ldrh	r3, [r3, #2]
 8007304:	4013      	ands	r3, r2
 8007306:	b29b      	uxth	r3, r3
static unsigned char
ipaddr_maskcmp(uip_ipaddr_t *ipaddr,
	       uip_ipaddr_t *netipaddr,
	       uip_ipaddr_t *netmask)
{
  return (ipaddr->u16[0] & netmask->u16[0]) == (netipaddr->u16[0] & netmask->u16[0]) &&
 8007308:	2b00      	cmp	r3, #0
 800730a:	d101      	bne.n	8007310 <ipaddr_maskcmp+0x40>
 800730c:	2301      	movs	r3, #1
 800730e:	e000      	b.n	8007312 <ipaddr_maskcmp+0x42>
 8007310:	2300      	movs	r3, #0
 8007312:	b2db      	uxtb	r3, r3
    (ipaddr->u16[1] & netmask->u16[1]) == (netipaddr->u16[1] & netmask->u16[1]);
}
 8007314:	4618      	mov	r0, r3
 8007316:	f107 0714 	add.w	r7, r7, #20
 800731a:	46bd      	mov	sp, r7
 800731c:	bc80      	pop	{r7}
 800731e:	4770      	bx	lr

08007320 <fwcache_register>:
 * forwarded again.
 */
/*------------------------------------------------------------------------------*/
static void
fwcache_register(void)
{
 8007320:	b480      	push	{r7}
 8007322:	b085      	sub	sp, #20
 8007324:	af00      	add	r7, sp, #0
  struct fwcache_entry *fw;
  int i, oldest;

  oldest = FW_TIME;
 8007326:	2314      	movs	r3, #20
 8007328:	607b      	str	r3, [r7, #4]
  fw = NULL;
 800732a:	2300      	movs	r3, #0
 800732c:	60fb      	str	r3, [r7, #12]
  
  /* Find the oldest entry in the cache. */
  for(i = 0; i < FWCACHE_SIZE; ++i) {
 800732e:	2300      	movs	r3, #0
 8007330:	60bb      	str	r3, [r7, #8]
 8007332:	e041      	b.n	80073b8 <fwcache_register+0x98>
    if(fwcache[i].timer == 0) {
 8007334:	f241 62dc 	movw	r2, #5852	; 0x16dc
 8007338:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800733c:	68b9      	ldr	r1, [r7, #8]
 800733e:	460b      	mov	r3, r1
 8007340:	00db      	lsls	r3, r3, #3
 8007342:	1a5b      	subs	r3, r3, r1
 8007344:	005b      	lsls	r3, r3, #1
 8007346:	18d3      	adds	r3, r2, r3
 8007348:	881b      	ldrh	r3, [r3, #0]
 800734a:	2b00      	cmp	r3, #0
 800734c:	d10b      	bne.n	8007366 <fwcache_register+0x46>
      fw = &fwcache[i];
 800734e:	68ba      	ldr	r2, [r7, #8]
 8007350:	4613      	mov	r3, r2
 8007352:	00db      	lsls	r3, r3, #3
 8007354:	1a9b      	subs	r3, r3, r2
 8007356:	005b      	lsls	r3, r3, #1
 8007358:	f241 62dc 	movw	r2, #5852	; 0x16dc
 800735c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8007360:	189b      	adds	r3, r3, r2
 8007362:	60fb      	str	r3, [r7, #12]
      break;
 8007364:	e02b      	b.n	80073be <fwcache_register+0x9e>
    } else if(fwcache[i].timer <= oldest) {
 8007366:	f241 62dc 	movw	r2, #5852	; 0x16dc
 800736a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800736e:	68b9      	ldr	r1, [r7, #8]
 8007370:	460b      	mov	r3, r1
 8007372:	00db      	lsls	r3, r3, #3
 8007374:	1a5b      	subs	r3, r3, r1
 8007376:	005b      	lsls	r3, r3, #1
 8007378:	18d3      	adds	r3, r2, r3
 800737a:	881b      	ldrh	r3, [r3, #0]
 800737c:	461a      	mov	r2, r3
 800737e:	687b      	ldr	r3, [r7, #4]
 8007380:	429a      	cmp	r2, r3
 8007382:	dc16      	bgt.n	80073b2 <fwcache_register+0x92>
      fw = &fwcache[i];
 8007384:	68ba      	ldr	r2, [r7, #8]
 8007386:	4613      	mov	r3, r2
 8007388:	00db      	lsls	r3, r3, #3
 800738a:	1a9b      	subs	r3, r3, r2
 800738c:	005b      	lsls	r3, r3, #1
 800738e:	f241 62dc 	movw	r2, #5852	; 0x16dc
 8007392:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8007396:	189b      	adds	r3, r3, r2
 8007398:	60fb      	str	r3, [r7, #12]
      oldest = fwcache[i].timer;
 800739a:	f241 62dc 	movw	r2, #5852	; 0x16dc
 800739e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80073a2:	68b9      	ldr	r1, [r7, #8]
 80073a4:	460b      	mov	r3, r1
 80073a6:	00db      	lsls	r3, r3, #3
 80073a8:	1a5b      	subs	r3, r3, r1
 80073aa:	005b      	lsls	r3, r3, #1
 80073ac:	18d3      	adds	r3, r2, r3
 80073ae:	881b      	ldrh	r3, [r3, #0]
 80073b0:	607b      	str	r3, [r7, #4]

  oldest = FW_TIME;
  fw = NULL;
  
  /* Find the oldest entry in the cache. */
  for(i = 0; i < FWCACHE_SIZE; ++i) {
 80073b2:	68bb      	ldr	r3, [r7, #8]
 80073b4:	3301      	adds	r3, #1
 80073b6:	60bb      	str	r3, [r7, #8]
 80073b8:	68bb      	ldr	r3, [r7, #8]
 80073ba:	2b01      	cmp	r3, #1
 80073bc:	ddba      	ble.n	8007334 <fwcache_register+0x14>
      fw = &fwcache[i];
      oldest = fwcache[i].timer;
    }
  }

  fw->timer = FW_TIME;
 80073be:	68fb      	ldr	r3, [r7, #12]
 80073c0:	2214      	movs	r2, #20
 80073c2:	801a      	strh	r2, [r3, #0]
  fw->ipid = BUF->ipid;
 80073c4:	f241 7318 	movw	r3, #5912	; 0x1718
 80073c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80073cc:	889a      	ldrh	r2, [r3, #4]
 80073ce:	68fb      	ldr	r3, [r7, #12]
 80073d0:	815a      	strh	r2, [r3, #10]
  uip_ipaddr_copy(&fw->srcipaddr, &BUF->srcipaddr);
 80073d2:	4a0b      	ldr	r2, [pc, #44]	; (8007400 <fwcache_register+0xe0>)
 80073d4:	68fb      	ldr	r3, [r7, #12]
 80073d6:	3302      	adds	r3, #2
 80073d8:	6812      	ldr	r2, [r2, #0]
 80073da:	601a      	str	r2, [r3, #0]
  uip_ipaddr_copy(&fw->destipaddr, &BUF->destipaddr);
 80073dc:	4a09      	ldr	r2, [pc, #36]	; (8007404 <fwcache_register+0xe4>)
 80073de:	68fb      	ldr	r3, [r7, #12]
 80073e0:	3306      	adds	r3, #6
 80073e2:	6812      	ldr	r2, [r2, #0]
 80073e4:	601a      	str	r2, [r3, #0]
  fw->proto = BUF->proto;
 80073e6:	f241 7318 	movw	r3, #5912	; 0x1718
 80073ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80073ee:	7a5a      	ldrb	r2, [r3, #9]
 80073f0:	68fb      	ldr	r3, [r7, #12]
 80073f2:	731a      	strb	r2, [r3, #12]
#endif
#if UIP_REASSEMBLY > 0
  fw->len = BUF->len;
  fw->offset = BUF->ipoffset;
#endif
}
 80073f4:	f107 0714 	add.w	r7, r7, #20
 80073f8:	46bd      	mov	sp, r7
 80073fa:	bc80      	pop	{r7}
 80073fc:	4770      	bx	lr
 80073fe:	bf00      	nop
 8007400:	20001724 	.word	0x20001724
 8007404:	20001728 	.word	0x20001728

08007408 <find_netif>:
 * Find a network interface for the IP packet in uip_buf.
 */
/*------------------------------------------------------------------------------*/
static struct uip_fw_netif *
find_netif(void)
{
 8007408:	b580      	push	{r7, lr}
 800740a:	b082      	sub	sp, #8
 800740c:	af00      	add	r7, sp, #0
  struct uip_fw_netif *netif;
  
  /* Walk through every network interface to check for a match. */
  for(netif = netifs; netif != NULL; netif = netif->next) {
 800740e:	f241 63d4 	movw	r3, #5844	; 0x16d4
 8007412:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007416:	681b      	ldr	r3, [r3, #0]
 8007418:	607b      	str	r3, [r7, #4]
 800741a:	e010      	b.n	800743e <find_netif+0x36>
    if(ipaddr_maskcmp(&BUF->destipaddr, &netif->ipaddr,
 800741c:	687b      	ldr	r3, [r7, #4]
 800741e:	1d1a      	adds	r2, r3, #4
 8007420:	687b      	ldr	r3, [r7, #4]
 8007422:	3308      	adds	r3, #8
 8007424:	480c      	ldr	r0, [pc, #48]	; (8007458 <find_netif+0x50>)
 8007426:	4611      	mov	r1, r2
 8007428:	461a      	mov	r2, r3
 800742a:	f7ff ff51 	bl	80072d0 <ipaddr_maskcmp>
 800742e:	4603      	mov	r3, r0
 8007430:	2b00      	cmp	r3, #0
 8007432:	d001      	beq.n	8007438 <find_netif+0x30>
		      &netif->netmask)) {
      /* If there was a match, we break the loop. */
      return netif;
 8007434:	687b      	ldr	r3, [r7, #4]
 8007436:	e00a      	b.n	800744e <find_netif+0x46>
find_netif(void)
{
  struct uip_fw_netif *netif;
  
  /* Walk through every network interface to check for a match. */
  for(netif = netifs; netif != NULL; netif = netif->next) {
 8007438:	687b      	ldr	r3, [r7, #4]
 800743a:	681b      	ldr	r3, [r3, #0]
 800743c:	607b      	str	r3, [r7, #4]
 800743e:	687b      	ldr	r3, [r7, #4]
 8007440:	2b00      	cmp	r3, #0
 8007442:	d1eb      	bne.n	800741c <find_netif+0x14>
      return netif;
    }
  }
  
  /* If no matching netif was found, we use default netif. */
  return defaultnetif;
 8007444:	f241 63d8 	movw	r3, #5848	; 0x16d8
 8007448:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800744c:	681b      	ldr	r3, [r3, #0]
}
 800744e:	4618      	mov	r0, r3
 8007450:	f107 0708 	add.w	r7, r7, #8
 8007454:	46bd      	mov	sp, r7
 8007456:	bd80      	pop	{r7, pc}
 8007458:	20001728 	.word	0x20001728

0800745c <uip_fw_output>:
 * function is passed unmodified as a return value.
 */
/*------------------------------------------------------------------------------*/
uint8_t
uip_fw_output(void)
{
 800745c:	b580      	push	{r7, lr}
 800745e:	b082      	sub	sp, #8
 8007460:	af00      	add	r7, sp, #0
  struct uip_fw_netif *netif;
#if UIP_BROADCAST
  const struct uip_udpip_hdr *udp = (void *)BUF;
#endif /* UIP_BROADCAST */

  if(uip_len == 0) {
 8007462:	f241 730c 	movw	r3, #5900	; 0x170c
 8007466:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800746a:	881b      	ldrh	r3, [r3, #0]
 800746c:	2b00      	cmp	r3, #0
 800746e:	d101      	bne.n	8007474 <uip_fw_output+0x18>
    return UIP_FW_ZEROLEN;
 8007470:	2302      	movs	r3, #2
 8007472:	e00d      	b.n	8007490 <uip_fw_output+0x34>
  }

  fwcache_register();
 8007474:	f7ff ff54 	bl	8007320 <fwcache_register>
    }
    return UIP_FW_OK;
  }
#endif /* UIP_BROADCAST */
  
  netif = find_netif();
 8007478:	f7ff ffc6 	bl	8007408 <find_netif>
 800747c:	6078      	str	r0, [r7, #4]
  /*  printf("uip_fw_output: netif %p ->output %p len %d\n", netif,
	 netif->output,
	 uip_len);*/

  if(netif == NULL) {
 800747e:	687b      	ldr	r3, [r7, #4]
 8007480:	2b00      	cmp	r3, #0
 8007482:	d101      	bne.n	8007488 <uip_fw_output+0x2c>
    return UIP_FW_NOROUTE;
 8007484:	2304      	movs	r3, #4
 8007486:	e003      	b.n	8007490 <uip_fw_output+0x34>
  }
  /* If we now have found a suitable network interface, we call its
     output function to send out the packet. */
  return netif->output();
 8007488:	687b      	ldr	r3, [r7, #4]
 800748a:	68db      	ldr	r3, [r3, #12]
 800748c:	4798      	blx	r3
 800748e:	4603      	mov	r3, r0
}
 8007490:	4618      	mov	r0, r3
 8007492:	f107 0708 	add.w	r7, r7, #8
 8007496:	46bd      	mov	sp, r7
 8007498:	bd80      	pop	{r7, pc}
 800749a:	bf00      	nop

0800749c <uip_fw_register>:
 * registered.
 */
/*------------------------------------------------------------------------------*/
void
uip_fw_register(struct uip_fw_netif *netif)
{
 800749c:	b480      	push	{r7}
 800749e:	b083      	sub	sp, #12
 80074a0:	af00      	add	r7, sp, #0
 80074a2:	6078      	str	r0, [r7, #4]
  netif->next = netifs;
 80074a4:	f241 63d4 	movw	r3, #5844	; 0x16d4
 80074a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80074ac:	681a      	ldr	r2, [r3, #0]
 80074ae:	687b      	ldr	r3, [r7, #4]
 80074b0:	601a      	str	r2, [r3, #0]
  netifs = netif;
 80074b2:	f241 63d4 	movw	r3, #5844	; 0x16d4
 80074b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80074ba:	687a      	ldr	r2, [r7, #4]
 80074bc:	601a      	str	r2, [r3, #0]
}
 80074be:	f107 070c 	add.w	r7, r7, #12
 80074c2:	46bd      	mov	sp, r7
 80074c4:	bc80      	pop	{r7}
 80074c6:	4770      	bx	lr

080074c8 <uip_fw_default>:
 * registered.
 */
/*------------------------------------------------------------------------------*/
void
uip_fw_default(struct uip_fw_netif *netif)
{
 80074c8:	b480      	push	{r7}
 80074ca:	b083      	sub	sp, #12
 80074cc:	af00      	add	r7, sp, #0
 80074ce:	6078      	str	r0, [r7, #4]
  defaultnetif = netif;
 80074d0:	f241 63d8 	movw	r3, #5848	; 0x16d8
 80074d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80074d8:	687a      	ldr	r2, [r7, #4]
 80074da:	601a      	str	r2, [r3, #0]
}
 80074dc:	f107 070c 	add.w	r7, r7, #12
 80074e0:	46bd      	mov	sp, r7
 80074e2:	bc80      	pop	{r7}
 80074e4:	4770      	bx	lr
 80074e6:	bf00      	nop

080074e8 <process_thread_uip_fw_process>:

PROCESS(uip_fw_process, "IP forwarding");

/*---------------------------------------------------------------------------*/
PROCESS_THREAD(uip_fw_process, ev, data)
{
 80074e8:	b580      	push	{r7, lr}
 80074ea:	b086      	sub	sp, #24
 80074ec:	af00      	add	r7, sp, #0
 80074ee:	60f8      	str	r0, [r7, #12]
 80074f0:	460b      	mov	r3, r1
 80074f2:	607a      	str	r2, [r7, #4]
 80074f4:	72fb      	strb	r3, [r7, #11]
  PROCESS_BEGIN();
 80074f6:	2301      	movs	r3, #1
 80074f8:	75fb      	strb	r3, [r7, #23]
 80074fa:	68fb      	ldr	r3, [r7, #12]
 80074fc:	881b      	ldrh	r3, [r3, #0]
 80074fe:	2b00      	cmp	r3, #0
 8007500:	d002      	beq.n	8007508 <process_thread_uip_fw_process+0x20>
 8007502:	2b2f      	cmp	r3, #47	; 0x2f
 8007504:	d009      	beq.n	800751a <process_thread_uip_fw_process+0x32>
 8007506:	e00d      	b.n	8007524 <process_thread_uip_fw_process+0x3c>

  tcpip_set_outputfunc(uip_fw_output);
 8007508:	f247 405d 	movw	r0, #29789	; 0x745d
 800750c:	f6c0 0000 	movt	r0, #2048	; 0x800
 8007510:	f7ff fb26 	bl	8006b60 <tcpip_set_outputfunc>

  PROCESS_WAIT_UNTIL(ev == PROCESS_EVENT_EXIT);
 8007514:	68fb      	ldr	r3, [r7, #12]
 8007516:	222f      	movs	r2, #47	; 0x2f
 8007518:	801a      	strh	r2, [r3, #0]
 800751a:	7afb      	ldrb	r3, [r7, #11]
 800751c:	2b83      	cmp	r3, #131	; 0x83
 800751e:	d001      	beq.n	8007524 <process_thread_uip_fw_process+0x3c>
 8007520:	2300      	movs	r3, #0
 8007522:	e005      	b.n	8007530 <process_thread_uip_fw_process+0x48>

  PROCESS_END();
 8007524:	2300      	movs	r3, #0
 8007526:	75fb      	strb	r3, [r7, #23]
 8007528:	68fb      	ldr	r3, [r7, #12]
 800752a:	2200      	movs	r2, #0
 800752c:	801a      	strh	r2, [r3, #0]
 800752e:	2303      	movs	r3, #3
}
 8007530:	4618      	mov	r0, r3
 8007532:	f107 0718 	add.w	r7, r7, #24
 8007536:	46bd      	mov	sp, r7
 8007538:	bd80      	pop	{r7, pc}
 800753a:	bf00      	nop

0800753c <NVIC_Init>:
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 800753c:	b480      	push	{r7}
 800753e:	b085      	sub	sp, #20
 8007540:	af00      	add	r7, sp, #0
 8007542:	6078      	str	r0, [r7, #4]
  uint8_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;
 8007544:	2300      	movs	r3, #0
 8007546:	73fb      	strb	r3, [r7, #15]
 8007548:	2300      	movs	r3, #0
 800754a:	73bb      	strb	r3, [r7, #14]
 800754c:	230f      	movs	r3, #15
 800754e:	737b      	strb	r3, [r7, #13]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8007550:	687b      	ldr	r3, [r7, #4]
 8007552:	78db      	ldrb	r3, [r3, #3]
 8007554:	2b00      	cmp	r3, #0
 8007556:	d040      	beq.n	80075da <NVIC_Init+0x9e>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8007558:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800755c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8007560:	68db      	ldr	r3, [r3, #12]
 8007562:	43db      	mvns	r3, r3
 8007564:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8007568:	0a1b      	lsrs	r3, r3, #8
 800756a:	73fb      	strb	r3, [r7, #15]
    tmppre = (0x4 - tmppriority);
 800756c:	7bfb      	ldrb	r3, [r7, #15]
 800756e:	f1c3 0304 	rsb	r3, r3, #4
 8007572:	73bb      	strb	r3, [r7, #14]
    tmpsub = tmpsub >> tmppriority;
 8007574:	7b7a      	ldrb	r2, [r7, #13]
 8007576:	7bfb      	ldrb	r3, [r7, #15]
 8007578:	fa42 f303 	asr.w	r3, r2, r3
 800757c:	737b      	strb	r3, [r7, #13]

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 800757e:	687b      	ldr	r3, [r7, #4]
 8007580:	785b      	ldrb	r3, [r3, #1]
 8007582:	461a      	mov	r2, r3
 8007584:	7bbb      	ldrb	r3, [r7, #14]
 8007586:	fa02 f303 	lsl.w	r3, r2, r3
 800758a:	73fb      	strb	r3, [r7, #15]
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 800758c:	687b      	ldr	r3, [r7, #4]
 800758e:	789a      	ldrb	r2, [r3, #2]
 8007590:	7b7b      	ldrb	r3, [r7, #13]
 8007592:	4013      	ands	r3, r2
 8007594:	b2da      	uxtb	r2, r3
 8007596:	7bfb      	ldrb	r3, [r7, #15]
 8007598:	4313      	orrs	r3, r2
 800759a:	73fb      	strb	r3, [r7, #15]
        
    tmppriority = tmppriority << 0x04;
 800759c:	7bfb      	ldrb	r3, [r7, #15]
 800759e:	011b      	lsls	r3, r3, #4
 80075a0:	73fb      	strb	r3, [r7, #15]
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 80075a2:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 80075a6:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80075aa:	687a      	ldr	r2, [r7, #4]
 80075ac:	7812      	ldrb	r2, [r2, #0]
 80075ae:	189b      	adds	r3, r3, r2
 80075b0:	7bfa      	ldrb	r2, [r7, #15]
 80075b2:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80075b6:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 80075ba:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80075be:	687a      	ldr	r2, [r7, #4]
 80075c0:	7812      	ldrb	r2, [r2, #0]
 80075c2:	0952      	lsrs	r2, r2, #5
 80075c4:	b2d2      	uxtb	r2, r2
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 80075c6:	6879      	ldr	r1, [r7, #4]
 80075c8:	7809      	ldrb	r1, [r1, #0]
 80075ca:	f001 011f 	and.w	r1, r1, #31
 80075ce:	2001      	movs	r0, #1
 80075d0:	fa00 f101 	lsl.w	r1, r0, r1
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80075d4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 80075d8:	e011      	b.n	80075fe <NVIC_Init+0xc2>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80075da:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 80075de:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80075e2:	687a      	ldr	r2, [r7, #4]
 80075e4:	7812      	ldrb	r2, [r2, #0]
 80075e6:	0952      	lsrs	r2, r2, #5
 80075e8:	b2d2      	uxtb	r2, r2
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 80075ea:	6879      	ldr	r1, [r7, #4]
 80075ec:	7809      	ldrb	r1, [r1, #0]
 80075ee:	f001 011f 	and.w	r1, r1, #31
 80075f2:	2001      	movs	r0, #1
 80075f4:	fa00 f101 	lsl.w	r1, r0, r1
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80075f8:	3220      	adds	r2, #32
 80075fa:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 80075fe:	f107 0714 	add.w	r7, r7, #20
 8007602:	46bd      	mov	sp, r7
 8007604:	bc80      	pop	{r7}
 8007606:	4770      	bx	lr

08007608 <RCC_GetClocksFreq>:
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8007608:	b480      	push	{r7}
 800760a:	b089      	sub	sp, #36	; 0x24
 800760c:	af00      	add	r7, sp, #0
 800760e:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
 8007610:	2300      	movs	r3, #0
 8007612:	61bb      	str	r3, [r7, #24]
 8007614:	2300      	movs	r3, #0
 8007616:	617b      	str	r3, [r7, #20]
 8007618:	2300      	movs	r3, #0
 800761a:	61fb      	str	r3, [r7, #28]
 800761c:	2302      	movs	r3, #2
 800761e:	613b      	str	r3, [r7, #16]
 8007620:	2300      	movs	r3, #0
 8007622:	60fb      	str	r3, [r7, #12]
 8007624:	2302      	movs	r3, #2
 8007626:	60bb      	str	r3, [r7, #8]

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8007628:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800762c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007630:	689b      	ldr	r3, [r3, #8]
 8007632:	f003 030c 	and.w	r3, r3, #12
 8007636:	61bb      	str	r3, [r7, #24]

  switch (tmp)
 8007638:	69bb      	ldr	r3, [r7, #24]
 800763a:	2b04      	cmp	r3, #4
 800763c:	d00a      	beq.n	8007654 <RCC_GetClocksFreq+0x4c>
 800763e:	2b08      	cmp	r3, #8
 8007640:	d00f      	beq.n	8007662 <RCC_GetClocksFreq+0x5a>
 8007642:	2b00      	cmp	r3, #0
 8007644:	d15a      	bne.n	80076fc <RCC_GetClocksFreq+0xf4>
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8007646:	687a      	ldr	r2, [r7, #4]
 8007648:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 800764c:	f2c0 03f4 	movt	r3, #244	; 0xf4
 8007650:	6013      	str	r3, [r2, #0]
      break;
 8007652:	e05a      	b.n	800770a <RCC_GetClocksFreq+0x102>
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8007654:	687a      	ldr	r2, [r7, #4]
 8007656:	f44f 5390 	mov.w	r3, #4608	; 0x1200
 800765a:	f2c0 037a 	movt	r3, #122	; 0x7a
 800765e:	6013      	str	r3, [r2, #0]
      break;
 8007660:	e053      	b.n	800770a <RCC_GetClocksFreq+0x102>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8007662:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007666:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800766a:	685b      	ldr	r3, [r3, #4]
 800766c:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8007670:	0d9b      	lsrs	r3, r3, #22
 8007672:	60fb      	str	r3, [r7, #12]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8007674:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007678:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800767c:	685b      	ldr	r3, [r3, #4]
 800767e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8007682:	60bb      	str	r3, [r7, #8]
      
      if (pllsource != 0)
 8007684:	68fb      	ldr	r3, [r7, #12]
 8007686:	2b00      	cmp	r3, #0
 8007688:	d013      	beq.n	80076b2 <RCC_GetClocksFreq+0xaa>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 800768a:	f44f 5390 	mov.w	r3, #4608	; 0x1200
 800768e:	f2c0 037a 	movt	r3, #122	; 0x7a
 8007692:	68ba      	ldr	r2, [r7, #8]
 8007694:	fbb3 f2f2 	udiv	r2, r3, r2
 8007698:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800769c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80076a0:	6859      	ldr	r1, [r3, #4]
 80076a2:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 80076a6:	400b      	ands	r3, r1
 80076a8:	099b      	lsrs	r3, r3, #6
 80076aa:	fb03 f302 	mul.w	r3, r3, r2
 80076ae:	61fb      	str	r3, [r7, #28]
 80076b0:	e012      	b.n	80076d8 <RCC_GetClocksFreq+0xd0>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 80076b2:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 80076b6:	f2c0 03f4 	movt	r3, #244	; 0xf4
 80076ba:	68ba      	ldr	r2, [r7, #8]
 80076bc:	fbb3 f2f2 	udiv	r2, r3, r2
 80076c0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80076c4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80076c8:	6859      	ldr	r1, [r3, #4]
 80076ca:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 80076ce:	400b      	ands	r3, r1
 80076d0:	099b      	lsrs	r3, r3, #6
 80076d2:	fb03 f302 	mul.w	r3, r3, r2
 80076d6:	61fb      	str	r3, [r7, #28]
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 80076d8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80076dc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80076e0:	685b      	ldr	r3, [r3, #4]
 80076e2:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 80076e6:	0c1b      	lsrs	r3, r3, #16
 80076e8:	3301      	adds	r3, #1
 80076ea:	005b      	lsls	r3, r3, #1
 80076ec:	613b      	str	r3, [r7, #16]
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 80076ee:	69fa      	ldr	r2, [r7, #28]
 80076f0:	693b      	ldr	r3, [r7, #16]
 80076f2:	fbb2 f2f3 	udiv	r2, r2, r3
 80076f6:	687b      	ldr	r3, [r7, #4]
 80076f8:	601a      	str	r2, [r3, #0]
      break;
 80076fa:	e006      	b.n	800770a <RCC_GetClocksFreq+0x102>
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 80076fc:	687a      	ldr	r2, [r7, #4]
 80076fe:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 8007702:	f2c0 03f4 	movt	r3, #244	; 0xf4
 8007706:	6013      	str	r3, [r2, #0]
      break;
 8007708:	bf00      	nop
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 800770a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800770e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007712:	689b      	ldr	r3, [r3, #8]
 8007714:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8007718:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 4;
 800771a:	69bb      	ldr	r3, [r7, #24]
 800771c:	091b      	lsrs	r3, r3, #4
 800771e:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8007720:	f640 0370 	movw	r3, #2160	; 0x870
 8007724:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007728:	69ba      	ldr	r2, [r7, #24]
 800772a:	189b      	adds	r3, r3, r2
 800772c:	781b      	ldrb	r3, [r3, #0]
 800772e:	b2db      	uxtb	r3, r3
 8007730:	617b      	str	r3, [r7, #20]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8007732:	687b      	ldr	r3, [r7, #4]
 8007734:	681a      	ldr	r2, [r3, #0]
 8007736:	697b      	ldr	r3, [r7, #20]
 8007738:	40da      	lsrs	r2, r3
 800773a:	687b      	ldr	r3, [r7, #4]
 800773c:	605a      	str	r2, [r3, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 800773e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007742:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007746:	689b      	ldr	r3, [r3, #8]
 8007748:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 800774c:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 10;
 800774e:	69bb      	ldr	r3, [r7, #24]
 8007750:	0a9b      	lsrs	r3, r3, #10
 8007752:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8007754:	f640 0370 	movw	r3, #2160	; 0x870
 8007758:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800775c:	69ba      	ldr	r2, [r7, #24]
 800775e:	189b      	adds	r3, r3, r2
 8007760:	781b      	ldrb	r3, [r3, #0]
 8007762:	b2db      	uxtb	r3, r3
 8007764:	617b      	str	r3, [r7, #20]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8007766:	687b      	ldr	r3, [r7, #4]
 8007768:	685a      	ldr	r2, [r3, #4]
 800776a:	697b      	ldr	r3, [r7, #20]
 800776c:	40da      	lsrs	r2, r3
 800776e:	687b      	ldr	r3, [r7, #4]
 8007770:	609a      	str	r2, [r3, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 8007772:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007776:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800777a:	689b      	ldr	r3, [r3, #8]
 800777c:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8007780:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 13;
 8007782:	69bb      	ldr	r3, [r7, #24]
 8007784:	0b5b      	lsrs	r3, r3, #13
 8007786:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8007788:	f640 0370 	movw	r3, #2160	; 0x870
 800778c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007790:	69ba      	ldr	r2, [r7, #24]
 8007792:	189b      	adds	r3, r3, r2
 8007794:	781b      	ldrb	r3, [r3, #0]
 8007796:	b2db      	uxtb	r3, r3
 8007798:	617b      	str	r3, [r7, #20]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800779a:	687b      	ldr	r3, [r7, #4]
 800779c:	685a      	ldr	r2, [r3, #4]
 800779e:	697b      	ldr	r3, [r7, #20]
 80077a0:	40da      	lsrs	r2, r3
 80077a2:	687b      	ldr	r3, [r7, #4]
 80077a4:	60da      	str	r2, [r3, #12]
}
 80077a6:	f107 0724 	add.w	r7, r7, #36	; 0x24
 80077aa:	46bd      	mov	sp, r7
 80077ac:	bc80      	pop	{r7}
 80077ae:	4770      	bx	lr

080077b0 <RCC_AHB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 80077b0:	b480      	push	{r7}
 80077b2:	b083      	sub	sp, #12
 80077b4:	af00      	add	r7, sp, #0
 80077b6:	6078      	str	r0, [r7, #4]
 80077b8:	460b      	mov	r3, r1
 80077ba:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80077bc:	78fb      	ldrb	r3, [r7, #3]
 80077be:	2b00      	cmp	r3, #0
 80077c0:	d00c      	beq.n	80077dc <RCC_AHB1PeriphClockCmd+0x2c>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 80077c2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80077c6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80077ca:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80077ce:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80077d2:	6b11      	ldr	r1, [r2, #48]	; 0x30
 80077d4:	687a      	ldr	r2, [r7, #4]
 80077d6:	430a      	orrs	r2, r1
 80077d8:	631a      	str	r2, [r3, #48]	; 0x30
 80077da:	e00c      	b.n	80077f6 <RCC_AHB1PeriphClockCmd+0x46>
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 80077dc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80077e0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80077e4:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80077e8:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80077ec:	6b11      	ldr	r1, [r2, #48]	; 0x30
 80077ee:	687a      	ldr	r2, [r7, #4]
 80077f0:	43d2      	mvns	r2, r2
 80077f2:	400a      	ands	r2, r1
 80077f4:	631a      	str	r2, [r3, #48]	; 0x30
  }
}
 80077f6:	f107 070c 	add.w	r7, r7, #12
 80077fa:	46bd      	mov	sp, r7
 80077fc:	bc80      	pop	{r7}
 80077fe:	4770      	bx	lr

08007800 <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 8007800:	b480      	push	{r7}
 8007802:	b083      	sub	sp, #12
 8007804:	af00      	add	r7, sp, #0
 8007806:	6078      	str	r0, [r7, #4]
 8007808:	460b      	mov	r3, r1
 800780a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800780c:	78fb      	ldrb	r3, [r7, #3]
 800780e:	2b00      	cmp	r3, #0
 8007810:	d00c      	beq.n	800782c <RCC_APB1PeriphClockCmd+0x2c>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8007812:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007816:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800781a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800781e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8007822:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8007824:	687a      	ldr	r2, [r7, #4]
 8007826:	430a      	orrs	r2, r1
 8007828:	641a      	str	r2, [r3, #64]	; 0x40
 800782a:	e00c      	b.n	8007846 <RCC_APB1PeriphClockCmd+0x46>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 800782c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007830:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007834:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8007838:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800783c:	6c11      	ldr	r1, [r2, #64]	; 0x40
 800783e:	687a      	ldr	r2, [r7, #4]
 8007840:	43d2      	mvns	r2, r2
 8007842:	400a      	ands	r2, r1
 8007844:	641a      	str	r2, [r3, #64]	; 0x40
  }
}
 8007846:	f107 070c 	add.w	r7, r7, #12
 800784a:	46bd      	mov	sp, r7
 800784c:	bc80      	pop	{r7}
 800784e:	4770      	bx	lr

08007850 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8007850:	b480      	push	{r7}
 8007852:	b083      	sub	sp, #12
 8007854:	af00      	add	r7, sp, #0
 8007856:	6078      	str	r0, [r7, #4]
 8007858:	460b      	mov	r3, r1
 800785a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800785c:	78fb      	ldrb	r3, [r7, #3]
 800785e:	2b00      	cmp	r3, #0
 8007860:	d00c      	beq.n	800787c <RCC_APB2PeriphClockCmd+0x2c>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8007862:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007866:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800786a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800786e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8007872:	6c51      	ldr	r1, [r2, #68]	; 0x44
 8007874:	687a      	ldr	r2, [r7, #4]
 8007876:	430a      	orrs	r2, r1
 8007878:	645a      	str	r2, [r3, #68]	; 0x44
 800787a:	e00c      	b.n	8007896 <RCC_APB2PeriphClockCmd+0x46>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 800787c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007880:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007884:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8007888:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800788c:	6c51      	ldr	r1, [r2, #68]	; 0x44
 800788e:	687a      	ldr	r2, [r7, #4]
 8007890:	43d2      	mvns	r2, r2
 8007892:	400a      	ands	r2, r1
 8007894:	645a      	str	r2, [r3, #68]	; 0x44
  }
}
 8007896:	f107 070c 	add.w	r7, r7, #12
 800789a:	46bd      	mov	sp, r7
 800789c:	bc80      	pop	{r7}
 800789e:	4770      	bx	lr

080078a0 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 80078a0:	b480      	push	{r7}
 80078a2:	b087      	sub	sp, #28
 80078a4:	af00      	add	r7, sp, #0
 80078a6:	6078      	str	r0, [r7, #4]
 80078a8:	6039      	str	r1, [r7, #0]
  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
 80078aa:	2300      	movs	r3, #0
 80078ac:	617b      	str	r3, [r7, #20]
 80078ae:	2300      	movs	r3, #0
 80078b0:	613b      	str	r3, [r7, #16]
 80078b2:	2300      	movs	r3, #0
 80078b4:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80078b6:	2300      	movs	r3, #0
 80078b8:	617b      	str	r3, [r7, #20]
 80078ba:	e076      	b.n	80079aa <GPIO_Init+0x10a>
  {
    pos = ((uint32_t)0x01) << pinpos;
 80078bc:	697b      	ldr	r3, [r7, #20]
 80078be:	2201      	movs	r2, #1
 80078c0:	fa02 f303 	lsl.w	r3, r2, r3
 80078c4:	613b      	str	r3, [r7, #16]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80078c6:	683b      	ldr	r3, [r7, #0]
 80078c8:	681a      	ldr	r2, [r3, #0]
 80078ca:	693b      	ldr	r3, [r7, #16]
 80078cc:	4013      	ands	r3, r2
 80078ce:	60fb      	str	r3, [r7, #12]

    if (currentpin == pos)
 80078d0:	68fa      	ldr	r2, [r7, #12]
 80078d2:	693b      	ldr	r3, [r7, #16]
 80078d4:	429a      	cmp	r2, r3
 80078d6:	d165      	bne.n	80079a4 <GPIO_Init+0x104>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80078d8:	687b      	ldr	r3, [r7, #4]
 80078da:	681a      	ldr	r2, [r3, #0]
 80078dc:	697b      	ldr	r3, [r7, #20]
 80078de:	005b      	lsls	r3, r3, #1
 80078e0:	2103      	movs	r1, #3
 80078e2:	fa01 f303 	lsl.w	r3, r1, r3
 80078e6:	43db      	mvns	r3, r3
 80078e8:	401a      	ands	r2, r3
 80078ea:	687b      	ldr	r3, [r7, #4]
 80078ec:	601a      	str	r2, [r3, #0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80078ee:	687b      	ldr	r3, [r7, #4]
 80078f0:	681a      	ldr	r2, [r3, #0]
 80078f2:	683b      	ldr	r3, [r7, #0]
 80078f4:	791b      	ldrb	r3, [r3, #4]
 80078f6:	4619      	mov	r1, r3
 80078f8:	697b      	ldr	r3, [r7, #20]
 80078fa:	005b      	lsls	r3, r3, #1
 80078fc:	fa01 f303 	lsl.w	r3, r1, r3
 8007900:	431a      	orrs	r2, r3
 8007902:	687b      	ldr	r3, [r7, #4]
 8007904:	601a      	str	r2, [r3, #0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8007906:	683b      	ldr	r3, [r7, #0]
 8007908:	791b      	ldrb	r3, [r3, #4]
 800790a:	2b01      	cmp	r3, #1
 800790c:	d003      	beq.n	8007916 <GPIO_Init+0x76>
 800790e:	683b      	ldr	r3, [r7, #0]
 8007910:	791b      	ldrb	r3, [r3, #4]
 8007912:	2b02      	cmp	r3, #2
 8007914:	d12e      	bne.n	8007974 <GPIO_Init+0xd4>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8007916:	687b      	ldr	r3, [r7, #4]
 8007918:	689a      	ldr	r2, [r3, #8]
 800791a:	697b      	ldr	r3, [r7, #20]
 800791c:	005b      	lsls	r3, r3, #1
 800791e:	2103      	movs	r1, #3
 8007920:	fa01 f303 	lsl.w	r3, r1, r3
 8007924:	43db      	mvns	r3, r3
 8007926:	401a      	ands	r2, r3
 8007928:	687b      	ldr	r3, [r7, #4]
 800792a:	609a      	str	r2, [r3, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 800792c:	687b      	ldr	r3, [r7, #4]
 800792e:	689a      	ldr	r2, [r3, #8]
 8007930:	683b      	ldr	r3, [r7, #0]
 8007932:	795b      	ldrb	r3, [r3, #5]
 8007934:	4619      	mov	r1, r3
 8007936:	697b      	ldr	r3, [r7, #20]
 8007938:	005b      	lsls	r3, r3, #1
 800793a:	fa01 f303 	lsl.w	r3, r1, r3
 800793e:	431a      	orrs	r2, r3
 8007940:	687b      	ldr	r3, [r7, #4]
 8007942:	609a      	str	r2, [r3, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 8007944:	687b      	ldr	r3, [r7, #4]
 8007946:	685a      	ldr	r2, [r3, #4]
 8007948:	697b      	ldr	r3, [r7, #20]
 800794a:	b29b      	uxth	r3, r3
 800794c:	2101      	movs	r1, #1
 800794e:	fa01 f303 	lsl.w	r3, r1, r3
 8007952:	43db      	mvns	r3, r3
 8007954:	401a      	ands	r2, r3
 8007956:	687b      	ldr	r3, [r7, #4]
 8007958:	605a      	str	r2, [r3, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 800795a:	687b      	ldr	r3, [r7, #4]
 800795c:	685a      	ldr	r2, [r3, #4]
 800795e:	683b      	ldr	r3, [r7, #0]
 8007960:	799b      	ldrb	r3, [r3, #6]
 8007962:	4619      	mov	r1, r3
 8007964:	697b      	ldr	r3, [r7, #20]
 8007966:	b29b      	uxth	r3, r3
 8007968:	fa01 f303 	lsl.w	r3, r1, r3
 800796c:	b29b      	uxth	r3, r3
 800796e:	431a      	orrs	r2, r3
 8007970:	687b      	ldr	r3, [r7, #4]
 8007972:	605a      	str	r2, [r3, #4]
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8007974:	687b      	ldr	r3, [r7, #4]
 8007976:	68da      	ldr	r2, [r3, #12]
 8007978:	697b      	ldr	r3, [r7, #20]
 800797a:	b29b      	uxth	r3, r3
 800797c:	005b      	lsls	r3, r3, #1
 800797e:	2103      	movs	r1, #3
 8007980:	fa01 f303 	lsl.w	r3, r1, r3
 8007984:	43db      	mvns	r3, r3
 8007986:	401a      	ands	r2, r3
 8007988:	687b      	ldr	r3, [r7, #4]
 800798a:	60da      	str	r2, [r3, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 800798c:	687b      	ldr	r3, [r7, #4]
 800798e:	68da      	ldr	r2, [r3, #12]
 8007990:	683b      	ldr	r3, [r7, #0]
 8007992:	79db      	ldrb	r3, [r3, #7]
 8007994:	4619      	mov	r1, r3
 8007996:	697b      	ldr	r3, [r7, #20]
 8007998:	005b      	lsls	r3, r3, #1
 800799a:	fa01 f303 	lsl.w	r3, r1, r3
 800799e:	431a      	orrs	r2, r3
 80079a0:	687b      	ldr	r3, [r7, #4]
 80079a2:	60da      	str	r2, [r3, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80079a4:	697b      	ldr	r3, [r7, #20]
 80079a6:	3301      	adds	r3, #1
 80079a8:	617b      	str	r3, [r7, #20]
 80079aa:	697b      	ldr	r3, [r7, #20]
 80079ac:	2b0f      	cmp	r3, #15
 80079ae:	d985      	bls.n	80078bc <GPIO_Init+0x1c>
      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 80079b0:	f107 071c 	add.w	r7, r7, #28
 80079b4:	46bd      	mov	sp, r7
 80079b6:	bc80      	pop	{r7}
 80079b8:	4770      	bx	lr
 80079ba:	bf00      	nop

080079bc <GPIO_SetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80079bc:	b480      	push	{r7}
 80079be:	b083      	sub	sp, #12
 80079c0:	af00      	add	r7, sp, #0
 80079c2:	6078      	str	r0, [r7, #4]
 80079c4:	460b      	mov	r3, r1
 80079c6:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRL = GPIO_Pin;
 80079c8:	687b      	ldr	r3, [r7, #4]
 80079ca:	887a      	ldrh	r2, [r7, #2]
 80079cc:	831a      	strh	r2, [r3, #24]
}
 80079ce:	f107 070c 	add.w	r7, r7, #12
 80079d2:	46bd      	mov	sp, r7
 80079d4:	bc80      	pop	{r7}
 80079d6:	4770      	bx	lr

080079d8 <GPIO_ResetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80079d8:	b480      	push	{r7}
 80079da:	b083      	sub	sp, #12
 80079dc:	af00      	add	r7, sp, #0
 80079de:	6078      	str	r0, [r7, #4]
 80079e0:	460b      	mov	r3, r1
 80079e2:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRH = GPIO_Pin;
 80079e4:	687b      	ldr	r3, [r7, #4]
 80079e6:	887a      	ldrh	r2, [r7, #2]
 80079e8:	835a      	strh	r2, [r3, #26]
}
 80079ea:	f107 070c 	add.w	r7, r7, #12
 80079ee:	46bd      	mov	sp, r7
 80079f0:	bc80      	pop	{r7}
 80079f2:	4770      	bx	lr

080079f4 <GPIO_PinAFConfig>:
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 80079f4:	b480      	push	{r7}
 80079f6:	b085      	sub	sp, #20
 80079f8:	af00      	add	r7, sp, #0
 80079fa:	6078      	str	r0, [r7, #4]
 80079fc:	4613      	mov	r3, r2
 80079fe:	460a      	mov	r2, r1
 8007a00:	807a      	strh	r2, [r7, #2]
 8007a02:	707b      	strb	r3, [r7, #1]
  uint32_t temp = 0x00;
 8007a04:	2300      	movs	r3, #0
 8007a06:	60fb      	str	r3, [r7, #12]
  uint32_t temp_2 = 0x00;
 8007a08:	2300      	movs	r3, #0
 8007a0a:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8007a0c:	787a      	ldrb	r2, [r7, #1]
 8007a0e:	887b      	ldrh	r3, [r7, #2]
 8007a10:	f003 0307 	and.w	r3, r3, #7
 8007a14:	009b      	lsls	r3, r3, #2
 8007a16:	fa02 f303 	lsl.w	r3, r2, r3
 8007a1a:	60fb      	str	r3, [r7, #12]
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8007a1c:	887b      	ldrh	r3, [r7, #2]
 8007a1e:	08db      	lsrs	r3, r3, #3
 8007a20:	b29b      	uxth	r3, r3
 8007a22:	461a      	mov	r2, r3
 8007a24:	887b      	ldrh	r3, [r7, #2]
 8007a26:	08db      	lsrs	r3, r3, #3
 8007a28:	b29b      	uxth	r3, r3
 8007a2a:	4619      	mov	r1, r3
 8007a2c:	687b      	ldr	r3, [r7, #4]
 8007a2e:	3108      	adds	r1, #8
 8007a30:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 8007a34:	887b      	ldrh	r3, [r7, #2]
 8007a36:	f003 0307 	and.w	r3, r3, #7
 8007a3a:	009b      	lsls	r3, r3, #2
 8007a3c:	200f      	movs	r0, #15
 8007a3e:	fa00 f303 	lsl.w	r3, r0, r3
 8007a42:	43db      	mvns	r3, r3
 8007a44:	4019      	ands	r1, r3
 8007a46:	687b      	ldr	r3, [r7, #4]
 8007a48:	3208      	adds	r2, #8
 8007a4a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8007a4e:	887b      	ldrh	r3, [r7, #2]
 8007a50:	08db      	lsrs	r3, r3, #3
 8007a52:	b29b      	uxth	r3, r3
 8007a54:	461a      	mov	r2, r3
 8007a56:	687b      	ldr	r3, [r7, #4]
 8007a58:	3208      	adds	r2, #8
 8007a5a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8007a5e:	68fb      	ldr	r3, [r7, #12]
 8007a60:	4313      	orrs	r3, r2
 8007a62:	60bb      	str	r3, [r7, #8]
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 8007a64:	887b      	ldrh	r3, [r7, #2]
 8007a66:	08db      	lsrs	r3, r3, #3
 8007a68:	b29b      	uxth	r3, r3
 8007a6a:	461a      	mov	r2, r3
 8007a6c:	687b      	ldr	r3, [r7, #4]
 8007a6e:	3208      	adds	r2, #8
 8007a70:	68b9      	ldr	r1, [r7, #8]
 8007a72:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8007a76:	f107 0714 	add.w	r7, r7, #20
 8007a7a:	46bd      	mov	sp, r7
 8007a7c:	bc80      	pop	{r7}
 8007a7e:	4770      	bx	lr

08007a80 <TIM_TimeBaseInit>:
  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 8007a80:	b480      	push	{r7}
 8007a82:	b085      	sub	sp, #20
 8007a84:	af00      	add	r7, sp, #0
 8007a86:	6078      	str	r0, [r7, #4]
 8007a88:	6039      	str	r1, [r7, #0]
  uint16_t tmpcr1 = 0;
 8007a8a:	2300      	movs	r3, #0
 8007a8c:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 8007a8e:	687b      	ldr	r3, [r7, #4]
 8007a90:	881b      	ldrh	r3, [r3, #0]
 8007a92:	81fb      	strh	r3, [r7, #14]

  if((TIMx == TIM1) || (TIMx == TIM8)||
 8007a94:	687a      	ldr	r2, [r7, #4]
 8007a96:	2300      	movs	r3, #0
 8007a98:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8007a9c:	429a      	cmp	r2, r3
 8007a9e:	d01f      	beq.n	8007ae0 <TIM_TimeBaseInit+0x60>
 8007aa0:	687a      	ldr	r2, [r7, #4]
 8007aa2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8007aa6:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8007aaa:	429a      	cmp	r2, r3
 8007aac:	d018      	beq.n	8007ae0 <TIM_TimeBaseInit+0x60>
 8007aae:	687b      	ldr	r3, [r7, #4]
 8007ab0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8007ab4:	d014      	beq.n	8007ae0 <TIM_TimeBaseInit+0x60>
     (TIMx == TIM2) || (TIMx == TIM3)||
 8007ab6:	687a      	ldr	r2, [r7, #4]
 8007ab8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8007abc:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007ac0:	429a      	cmp	r2, r3
 8007ac2:	d00d      	beq.n	8007ae0 <TIM_TimeBaseInit+0x60>
 8007ac4:	687a      	ldr	r2, [r7, #4]
 8007ac6:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007aca:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007ace:	429a      	cmp	r2, r3
 8007ad0:	d006      	beq.n	8007ae0 <TIM_TimeBaseInit+0x60>
     (TIMx == TIM4) || (TIMx == TIM5)) 
 8007ad2:	687a      	ldr	r2, [r7, #4]
 8007ad4:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8007ad8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007adc:	429a      	cmp	r2, r3
 8007ade:	d108      	bne.n	8007af2 <TIM_TimeBaseInit+0x72>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
 8007ae0:	89fb      	ldrh	r3, [r7, #14]
 8007ae2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8007ae6:	81fb      	strh	r3, [r7, #14]
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 8007ae8:	683b      	ldr	r3, [r7, #0]
 8007aea:	885a      	ldrh	r2, [r3, #2]
 8007aec:	89fb      	ldrh	r3, [r7, #14]
 8007aee:	4313      	orrs	r3, r2
 8007af0:	81fb      	strh	r3, [r7, #14]
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
 8007af2:	687a      	ldr	r2, [r7, #4]
 8007af4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8007af8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007afc:	429a      	cmp	r2, r3
 8007afe:	d00f      	beq.n	8007b20 <TIM_TimeBaseInit+0xa0>
 8007b00:	687a      	ldr	r2, [r7, #4]
 8007b02:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8007b06:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007b0a:	429a      	cmp	r2, r3
 8007b0c:	d008      	beq.n	8007b20 <TIM_TimeBaseInit+0xa0>
  {
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 8007b0e:	89fb      	ldrh	r3, [r7, #14]
 8007b10:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8007b14:	81fb      	strh	r3, [r7, #14]
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8007b16:	683b      	ldr	r3, [r7, #0]
 8007b18:	891a      	ldrh	r2, [r3, #8]
 8007b1a:	89fb      	ldrh	r3, [r7, #14]
 8007b1c:	4313      	orrs	r3, r2
 8007b1e:	81fb      	strh	r3, [r7, #14]
  }

  TIMx->CR1 = tmpcr1;
 8007b20:	687b      	ldr	r3, [r7, #4]
 8007b22:	89fa      	ldrh	r2, [r7, #14]
 8007b24:	801a      	strh	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 8007b26:	683b      	ldr	r3, [r7, #0]
 8007b28:	685a      	ldr	r2, [r3, #4]
 8007b2a:	687b      	ldr	r3, [r7, #4]
 8007b2c:	62da      	str	r2, [r3, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 8007b2e:	683b      	ldr	r3, [r7, #0]
 8007b30:	881a      	ldrh	r2, [r3, #0]
 8007b32:	687b      	ldr	r3, [r7, #4]
 8007b34:	851a      	strh	r2, [r3, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8))  
 8007b36:	687a      	ldr	r2, [r7, #4]
 8007b38:	2300      	movs	r3, #0
 8007b3a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8007b3e:	429a      	cmp	r2, r3
 8007b40:	d006      	beq.n	8007b50 <TIM_TimeBaseInit+0xd0>
 8007b42:	687a      	ldr	r2, [r7, #4]
 8007b44:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8007b48:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8007b4c:	429a      	cmp	r2, r3
 8007b4e:	d104      	bne.n	8007b5a <TIM_TimeBaseInit+0xda>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 8007b50:	683b      	ldr	r3, [r7, #0]
 8007b52:	7a9b      	ldrb	r3, [r3, #10]
 8007b54:	461a      	mov	r2, r3
 8007b56:	687b      	ldr	r3, [r7, #4]
 8007b58:	861a      	strh	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;          
 8007b5a:	687b      	ldr	r3, [r7, #4]
 8007b5c:	2201      	movs	r2, #1
 8007b5e:	829a      	strh	r2, [r3, #20]
}
 8007b60:	f107 0714 	add.w	r7, r7, #20
 8007b64:	46bd      	mov	sp, r7
 8007b66:	bc80      	pop	{r7}
 8007b68:	4770      	bx	lr
 8007b6a:	bf00      	nop

08007b6c <TIM_Cmd>:
  * @param  NewState: new state of the TIMx peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 8007b6c:	b480      	push	{r7}
 8007b6e:	b083      	sub	sp, #12
 8007b70:	af00      	add	r7, sp, #0
 8007b72:	6078      	str	r0, [r7, #4]
 8007b74:	460b      	mov	r3, r1
 8007b76:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8007b78:	78fb      	ldrb	r3, [r7, #3]
 8007b7a:	2b00      	cmp	r3, #0
 8007b7c:	d008      	beq.n	8007b90 <TIM_Cmd+0x24>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 8007b7e:	687b      	ldr	r3, [r7, #4]
 8007b80:	881b      	ldrh	r3, [r3, #0]
 8007b82:	b29b      	uxth	r3, r3
 8007b84:	f043 0301 	orr.w	r3, r3, #1
 8007b88:	b29a      	uxth	r2, r3
 8007b8a:	687b      	ldr	r3, [r7, #4]
 8007b8c:	801a      	strh	r2, [r3, #0]
 8007b8e:	e007      	b.n	8007ba0 <TIM_Cmd+0x34>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
 8007b90:	687b      	ldr	r3, [r7, #4]
 8007b92:	881b      	ldrh	r3, [r3, #0]
 8007b94:	b29b      	uxth	r3, r3
 8007b96:	f023 0301 	bic.w	r3, r3, #1
 8007b9a:	b29a      	uxth	r2, r3
 8007b9c:	687b      	ldr	r3, [r7, #4]
 8007b9e:	801a      	strh	r2, [r3, #0]
  }
}
 8007ba0:	f107 070c 	add.w	r7, r7, #12
 8007ba4:	46bd      	mov	sp, r7
 8007ba6:	bc80      	pop	{r7}
 8007ba8:	4770      	bx	lr
 8007baa:	bf00      	nop

08007bac <TIM_ITConfig>:
  * @param  NewState: new state of the TIM interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
{  
 8007bac:	b480      	push	{r7}
 8007bae:	b083      	sub	sp, #12
 8007bb0:	af00      	add	r7, sp, #0
 8007bb2:	6078      	str	r0, [r7, #4]
 8007bb4:	4613      	mov	r3, r2
 8007bb6:	460a      	mov	r2, r1
 8007bb8:	807a      	strh	r2, [r7, #2]
 8007bba:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8007bbc:	787b      	ldrb	r3, [r7, #1]
 8007bbe:	2b00      	cmp	r3, #0
 8007bc0:	d008      	beq.n	8007bd4 <TIM_ITConfig+0x28>
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 8007bc2:	687b      	ldr	r3, [r7, #4]
 8007bc4:	899b      	ldrh	r3, [r3, #12]
 8007bc6:	b29a      	uxth	r2, r3
 8007bc8:	887b      	ldrh	r3, [r7, #2]
 8007bca:	4313      	orrs	r3, r2
 8007bcc:	b29a      	uxth	r2, r3
 8007bce:	687b      	ldr	r3, [r7, #4]
 8007bd0:	819a      	strh	r2, [r3, #12]
 8007bd2:	e009      	b.n	8007be8 <TIM_ITConfig+0x3c>
  }
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
 8007bd4:	687b      	ldr	r3, [r7, #4]
 8007bd6:	899b      	ldrh	r3, [r3, #12]
 8007bd8:	b29a      	uxth	r2, r3
 8007bda:	887b      	ldrh	r3, [r7, #2]
 8007bdc:	43db      	mvns	r3, r3
 8007bde:	b29b      	uxth	r3, r3
 8007be0:	4013      	ands	r3, r2
 8007be2:	b29a      	uxth	r2, r3
 8007be4:	687b      	ldr	r3, [r7, #4]
 8007be6:	819a      	strh	r2, [r3, #12]
  }
}
 8007be8:	f107 070c 	add.w	r7, r7, #12
 8007bec:	46bd      	mov	sp, r7
 8007bee:	bc80      	pop	{r7}
 8007bf0:	4770      	bx	lr
 8007bf2:	bf00      	nop

08007bf4 <TIM_ClearITPendingBit>:
  * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
  *      
  * @retval None
  */
void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
 8007bf4:	b480      	push	{r7}
 8007bf6:	b083      	sub	sp, #12
 8007bf8:	af00      	add	r7, sp, #0
 8007bfa:	6078      	str	r0, [r7, #4]
 8007bfc:	460b      	mov	r3, r1
 8007bfe:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 8007c00:	887b      	ldrh	r3, [r7, #2]
 8007c02:	43db      	mvns	r3, r3
 8007c04:	b29a      	uxth	r2, r3
 8007c06:	687b      	ldr	r3, [r7, #4]
 8007c08:	821a      	strh	r2, [r3, #16]
}
 8007c0a:	f107 070c 	add.w	r7, r7, #12
 8007c0e:	46bd      	mov	sp, r7
 8007c10:	bc80      	pop	{r7}
 8007c12:	4770      	bx	lr

08007c14 <USART_Init>:
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8007c14:	b580      	push	{r7, lr}
 8007c16:	b08a      	sub	sp, #40	; 0x28
 8007c18:	af00      	add	r7, sp, #0
 8007c1a:	6078      	str	r0, [r7, #4]
 8007c1c:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0x00, apbclock = 0x00;
 8007c1e:	2300      	movs	r3, #0
 8007c20:	627b      	str	r3, [r7, #36]	; 0x24
 8007c22:	2300      	movs	r3, #0
 8007c24:	623b      	str	r3, [r7, #32]
  uint32_t integerdivider = 0x00;
 8007c26:	2300      	movs	r3, #0
 8007c28:	61fb      	str	r3, [r7, #28]
  uint32_t fractionaldivider = 0x00;
 8007c2a:	2300      	movs	r3, #0
 8007c2c:	61bb      	str	r3, [r7, #24]
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  }

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8007c2e:	687b      	ldr	r3, [r7, #4]
 8007c30:	8a1b      	ldrh	r3, [r3, #16]
 8007c32:	b29b      	uxth	r3, r3
 8007c34:	627b      	str	r3, [r7, #36]	; 0x24

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 8007c36:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007c38:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8007c3c:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
      Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 8007c3e:	683b      	ldr	r3, [r7, #0]
 8007c40:	88db      	ldrh	r3, [r3, #6]
 8007c42:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007c44:	4313      	orrs	r3, r2
 8007c46:	627b      	str	r3, [r7, #36]	; 0x24
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8007c48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007c4a:	b29a      	uxth	r2, r3
 8007c4c:	687b      	ldr	r3, [r7, #4]
 8007c4e:	821a      	strh	r2, [r3, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8007c50:	687b      	ldr	r3, [r7, #4]
 8007c52:	899b      	ldrh	r3, [r3, #12]
 8007c54:	b29b      	uxth	r3, r3
 8007c56:	627b      	str	r3, [r7, #36]	; 0x24

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 8007c58:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007c5a:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
 8007c5e:	f023 030c 	bic.w	r3, r3, #12
 8007c62:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the USART Word Length, Parity and mode: 
     Set the M bits according to USART_WordLength value 
     Set PCE and PS bits according to USART_Parity value
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8007c64:	683b      	ldr	r3, [r7, #0]
 8007c66:	889a      	ldrh	r2, [r3, #4]
 8007c68:	683b      	ldr	r3, [r7, #0]
 8007c6a:	891b      	ldrh	r3, [r3, #8]
 8007c6c:	4313      	orrs	r3, r2
 8007c6e:	b29a      	uxth	r2, r3
            USART_InitStruct->USART_Mode;
 8007c70:	683b      	ldr	r3, [r7, #0]
 8007c72:	895b      	ldrh	r3, [r3, #10]

  /* Configure the USART Word Length, Parity and mode: 
     Set the M bits according to USART_WordLength value 
     Set PCE and PS bits according to USART_Parity value
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8007c74:	4313      	orrs	r3, r2
 8007c76:	b29b      	uxth	r3, r3
 8007c78:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007c7a:	4313      	orrs	r3, r2
 8007c7c:	627b      	str	r3, [r7, #36]	; 0x24
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 8007c7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007c80:	b29a      	uxth	r2, r3
 8007c82:	687b      	ldr	r3, [r7, #4]
 8007c84:	819a      	strh	r2, [r3, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8007c86:	687b      	ldr	r3, [r7, #4]
 8007c88:	8a9b      	ldrh	r3, [r3, #20]
 8007c8a:	b29b      	uxth	r3, r3
 8007c8c:	627b      	str	r3, [r7, #36]	; 0x24

  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 8007c8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007c90:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8007c94:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the USART HFC : 
      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 8007c96:	683b      	ldr	r3, [r7, #0]
 8007c98:	899b      	ldrh	r3, [r3, #12]
 8007c9a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007c9c:	4313      	orrs	r3, r2
 8007c9e:	627b      	str	r3, [r7, #36]	; 0x24

  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8007ca0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007ca2:	b29a      	uxth	r2, r3
 8007ca4:	687b      	ldr	r3, [r7, #4]
 8007ca6:	829a      	strh	r2, [r3, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate */
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 8007ca8:	f107 0308 	add.w	r3, r7, #8
 8007cac:	4618      	mov	r0, r3
 8007cae:	f7ff fcab 	bl	8007608 <RCC_GetClocksFreq>

  if ((USARTx == USART1) || (USARTx == USART6))
 8007cb2:	687a      	ldr	r2, [r7, #4]
 8007cb4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8007cb8:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8007cbc:	429a      	cmp	r2, r3
 8007cbe:	d006      	beq.n	8007cce <USART_Init+0xba>
 8007cc0:	687a      	ldr	r2, [r7, #4]
 8007cc2:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8007cc6:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8007cca:	429a      	cmp	r2, r3
 8007ccc:	d102      	bne.n	8007cd4 <USART_Init+0xc0>
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 8007cce:	697b      	ldr	r3, [r7, #20]
 8007cd0:	623b      	str	r3, [r7, #32]
 8007cd2:	e001      	b.n	8007cd8 <USART_Init+0xc4>
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 8007cd4:	693b      	ldr	r3, [r7, #16]
 8007cd6:	623b      	str	r3, [r7, #32]
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8007cd8:	687b      	ldr	r3, [r7, #4]
 8007cda:	899b      	ldrh	r3, [r3, #12]
 8007cdc:	b29b      	uxth	r3, r3
 8007cde:	b29b      	uxth	r3, r3
 8007ce0:	b21b      	sxth	r3, r3
 8007ce2:	2b00      	cmp	r3, #0
 8007ce4:	da0c      	bge.n	8007d00 <USART_Init+0xec>
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 8007ce6:	6a3a      	ldr	r2, [r7, #32]
 8007ce8:	4613      	mov	r3, r2
 8007cea:	009b      	lsls	r3, r3, #2
 8007cec:	189b      	adds	r3, r3, r2
 8007cee:	009a      	lsls	r2, r3, #2
 8007cf0:	189a      	adds	r2, r3, r2
 8007cf2:	683b      	ldr	r3, [r7, #0]
 8007cf4:	681b      	ldr	r3, [r3, #0]
 8007cf6:	005b      	lsls	r3, r3, #1
 8007cf8:	fbb2 f3f3 	udiv	r3, r2, r3
 8007cfc:	61fb      	str	r3, [r7, #28]
 8007cfe:	e00b      	b.n	8007d18 <USART_Init+0x104>
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8007d00:	6a3a      	ldr	r2, [r7, #32]
 8007d02:	4613      	mov	r3, r2
 8007d04:	009b      	lsls	r3, r3, #2
 8007d06:	189b      	adds	r3, r3, r2
 8007d08:	009a      	lsls	r2, r3, #2
 8007d0a:	189a      	adds	r2, r3, r2
 8007d0c:	683b      	ldr	r3, [r7, #0]
 8007d0e:	681b      	ldr	r3, [r3, #0]
 8007d10:	009b      	lsls	r3, r3, #2
 8007d12:	fbb2 f3f3 	udiv	r3, r2, r3
 8007d16:	61fb      	str	r3, [r7, #28]
  }
  tmpreg = (integerdivider / 100) << 4;
 8007d18:	69fa      	ldr	r2, [r7, #28]
 8007d1a:	f248 531f 	movw	r3, #34079	; 0x851f
 8007d1e:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 8007d22:	fba3 1302 	umull	r1, r3, r3, r2
 8007d26:	095b      	lsrs	r3, r3, #5
 8007d28:	011b      	lsls	r3, r3, #4
 8007d2a:	627b      	str	r3, [r7, #36]	; 0x24

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 8007d2c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007d2e:	091b      	lsrs	r3, r3, #4
 8007d30:	2264      	movs	r2, #100	; 0x64
 8007d32:	fb02 f303 	mul.w	r3, r2, r3
 8007d36:	69fa      	ldr	r2, [r7, #28]
 8007d38:	1ad3      	subs	r3, r2, r3
 8007d3a:	61bb      	str	r3, [r7, #24]

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8007d3c:	687b      	ldr	r3, [r7, #4]
 8007d3e:	899b      	ldrh	r3, [r3, #12]
 8007d40:	b29b      	uxth	r3, r3
 8007d42:	b29b      	uxth	r3, r3
 8007d44:	b21b      	sxth	r3, r3
 8007d46:	2b00      	cmp	r3, #0
 8007d48:	da10      	bge.n	8007d6c <USART_Init+0x158>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 8007d4a:	69bb      	ldr	r3, [r7, #24]
 8007d4c:	00db      	lsls	r3, r3, #3
 8007d4e:	f103 0232 	add.w	r2, r3, #50	; 0x32
 8007d52:	f248 531f 	movw	r3, #34079	; 0x851f
 8007d56:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 8007d5a:	fba3 1302 	umull	r1, r3, r3, r2
 8007d5e:	095b      	lsrs	r3, r3, #5
 8007d60:	f003 0307 	and.w	r3, r3, #7
 8007d64:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007d66:	4313      	orrs	r3, r2
 8007d68:	627b      	str	r3, [r7, #36]	; 0x24
 8007d6a:	e00f      	b.n	8007d8c <USART_Init+0x178>
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 8007d6c:	69bb      	ldr	r3, [r7, #24]
 8007d6e:	011b      	lsls	r3, r3, #4
 8007d70:	f103 0232 	add.w	r2, r3, #50	; 0x32
 8007d74:	f248 531f 	movw	r3, #34079	; 0x851f
 8007d78:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 8007d7c:	fba3 1302 	umull	r1, r3, r3, r2
 8007d80:	095b      	lsrs	r3, r3, #5
 8007d82:	f003 030f 	and.w	r3, r3, #15
 8007d86:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007d88:	4313      	orrs	r3, r2
 8007d8a:	627b      	str	r3, [r7, #36]	; 0x24
  }
  
  /* Write to USART BRR register */
  USARTx->BRR = (uint16_t)tmpreg;
 8007d8c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007d8e:	b29a      	uxth	r2, r3
 8007d90:	687b      	ldr	r3, [r7, #4]
 8007d92:	811a      	strh	r2, [r3, #8]
}
 8007d94:	f107 0728 	add.w	r7, r7, #40	; 0x28
 8007d98:	46bd      	mov	sp, r7
 8007d9a:	bd80      	pop	{r7, pc}

08007d9c <USART_Cmd>:
  * @param  NewState: new state of the USARTx peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 8007d9c:	b480      	push	{r7}
 8007d9e:	b083      	sub	sp, #12
 8007da0:	af00      	add	r7, sp, #0
 8007da2:	6078      	str	r0, [r7, #4]
 8007da4:	460b      	mov	r3, r1
 8007da6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8007da8:	78fb      	ldrb	r3, [r7, #3]
 8007daa:	2b00      	cmp	r3, #0
 8007dac:	d008      	beq.n	8007dc0 <USART_Cmd+0x24>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 8007dae:	687b      	ldr	r3, [r7, #4]
 8007db0:	899b      	ldrh	r3, [r3, #12]
 8007db2:	b29b      	uxth	r3, r3
 8007db4:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8007db8:	b29a      	uxth	r2, r3
 8007dba:	687b      	ldr	r3, [r7, #4]
 8007dbc:	819a      	strh	r2, [r3, #12]
 8007dbe:	e007      	b.n	8007dd0 <USART_Cmd+0x34>
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
 8007dc0:	687b      	ldr	r3, [r7, #4]
 8007dc2:	899b      	ldrh	r3, [r3, #12]
 8007dc4:	b29b      	uxth	r3, r3
 8007dc6:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8007dca:	b29a      	uxth	r2, r3
 8007dcc:	687b      	ldr	r3, [r7, #4]
 8007dce:	819a      	strh	r2, [r3, #12]
  }
}
 8007dd0:	f107 070c 	add.w	r7, r7, #12
 8007dd4:	46bd      	mov	sp, r7
 8007dd6:	bc80      	pop	{r7}
 8007dd8:	4770      	bx	lr
 8007dda:	bf00      	nop

08007ddc <USART_SendData>:
  *         UART peripheral.
  * @param  Data: the data to transmit.
  * @retval None
  */
void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
{
 8007ddc:	b480      	push	{r7}
 8007dde:	b083      	sub	sp, #12
 8007de0:	af00      	add	r7, sp, #0
 8007de2:	6078      	str	r0, [r7, #4]
 8007de4:	460b      	mov	r3, r1
 8007de6:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->DR = (Data & (uint16_t)0x01FF);
 8007de8:	887b      	ldrh	r3, [r7, #2]
 8007dea:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8007dee:	b29a      	uxth	r2, r3
 8007df0:	687b      	ldr	r3, [r7, #4]
 8007df2:	809a      	strh	r2, [r3, #4]
}
 8007df4:	f107 070c 	add.w	r7, r7, #12
 8007df8:	46bd      	mov	sp, r7
 8007dfa:	bc80      	pop	{r7}
 8007dfc:	4770      	bx	lr
 8007dfe:	bf00      	nop

08007e00 <USART_ReceiveData>:
  * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
  *         UART peripheral.
  * @retval The received data.
  */
uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
{
 8007e00:	b480      	push	{r7}
 8007e02:	b083      	sub	sp, #12
 8007e04:	af00      	add	r7, sp, #0
 8007e06:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Receive Data */
  return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
 8007e08:	687b      	ldr	r3, [r7, #4]
 8007e0a:	889b      	ldrh	r3, [r3, #4]
 8007e0c:	b29b      	uxth	r3, r3
 8007e0e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8007e12:	b29b      	uxth	r3, r3
}
 8007e14:	4618      	mov	r0, r3
 8007e16:	f107 070c 	add.w	r7, r7, #12
 8007e1a:	46bd      	mov	sp, r7
 8007e1c:	bc80      	pop	{r7}
 8007e1e:	4770      	bx	lr

08007e20 <USART_ITConfig>:
  * @param  NewState: new state of the specified USARTx interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
{
 8007e20:	b480      	push	{r7}
 8007e22:	b087      	sub	sp, #28
 8007e24:	af00      	add	r7, sp, #0
 8007e26:	6078      	str	r0, [r7, #4]
 8007e28:	4613      	mov	r3, r2
 8007e2a:	460a      	mov	r2, r1
 8007e2c:	807a      	strh	r2, [r7, #2]
 8007e2e:	707b      	strb	r3, [r7, #1]
  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
 8007e30:	2300      	movs	r3, #0
 8007e32:	613b      	str	r3, [r7, #16]
 8007e34:	2300      	movs	r3, #0
 8007e36:	60fb      	str	r3, [r7, #12]
 8007e38:	2300      	movs	r3, #0
 8007e3a:	60bb      	str	r3, [r7, #8]
  uint32_t usartxbase = 0x00;
 8007e3c:	2300      	movs	r3, #0
 8007e3e:	617b      	str	r3, [r7, #20]
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  usartxbase = (uint32_t)USARTx;
 8007e40:	687b      	ldr	r3, [r7, #4]
 8007e42:	617b      	str	r3, [r7, #20]

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8007e44:	887b      	ldrh	r3, [r7, #2]
 8007e46:	b2db      	uxtb	r3, r3
 8007e48:	095b      	lsrs	r3, r3, #5
 8007e4a:	b2db      	uxtb	r3, r3
 8007e4c:	613b      	str	r3, [r7, #16]

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
 8007e4e:	887b      	ldrh	r3, [r7, #2]
 8007e50:	f003 031f 	and.w	r3, r3, #31
 8007e54:	60fb      	str	r3, [r7, #12]
  itmask = (((uint32_t)0x01) << itpos);
 8007e56:	68fb      	ldr	r3, [r7, #12]
 8007e58:	2201      	movs	r2, #1
 8007e5a:	fa02 f303 	lsl.w	r3, r2, r3
 8007e5e:	60bb      	str	r3, [r7, #8]
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8007e60:	693b      	ldr	r3, [r7, #16]
 8007e62:	2b01      	cmp	r3, #1
 8007e64:	d103      	bne.n	8007e6e <USART_ITConfig+0x4e>
  {
    usartxbase += 0x0C;
 8007e66:	697b      	ldr	r3, [r7, #20]
 8007e68:	330c      	adds	r3, #12
 8007e6a:	617b      	str	r3, [r7, #20]
 8007e6c:	e009      	b.n	8007e82 <USART_ITConfig+0x62>
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 8007e6e:	693b      	ldr	r3, [r7, #16]
 8007e70:	2b02      	cmp	r3, #2
 8007e72:	d103      	bne.n	8007e7c <USART_ITConfig+0x5c>
  {
    usartxbase += 0x10;
 8007e74:	697b      	ldr	r3, [r7, #20]
 8007e76:	3310      	adds	r3, #16
 8007e78:	617b      	str	r3, [r7, #20]
 8007e7a:	e002      	b.n	8007e82 <USART_ITConfig+0x62>
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 8007e7c:	697b      	ldr	r3, [r7, #20]
 8007e7e:	3314      	adds	r3, #20
 8007e80:	617b      	str	r3, [r7, #20]
  }
  if (NewState != DISABLE)
 8007e82:	787b      	ldrb	r3, [r7, #1]
 8007e84:	2b00      	cmp	r3, #0
 8007e86:	d006      	beq.n	8007e96 <USART_ITConfig+0x76>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 8007e88:	697b      	ldr	r3, [r7, #20]
 8007e8a:	697a      	ldr	r2, [r7, #20]
 8007e8c:	6811      	ldr	r1, [r2, #0]
 8007e8e:	68ba      	ldr	r2, [r7, #8]
 8007e90:	430a      	orrs	r2, r1
 8007e92:	601a      	str	r2, [r3, #0]
 8007e94:	e006      	b.n	8007ea4 <USART_ITConfig+0x84>
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 8007e96:	697b      	ldr	r3, [r7, #20]
 8007e98:	697a      	ldr	r2, [r7, #20]
 8007e9a:	6811      	ldr	r1, [r2, #0]
 8007e9c:	68ba      	ldr	r2, [r7, #8]
 8007e9e:	43d2      	mvns	r2, r2
 8007ea0:	400a      	ands	r2, r1
 8007ea2:	601a      	str	r2, [r3, #0]
  }
}
 8007ea4:	f107 071c 	add.w	r7, r7, #28
 8007ea8:	46bd      	mov	sp, r7
 8007eaa:	bc80      	pop	{r7}
 8007eac:	4770      	bx	lr
 8007eae:	bf00      	nop

08007eb0 <USART_GetFlagStatus>:
  *            @arg USART_FLAG_FE:   Framing Error flag
  *            @arg USART_FLAG_PE:   Parity Error flag
  * @retval The new state of USART_FLAG (SET or RESET).
  */
FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
{
 8007eb0:	b480      	push	{r7}
 8007eb2:	b085      	sub	sp, #20
 8007eb4:	af00      	add	r7, sp, #0
 8007eb6:	6078      	str	r0, [r7, #4]
 8007eb8:	460b      	mov	r3, r1
 8007eba:	807b      	strh	r3, [r7, #2]
  FlagStatus bitstatus = RESET;
 8007ebc:	2300      	movs	r3, #0
 8007ebe:	73fb      	strb	r3, [r7, #15]
  if (USART_FLAG == USART_FLAG_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
 8007ec0:	687b      	ldr	r3, [r7, #4]
 8007ec2:	881b      	ldrh	r3, [r3, #0]
 8007ec4:	b29a      	uxth	r2, r3
 8007ec6:	887b      	ldrh	r3, [r7, #2]
 8007ec8:	4013      	ands	r3, r2
 8007eca:	b29b      	uxth	r3, r3
 8007ecc:	2b00      	cmp	r3, #0
 8007ece:	d002      	beq.n	8007ed6 <USART_GetFlagStatus+0x26>
  {
    bitstatus = SET;
 8007ed0:	2301      	movs	r3, #1
 8007ed2:	73fb      	strb	r3, [r7, #15]
 8007ed4:	e001      	b.n	8007eda <USART_GetFlagStatus+0x2a>
  }
  else
  {
    bitstatus = RESET;
 8007ed6:	2300      	movs	r3, #0
 8007ed8:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8007eda:	7bfb      	ldrb	r3, [r7, #15]
}
 8007edc:	4618      	mov	r0, r3
 8007ede:	f107 0714 	add.w	r7, r7, #20
 8007ee2:	46bd      	mov	sp, r7
 8007ee4:	bc80      	pop	{r7}
 8007ee6:	4770      	bx	lr

08007ee8 <USART_GetITStatus>:
  *            @arg USART_IT_FE:   Framing Error interrupt
  *            @arg USART_IT_PE:   Parity Error interrupt
  * @retval The new state of USART_IT (SET or RESET).
  */
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
{
 8007ee8:	b480      	push	{r7}
 8007eea:	b087      	sub	sp, #28
 8007eec:	af00      	add	r7, sp, #0
 8007eee:	6078      	str	r0, [r7, #4]
 8007ef0:	460b      	mov	r3, r1
 8007ef2:	807b      	strh	r3, [r7, #2]
  uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
 8007ef4:	2300      	movs	r3, #0
 8007ef6:	60fb      	str	r3, [r7, #12]
 8007ef8:	2300      	movs	r3, #0
 8007efa:	617b      	str	r3, [r7, #20]
 8007efc:	2300      	movs	r3, #0
 8007efe:	60bb      	str	r3, [r7, #8]
  ITStatus bitstatus = RESET;
 8007f00:	2300      	movs	r3, #0
 8007f02:	74fb      	strb	r3, [r7, #19]
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8007f04:	887b      	ldrh	r3, [r7, #2]
 8007f06:	b2db      	uxtb	r3, r3
 8007f08:	095b      	lsrs	r3, r3, #5
 8007f0a:	b2db      	uxtb	r3, r3
 8007f0c:	60bb      	str	r3, [r7, #8]
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
 8007f0e:	887b      	ldrh	r3, [r7, #2]
 8007f10:	f003 031f 	and.w	r3, r3, #31
 8007f14:	617b      	str	r3, [r7, #20]
  itmask = (uint32_t)0x01 << itmask;
 8007f16:	697b      	ldr	r3, [r7, #20]
 8007f18:	2201      	movs	r2, #1
 8007f1a:	fa02 f303 	lsl.w	r3, r2, r3
 8007f1e:	617b      	str	r3, [r7, #20]
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 8007f20:	68bb      	ldr	r3, [r7, #8]
 8007f22:	2b01      	cmp	r3, #1
 8007f24:	d106      	bne.n	8007f34 <USART_GetITStatus+0x4c>
  {
    itmask &= USARTx->CR1;
 8007f26:	687b      	ldr	r3, [r7, #4]
 8007f28:	899b      	ldrh	r3, [r3, #12]
 8007f2a:	b29b      	uxth	r3, r3
 8007f2c:	697a      	ldr	r2, [r7, #20]
 8007f2e:	4013      	ands	r3, r2
 8007f30:	617b      	str	r3, [r7, #20]
 8007f32:	e00f      	b.n	8007f54 <USART_GetITStatus+0x6c>
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
 8007f34:	68bb      	ldr	r3, [r7, #8]
 8007f36:	2b02      	cmp	r3, #2
 8007f38:	d106      	bne.n	8007f48 <USART_GetITStatus+0x60>
  {
    itmask &= USARTx->CR2;
 8007f3a:	687b      	ldr	r3, [r7, #4]
 8007f3c:	8a1b      	ldrh	r3, [r3, #16]
 8007f3e:	b29b      	uxth	r3, r3
 8007f40:	697a      	ldr	r2, [r7, #20]
 8007f42:	4013      	ands	r3, r2
 8007f44:	617b      	str	r3, [r7, #20]
 8007f46:	e005      	b.n	8007f54 <USART_GetITStatus+0x6c>
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
 8007f48:	687b      	ldr	r3, [r7, #4]
 8007f4a:	8a9b      	ldrh	r3, [r3, #20]
 8007f4c:	b29b      	uxth	r3, r3
 8007f4e:	697a      	ldr	r2, [r7, #20]
 8007f50:	4013      	ands	r3, r2
 8007f52:	617b      	str	r3, [r7, #20]
  }
  
  bitpos = USART_IT >> 0x08;
 8007f54:	887b      	ldrh	r3, [r7, #2]
 8007f56:	0a1b      	lsrs	r3, r3, #8
 8007f58:	b29b      	uxth	r3, r3
 8007f5a:	60fb      	str	r3, [r7, #12]
  bitpos = (uint32_t)0x01 << bitpos;
 8007f5c:	68fb      	ldr	r3, [r7, #12]
 8007f5e:	2201      	movs	r2, #1
 8007f60:	fa02 f303 	lsl.w	r3, r2, r3
 8007f64:	60fb      	str	r3, [r7, #12]
  bitpos &= USARTx->SR;
 8007f66:	687b      	ldr	r3, [r7, #4]
 8007f68:	881b      	ldrh	r3, [r3, #0]
 8007f6a:	b29b      	uxth	r3, r3
 8007f6c:	68fa      	ldr	r2, [r7, #12]
 8007f6e:	4013      	ands	r3, r2
 8007f70:	60fb      	str	r3, [r7, #12]
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 8007f72:	697b      	ldr	r3, [r7, #20]
 8007f74:	2b00      	cmp	r3, #0
 8007f76:	d005      	beq.n	8007f84 <USART_GetITStatus+0x9c>
 8007f78:	68fb      	ldr	r3, [r7, #12]
 8007f7a:	2b00      	cmp	r3, #0
 8007f7c:	d002      	beq.n	8007f84 <USART_GetITStatus+0x9c>
  {
    bitstatus = SET;
 8007f7e:	2301      	movs	r3, #1
 8007f80:	74fb      	strb	r3, [r7, #19]
 8007f82:	e001      	b.n	8007f88 <USART_GetITStatus+0xa0>
  }
  else
  {
    bitstatus = RESET;
 8007f84:	2300      	movs	r3, #0
 8007f86:	74fb      	strb	r3, [r7, #19]
  }
  
  return bitstatus;  
 8007f88:	7cfb      	ldrb	r3, [r7, #19]
}
 8007f8a:	4618      	mov	r0, r3
 8007f8c:	f107 071c 	add.w	r7, r7, #28
 8007f90:	46bd      	mov	sp, r7
 8007f92:	bc80      	pop	{r7}
 8007f94:	4770      	bx	lr
 8007f96:	bf00      	nop

08007f98 <USART_ClearITPendingBit>:
  *          (USART_SendData()).
  *  
  * @retval None
  */
void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
{
 8007f98:	b480      	push	{r7}
 8007f9a:	b085      	sub	sp, #20
 8007f9c:	af00      	add	r7, sp, #0
 8007f9e:	6078      	str	r0, [r7, #4]
 8007fa0:	460b      	mov	r3, r1
 8007fa2:	807b      	strh	r3, [r7, #2]
  uint16_t bitpos = 0x00, itmask = 0x00;
 8007fa4:	2300      	movs	r3, #0
 8007fa6:	81fb      	strh	r3, [r7, #14]
 8007fa8:	2300      	movs	r3, #0
 8007faa:	81bb      	strh	r3, [r7, #12]
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  bitpos = USART_IT >> 0x08;
 8007fac:	887b      	ldrh	r3, [r7, #2]
 8007fae:	0a1b      	lsrs	r3, r3, #8
 8007fb0:	81fb      	strh	r3, [r7, #14]
  itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
 8007fb2:	89fb      	ldrh	r3, [r7, #14]
 8007fb4:	2201      	movs	r2, #1
 8007fb6:	fa02 f303 	lsl.w	r3, r2, r3
 8007fba:	81bb      	strh	r3, [r7, #12]
  USARTx->SR = (uint16_t)~itmask;
 8007fbc:	89bb      	ldrh	r3, [r7, #12]
 8007fbe:	43db      	mvns	r3, r3
 8007fc0:	b29a      	uxth	r2, r3
 8007fc2:	687b      	ldr	r3, [r7, #4]
 8007fc4:	801a      	strh	r2, [r3, #0]
}
 8007fc6:	f107 0714 	add.w	r7, r7, #20
 8007fca:	46bd      	mov	sp, r7
 8007fcc:	bc80      	pop	{r7}
 8007fce:	4770      	bx	lr

08007fd0 <leds_arch_init>:
#include "dev/leds.h"

/*---------------------------------------------------------------------------*/
void
leds_arch_init(void)
{
 8007fd0:	b580      	push	{r7, lr}
 8007fd2:	b082      	sub	sp, #8
 8007fd4:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD,ENABLE);
 8007fd6:	2008      	movs	r0, #8
 8007fd8:	2101      	movs	r1, #1
 8007fda:	f7ff fbe9 	bl	80077b0 <RCC_AHB1PeriphClockCmd>
	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_OUT;
 8007fde:	2301      	movs	r3, #1
 8007fe0:	713b      	strb	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
 8007fe2:	f44f 4370 	mov.w	r3, #61440	; 0xf000
 8007fe6:	603b      	str	r3, [r7, #0]
	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
 8007fe8:	2302      	movs	r3, #2
 8007fea:	717b      	strb	r3, [r7, #5]
	GPIO_Init(GPIOD,&GPIO_InitStructure);
 8007fec:	463b      	mov	r3, r7
 8007fee:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8007ff2:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8007ff6:	4619      	mov	r1, r3
 8007ff8:	f7ff fc52 	bl	80078a0 <GPIO_Init>
	GPIO_ResetBits(GPIOD, GPIO_Pin_12);
 8007ffc:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8008000:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8008004:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8008008:	f7ff fce6 	bl	80079d8 <GPIO_ResetBits>
	GPIO_ResetBits(GPIOD, GPIO_Pin_13);
 800800c:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8008010:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8008014:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8008018:	f7ff fcde 	bl	80079d8 <GPIO_ResetBits>
	GPIO_ResetBits(GPIOD, GPIO_Pin_14);
 800801c:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8008020:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8008024:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8008028:	f7ff fcd6 	bl	80079d8 <GPIO_ResetBits>
	GPIO_ResetBits(GPIOD, GPIO_Pin_15);
 800802c:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8008030:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8008034:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8008038:	f7ff fcce 	bl	80079d8 <GPIO_ResetBits>
}
 800803c:	f107 0708 	add.w	r7, r7, #8
 8008040:	46bd      	mov	sp, r7
 8008042:	bd80      	pop	{r7, pc}

08008044 <leds_arch_set>:
			((GPIOD->ODR & ((1u)<<13)) ? LEDS_GREEN : 0);
}
/*---------------------------------------------------------------------------*/
void
leds_arch_set(unsigned char leds)
{
 8008044:	b580      	push	{r7, lr}
 8008046:	b082      	sub	sp, #8
 8008048:	af00      	add	r7, sp, #0
 800804a:	4603      	mov	r3, r0
 800804c:	71fb      	strb	r3, [r7, #7]
	((leds & LEDS_RED) ? GPIO_SetBits(GPIOD, GPIO_Pin_12) : GPIO_ResetBits(GPIOD, GPIO_Pin_12));
 800804e:	79fb      	ldrb	r3, [r7, #7]
 8008050:	f003 0304 	and.w	r3, r3, #4
 8008054:	2b00      	cmp	r3, #0
 8008056:	d008      	beq.n	800806a <leds_arch_set+0x26>
 8008058:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 800805c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8008060:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8008064:	f7ff fcaa 	bl	80079bc <GPIO_SetBits>
 8008068:	e007      	b.n	800807a <leds_arch_set+0x36>
 800806a:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 800806e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8008072:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8008076:	f7ff fcaf 	bl	80079d8 <GPIO_ResetBits>
    ((leds & LEDS_GREEN) ? GPIO_SetBits(GPIOD, GPIO_Pin_13) : GPIO_ResetBits(GPIOD, GPIO_Pin_13));
 800807a:	79fb      	ldrb	r3, [r7, #7]
 800807c:	f003 0301 	and.w	r3, r3, #1
 8008080:	2b00      	cmp	r3, #0
 8008082:	d008      	beq.n	8008096 <leds_arch_set+0x52>
 8008084:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8008088:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800808c:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8008090:	f7ff fc94 	bl	80079bc <GPIO_SetBits>
 8008094:	e007      	b.n	80080a6 <leds_arch_set+0x62>
 8008096:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 800809a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800809e:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80080a2:	f7ff fc99 	bl	80079d8 <GPIO_ResetBits>
}
 80080a6:	f107 0708 	add.w	r7, r7, #8
 80080aa:	46bd      	mov	sp, r7
 80080ac:	bd80      	pop	{r7, pc}
 80080ae:	bf00      	nop

080080b0 <timer_set>:
 * \param interval The interval before the timer expires.
 *
 */
void
timer_set(struct timer *t, clock_time_t interval)
{
 80080b0:	b580      	push	{r7, lr}
 80080b2:	b082      	sub	sp, #8
 80080b4:	af00      	add	r7, sp, #0
 80080b6:	6078      	str	r0, [r7, #4]
 80080b8:	6039      	str	r1, [r7, #0]
  t->interval = interval;
 80080ba:	687b      	ldr	r3, [r7, #4]
 80080bc:	683a      	ldr	r2, [r7, #0]
 80080be:	605a      	str	r2, [r3, #4]
  t->start = clock_time();
 80080c0:	f7fb f8c2 	bl	8003248 <clock_time>
 80080c4:	4602      	mov	r2, r0
 80080c6:	687b      	ldr	r3, [r7, #4]
 80080c8:	601a      	str	r2, [r3, #0]
}
 80080ca:	f107 0708 	add.w	r7, r7, #8
 80080ce:	46bd      	mov	sp, r7
 80080d0:	bd80      	pop	{r7, pc}
 80080d2:	bf00      	nop

080080d4 <timer_reset>:
 *
 * \sa timer_restart()
 */
void
timer_reset(struct timer *t)
{
 80080d4:	b480      	push	{r7}
 80080d6:	b083      	sub	sp, #12
 80080d8:	af00      	add	r7, sp, #0
 80080da:	6078      	str	r0, [r7, #4]
  t->start += t->interval;
 80080dc:	687b      	ldr	r3, [r7, #4]
 80080de:	681a      	ldr	r2, [r3, #0]
 80080e0:	687b      	ldr	r3, [r7, #4]
 80080e2:	685b      	ldr	r3, [r3, #4]
 80080e4:	18d2      	adds	r2, r2, r3
 80080e6:	687b      	ldr	r3, [r7, #4]
 80080e8:	601a      	str	r2, [r3, #0]
}
 80080ea:	f107 070c 	add.w	r7, r7, #12
 80080ee:	46bd      	mov	sp, r7
 80080f0:	bc80      	pop	{r7}
 80080f2:	4770      	bx	lr

080080f4 <timer_restart>:
 *
 * \sa timer_reset()
 */
void
timer_restart(struct timer *t)
{
 80080f4:	b580      	push	{r7, lr}
 80080f6:	b082      	sub	sp, #8
 80080f8:	af00      	add	r7, sp, #0
 80080fa:	6078      	str	r0, [r7, #4]
  t->start = clock_time();
 80080fc:	f7fb f8a4 	bl	8003248 <clock_time>
 8008100:	4602      	mov	r2, r0
 8008102:	687b      	ldr	r3, [r7, #4]
 8008104:	601a      	str	r2, [r3, #0]
}
 8008106:	f107 0708 	add.w	r7, r7, #8
 800810a:	46bd      	mov	sp, r7
 800810c:	bd80      	pop	{r7, pc}
 800810e:	bf00      	nop

08008110 <timer_expired>:
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int
timer_expired(struct timer *t)
{
 8008110:	b580      	push	{r7, lr}
 8008112:	b084      	sub	sp, #16
 8008114:	af00      	add	r7, sp, #0
 8008116:	6078      	str	r0, [r7, #4]
  /* Note: Can not return diff >= t->interval so we add 1 to diff and return
     t->interval < diff - required to avoid an internal error in mspgcc. */
  clock_time_t diff = (clock_time() - t->start) + 1;
 8008118:	f7fb f896 	bl	8003248 <clock_time>
 800811c:	4602      	mov	r2, r0
 800811e:	687b      	ldr	r3, [r7, #4]
 8008120:	681b      	ldr	r3, [r3, #0]
 8008122:	1ad3      	subs	r3, r2, r3
 8008124:	3301      	adds	r3, #1
 8008126:	60fb      	str	r3, [r7, #12]
  return t->interval < diff;
 8008128:	687b      	ldr	r3, [r7, #4]
 800812a:	685a      	ldr	r2, [r3, #4]
 800812c:	68fb      	ldr	r3, [r7, #12]
 800812e:	429a      	cmp	r2, r3
 8008130:	bf2c      	ite	cs
 8008132:	2300      	movcs	r3, #0
 8008134:	2301      	movcc	r3, #1
 8008136:	b2db      	uxtb	r3, r3

}
 8008138:	4618      	mov	r0, r3
 800813a:	f107 0710 	add.w	r7, r7, #16
 800813e:	46bd      	mov	sp, r7
 8008140:	bd80      	pop	{r7, pc}
 8008142:	bf00      	nop

08008144 <printf>:
 8008144:	b40f      	push	{r0, r1, r2, r3}
 8008146:	b507      	push	{r0, r1, r2, lr}
 8008148:	aa04      	add	r2, sp, #16
 800814a:	f852 1b04 	ldr.w	r1, [r2], #4
 800814e:	2000      	movs	r0, #0
 8008150:	9201      	str	r2, [sp, #4]
 8008152:	f000 fafd 	bl	8008750 <vfiprintf>
 8008156:	e8bd 400e 	ldmia.w	sp!, {r1, r2, r3, lr}
 800815a:	b004      	add	sp, #16
 800815c:	4770      	bx	lr
	...

08008160 <_vfiprintf_r>:
 8008160:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008164:	b0b1      	sub	sp, #196	; 0xc4
 8008166:	9008      	str	r0, [sp, #32]
 8008168:	2000      	movs	r0, #0
 800816a:	468b      	mov	fp, r1
 800816c:	4691      	mov	r9, r2
 800816e:	461c      	mov	r4, r3
 8008170:	9007      	str	r0, [sp, #28]
 8008172:	9005      	str	r0, [sp, #20]
 8008174:	464b      	mov	r3, r9
 8008176:	461d      	mov	r5, r3
 8008178:	f813 2b01 	ldrb.w	r2, [r3], #1
 800817c:	b91a      	cbnz	r2, 8008186 <_vfiprintf_r+0x26>
 800817e:	ebb5 0609 	subs.w	r6, r5, r9
 8008182:	d00b      	beq.n	800819c <_vfiprintf_r+0x3c>
 8008184:	e002      	b.n	800818c <_vfiprintf_r+0x2c>
 8008186:	2a25      	cmp	r2, #37	; 0x25
 8008188:	d1f5      	bne.n	8008176 <_vfiprintf_r+0x16>
 800818a:	e7f8      	b.n	800817e <_vfiprintf_r+0x1e>
 800818c:	4631      	mov	r1, r6
 800818e:	4648      	mov	r0, r9
 8008190:	465a      	mov	r2, fp
 8008192:	f000 faeb 	bl	800876c <_SMALL_PRINTF_puts>
 8008196:	9905      	ldr	r1, [sp, #20]
 8008198:	1989      	adds	r1, r1, r6
 800819a:	9105      	str	r1, [sp, #20]
 800819c:	f995 3000 	ldrsb.w	r3, [r5]
 80081a0:	2b00      	cmp	r3, #0
 80081a2:	f000 82cb 	beq.w	800873c <_vfiprintf_r+0x5dc>
 80081a6:	2300      	movs	r3, #0
 80081a8:	f04f 0200 	mov.w	r2, #0
 80081ac:	f105 0901 	add.w	r9, r5, #1
 80081b0:	f88d 202f 	strb.w	r2, [sp, #47]	; 0x2f
 80081b4:	f04f 37ff 	mov.w	r7, #4294967295
 80081b8:	9304      	str	r3, [sp, #16]
 80081ba:	461d      	mov	r5, r3
 80081bc:	210a      	movs	r1, #10
 80081be:	e004      	b.n	80081ca <_vfiprintf_r+0x6a>
 80081c0:	4633      	mov	r3, r6
 80081c2:	e002      	b.n	80081ca <_vfiprintf_r+0x6a>
 80081c4:	4614      	mov	r4, r2
 80081c6:	f04f 37ff 	mov.w	r7, #4294967295
 80081ca:	f919 6b01 	ldrsb.w	r6, [r9], #1
 80081ce:	2e58      	cmp	r6, #88	; 0x58
 80081d0:	d053      	beq.n	800827a <_vfiprintf_r+0x11a>
 80081d2:	dc28      	bgt.n	8008226 <_vfiprintf_r+0xc6>
 80081d4:	2e39      	cmp	r6, #57	; 0x39
 80081d6:	dc14      	bgt.n	8008202 <_vfiprintf_r+0xa2>
 80081d8:	2e31      	cmp	r6, #49	; 0x31
 80081da:	da7d      	bge.n	80082d8 <_vfiprintf_r+0x178>
 80081dc:	2e2b      	cmp	r6, #43	; 0x2b
 80081de:	d0ef      	beq.n	80081c0 <_vfiprintf_r+0x60>
 80081e0:	dc07      	bgt.n	80081f2 <_vfiprintf_r+0x92>
 80081e2:	2e23      	cmp	r6, #35	; 0x23
 80081e4:	d050      	beq.n	8008288 <_vfiprintf_r+0x128>
 80081e6:	2e2a      	cmp	r6, #42	; 0x2a
 80081e8:	d051      	beq.n	800828e <_vfiprintf_r+0x12e>
 80081ea:	2e20      	cmp	r6, #32
 80081ec:	f040 81ef 	bne.w	80085ce <_vfiprintf_r+0x46e>
 80081f0:	e046      	b.n	8008280 <_vfiprintf_r+0x120>
 80081f2:	2e2e      	cmp	r6, #46	; 0x2e
 80081f4:	d056      	beq.n	80082a4 <_vfiprintf_r+0x144>
 80081f6:	2e30      	cmp	r6, #48	; 0x30
 80081f8:	d06b      	beq.n	80082d2 <_vfiprintf_r+0x172>
 80081fa:	2e2d      	cmp	r6, #45	; 0x2d
 80081fc:	f040 81e7 	bne.w	80085ce <_vfiprintf_r+0x46e>
 8008200:	e04d      	b.n	800829e <_vfiprintf_r+0x13e>
 8008202:	2e4f      	cmp	r6, #79	; 0x4f
 8008204:	f000 80d5 	beq.w	80083b2 <_vfiprintf_r+0x252>
 8008208:	dc06      	bgt.n	8008218 <_vfiprintf_r+0xb8>
 800820a:	2e43      	cmp	r6, #67	; 0x43
 800820c:	f000 8084 	beq.w	8008318 <_vfiprintf_r+0x1b8>
 8008210:	2e44      	cmp	r6, #68	; 0x44
 8008212:	f040 81dc 	bne.w	80085ce <_vfiprintf_r+0x46e>
 8008216:	e0a0      	b.n	800835a <_vfiprintf_r+0x1fa>
 8008218:	2e53      	cmp	r6, #83	; 0x53
 800821a:	f000 80e6 	beq.w	80083ea <_vfiprintf_r+0x28a>
 800821e:	2e55      	cmp	r6, #85	; 0x55
 8008220:	f040 81d5 	bne.w	80085ce <_vfiprintf_r+0x46e>
 8008224:	e154      	b.n	80084d0 <_vfiprintf_r+0x370>
 8008226:	2e6e      	cmp	r6, #110	; 0x6e
 8008228:	f000 80b0 	beq.w	800838c <_vfiprintf_r+0x22c>
 800822c:	dc0e      	bgt.n	800824c <_vfiprintf_r+0xec>
 800822e:	2e68      	cmp	r6, #104	; 0x68
 8008230:	d062      	beq.n	80082f8 <_vfiprintf_r+0x198>
 8008232:	dc05      	bgt.n	8008240 <_vfiprintf_r+0xe0>
 8008234:	2e63      	cmp	r6, #99	; 0x63
 8008236:	d06f      	beq.n	8008318 <_vfiprintf_r+0x1b8>
 8008238:	2e64      	cmp	r6, #100	; 0x64
 800823a:	f040 81c8 	bne.w	80085ce <_vfiprintf_r+0x46e>
 800823e:	e019      	b.n	8008274 <_vfiprintf_r+0x114>
 8008240:	2e69      	cmp	r6, #105	; 0x69
 8008242:	d017      	beq.n	8008274 <_vfiprintf_r+0x114>
 8008244:	2e6c      	cmp	r6, #108	; 0x6c
 8008246:	f040 81c2 	bne.w	80085ce <_vfiprintf_r+0x46e>
 800824a:	e058      	b.n	80082fe <_vfiprintf_r+0x19e>
 800824c:	2e71      	cmp	r6, #113	; 0x71
 800824e:	d060      	beq.n	8008312 <_vfiprintf_r+0x1b2>
 8008250:	dc06      	bgt.n	8008260 <_vfiprintf_r+0x100>
 8008252:	2e6f      	cmp	r6, #111	; 0x6f
 8008254:	f000 80af 	beq.w	80083b6 <_vfiprintf_r+0x256>
 8008258:	2e70      	cmp	r6, #112	; 0x70
 800825a:	f040 81b8 	bne.w	80085ce <_vfiprintf_r+0x46e>
 800825e:	e0bb      	b.n	80083d8 <_vfiprintf_r+0x278>
 8008260:	2e75      	cmp	r6, #117	; 0x75
 8008262:	f000 8137 	beq.w	80084d4 <_vfiprintf_r+0x374>
 8008266:	2e78      	cmp	r6, #120	; 0x78
 8008268:	f000 8142 	beq.w	80084f0 <_vfiprintf_r+0x390>
 800826c:	2e73      	cmp	r6, #115	; 0x73
 800826e:	f040 81ae 	bne.w	80085ce <_vfiprintf_r+0x46e>
 8008272:	e0ba      	b.n	80083ea <_vfiprintf_r+0x28a>
 8008274:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
 8008278:	e073      	b.n	8008362 <_vfiprintf_r+0x202>
 800827a:	4baa      	ldr	r3, [pc, #680]	; (8008524 <_vfiprintf_r+0x3c4>)
 800827c:	9307      	str	r3, [sp, #28]
 800827e:	e139      	b.n	80084f4 <_vfiprintf_r+0x394>
 8008280:	2b00      	cmp	r3, #0
 8008282:	bf08      	it	eq
 8008284:	2320      	moveq	r3, #32
 8008286:	e7a0      	b.n	80081ca <_vfiprintf_r+0x6a>
 8008288:	f045 0501 	orr.w	r5, r5, #1
 800828c:	e79d      	b.n	80081ca <_vfiprintf_r+0x6a>
 800828e:	1d22      	adds	r2, r4, #4
 8008290:	6824      	ldr	r4, [r4, #0]
 8008292:	2c00      	cmp	r4, #0
 8008294:	9404      	str	r4, [sp, #16]
 8008296:	da0d      	bge.n	80082b4 <_vfiprintf_r+0x154>
 8008298:	4260      	negs	r0, r4
 800829a:	9004      	str	r0, [sp, #16]
 800829c:	4614      	mov	r4, r2
 800829e:	f045 0504 	orr.w	r5, r5, #4
 80082a2:	e792      	b.n	80081ca <_vfiprintf_r+0x6a>
 80082a4:	f919 6b01 	ldrsb.w	r6, [r9], #1
 80082a8:	2e2a      	cmp	r6, #42	; 0x2a
 80082aa:	d10a      	bne.n	80082c2 <_vfiprintf_r+0x162>
 80082ac:	6827      	ldr	r7, [r4, #0]
 80082ae:	1d22      	adds	r2, r4, #4
 80082b0:	2f00      	cmp	r7, #0
 80082b2:	db87      	blt.n	80081c4 <_vfiprintf_r+0x64>
 80082b4:	4614      	mov	r4, r2
 80082b6:	e788      	b.n	80081ca <_vfiprintf_r+0x6a>
 80082b8:	fb01 2707 	mla	r7, r1, r7, r2
 80082bc:	f919 6b01 	ldrsb.w	r6, [r9], #1
 80082c0:	e000      	b.n	80082c4 <_vfiprintf_r+0x164>
 80082c2:	2700      	movs	r7, #0
 80082c4:	f1a6 0230 	sub.w	r2, r6, #48	; 0x30
 80082c8:	2a09      	cmp	r2, #9
 80082ca:	d9f5      	bls.n	80082b8 <_vfiprintf_r+0x158>
 80082cc:	ea47 77e7 	orr.w	r7, r7, r7, asr #31
 80082d0:	e77d      	b.n	80081ce <_vfiprintf_r+0x6e>
 80082d2:	f045 0580 	orr.w	r5, r5, #128	; 0x80
 80082d6:	e778      	b.n	80081ca <_vfiprintf_r+0x6a>
 80082d8:	2000      	movs	r0, #0
 80082da:	464a      	mov	r2, r9
 80082dc:	9004      	str	r0, [sp, #16]
 80082de:	9804      	ldr	r0, [sp, #16]
 80082e0:	3e30      	subs	r6, #48	; 0x30
 80082e2:	fb01 6000 	mla	r0, r1, r0, r6
 80082e6:	f912 6b01 	ldrsb.w	r6, [r2], #1
 80082ea:	9004      	str	r0, [sp, #16]
 80082ec:	f1a6 0030 	sub.w	r0, r6, #48	; 0x30
 80082f0:	2809      	cmp	r0, #9
 80082f2:	4691      	mov	r9, r2
 80082f4:	d9f3      	bls.n	80082de <_vfiprintf_r+0x17e>
 80082f6:	e76a      	b.n	80081ce <_vfiprintf_r+0x6e>
 80082f8:	f045 0540 	orr.w	r5, r5, #64	; 0x40
 80082fc:	e765      	b.n	80081ca <_vfiprintf_r+0x6a>
 80082fe:	f999 2000 	ldrsb.w	r2, [r9]
 8008302:	f045 0510 	orr.w	r5, r5, #16
 8008306:	2a6c      	cmp	r2, #108	; 0x6c
 8008308:	f47f af5f 	bne.w	80081ca <_vfiprintf_r+0x6a>
 800830c:	f109 0901 	add.w	r9, r9, #1
 8008310:	e75b      	b.n	80081ca <_vfiprintf_r+0x6a>
 8008312:	f045 0510 	orr.w	r5, r5, #16
 8008316:	e758      	b.n	80081ca <_vfiprintf_r+0x6a>
 8008318:	2e43      	cmp	r6, #67	; 0x43
 800831a:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
 800831e:	d001      	beq.n	8008324 <_vfiprintf_r+0x1c4>
 8008320:	06ef      	lsls	r7, r5, #27
 8008322:	d510      	bpl.n	8008346 <_vfiprintf_r+0x1e6>
 8008324:	2100      	movs	r1, #0
 8008326:	910e      	str	r1, [sp, #56]	; 0x38
 8008328:	910f      	str	r1, [sp, #60]	; 0x3c
 800832a:	9808      	ldr	r0, [sp, #32]
 800832c:	a912      	add	r1, sp, #72	; 0x48
 800832e:	6822      	ldr	r2, [r4, #0]
 8008330:	ab0e      	add	r3, sp, #56	; 0x38
 8008332:	f000 fab9 	bl	80088a8 <_wcrtomb_r>
 8008336:	4607      	mov	r7, r0
 8008338:	3001      	adds	r0, #1
 800833a:	f104 0804 	add.w	r8, r4, #4
 800833e:	f000 81fd 	beq.w	800873c <_vfiprintf_r+0x5dc>
 8008342:	4644      	mov	r4, r8
 8008344:	e004      	b.n	8008350 <_vfiprintf_r+0x1f0>
 8008346:	6823      	ldr	r3, [r4, #0]
 8008348:	2701      	movs	r7, #1
 800834a:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
 800834e:	3404      	adds	r4, #4
 8008350:	f04f 0200 	mov.w	r2, #0
 8008354:	f88d 202f 	strb.w	r2, [sp, #47]	; 0x2f
 8008358:	e143      	b.n	80085e2 <_vfiprintf_r+0x482>
 800835a:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
 800835e:	f045 0510 	orr.w	r5, r5, #16
 8008362:	f015 0f10 	tst.w	r5, #16
 8008366:	f104 0204 	add.w	r2, r4, #4
 800836a:	d001      	beq.n	8008370 <_vfiprintf_r+0x210>
 800836c:	6823      	ldr	r3, [r4, #0]
 800836e:	e004      	b.n	800837a <_vfiprintf_r+0x21a>
 8008370:	6823      	ldr	r3, [r4, #0]
 8008372:	f015 0f40 	tst.w	r5, #64	; 0x40
 8008376:	bf18      	it	ne
 8008378:	b21b      	sxthne	r3, r3
 800837a:	2b00      	cmp	r3, #0
 800837c:	4614      	mov	r4, r2
 800837e:	f280 80d5 	bge.w	800852c <_vfiprintf_r+0x3cc>
 8008382:	222d      	movs	r2, #45	; 0x2d
 8008384:	425b      	negs	r3, r3
 8008386:	f88d 202f 	strb.w	r2, [sp, #47]	; 0x2f
 800838a:	e0cf      	b.n	800852c <_vfiprintf_r+0x3cc>
 800838c:	f015 0f10 	tst.w	r5, #16
 8008390:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
 8008394:	f104 0304 	add.w	r3, r4, #4
 8008398:	d000      	beq.n	800839c <_vfiprintf_r+0x23c>
 800839a:	e005      	b.n	80083a8 <_vfiprintf_r+0x248>
 800839c:	0669      	lsls	r1, r5, #25
 800839e:	d503      	bpl.n	80083a8 <_vfiprintf_r+0x248>
 80083a0:	6822      	ldr	r2, [r4, #0]
 80083a2:	9905      	ldr	r1, [sp, #20]
 80083a4:	8011      	strh	r1, [r2, #0]
 80083a6:	e002      	b.n	80083ae <_vfiprintf_r+0x24e>
 80083a8:	6822      	ldr	r2, [r4, #0]
 80083aa:	9805      	ldr	r0, [sp, #20]
 80083ac:	6010      	str	r0, [r2, #0]
 80083ae:	461c      	mov	r4, r3
 80083b0:	e6e0      	b.n	8008174 <_vfiprintf_r+0x14>
 80083b2:	f045 0510 	orr.w	r5, r5, #16
 80083b6:	f015 0010 	ands.w	r0, r5, #16
 80083ba:	f104 0104 	add.w	r1, r4, #4
 80083be:	d003      	beq.n	80083c8 <_vfiprintf_r+0x268>
 80083c0:	6823      	ldr	r3, [r4, #0]
 80083c2:	460c      	mov	r4, r1
 80083c4:	2200      	movs	r2, #0
 80083c6:	e0a7      	b.n	8008518 <_vfiprintf_r+0x3b8>
 80083c8:	f015 0240 	ands.w	r2, r5, #64	; 0x40
 80083cc:	d001      	beq.n	80083d2 <_vfiprintf_r+0x272>
 80083ce:	8823      	ldrh	r3, [r4, #0]
 80083d0:	e7f7      	b.n	80083c2 <_vfiprintf_r+0x262>
 80083d2:	6823      	ldr	r3, [r4, #0]
 80083d4:	460c      	mov	r4, r1
 80083d6:	e09f      	b.n	8008518 <_vfiprintf_r+0x3b8>
 80083d8:	4953      	ldr	r1, [pc, #332]	; (8008528 <_vfiprintf_r+0x3c8>)
 80083da:	6823      	ldr	r3, [r4, #0]
 80083dc:	f045 0502 	orr.w	r5, r5, #2
 80083e0:	3404      	adds	r4, #4
 80083e2:	9107      	str	r1, [sp, #28]
 80083e4:	2202      	movs	r2, #2
 80083e6:	2678      	movs	r6, #120	; 0x78
 80083e8:	e096      	b.n	8008518 <_vfiprintf_r+0x3b8>
 80083ea:	4623      	mov	r3, r4
 80083ec:	f8d3 8000 	ldr.w	r8, [r3]
 80083f0:	f04f 0200 	mov.w	r2, #0
 80083f4:	46bc      	mov	ip, r7
 80083f6:	f88d 202f 	strb.w	r2, [sp, #47]	; 0x2f
 80083fa:	3404      	adds	r4, #4
 80083fc:	f1b8 0f00 	cmp.w	r8, #0
 8008400:	f000 80f4 	beq.w	80085ec <_vfiprintf_r+0x48c>
 8008404:	2e53      	cmp	r6, #83	; 0x53
 8008406:	d002      	beq.n	800840e <_vfiprintf_r+0x2ae>
 8008408:	f015 0a10 	ands.w	sl, r5, #16
 800840c:	d04c      	beq.n	80084a8 <_vfiprintf_r+0x348>
 800840e:	2000      	movs	r0, #0
 8008410:	4287      	cmp	r7, r0
 8008412:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
 8008416:	ab10      	add	r3, sp, #64	; 0x40
 8008418:	9010      	str	r0, [sp, #64]	; 0x40
 800841a:	9011      	str	r0, [sp, #68]	; 0x44
 800841c:	db19      	blt.n	8008452 <_vfiprintf_r+0x2f2>
 800841e:	4607      	mov	r7, r0
 8008420:	4682      	mov	sl, r0
 8008422:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008424:	f853 200a 	ldr.w	r2, [r3, sl]
 8008428:	b312      	cbz	r2, 8008470 <_vfiprintf_r+0x310>
 800842a:	9808      	ldr	r0, [sp, #32]
 800842c:	a912      	add	r1, sp, #72	; 0x48
 800842e:	ab10      	add	r3, sp, #64	; 0x40
 8008430:	f8cd c00c 	str.w	ip, [sp, #12]
 8008434:	f000 fa38 	bl	80088a8 <_wcrtomb_r>
 8008438:	1c42      	adds	r2, r0, #1
 800843a:	f8dd c00c 	ldr.w	ip, [sp, #12]
 800843e:	f000 817d 	beq.w	800873c <_vfiprintf_r+0x5dc>
 8008442:	19c0      	adds	r0, r0, r7
 8008444:	4560      	cmp	r0, ip
 8008446:	dc13      	bgt.n	8008470 <_vfiprintf_r+0x310>
 8008448:	f10a 0a04 	add.w	sl, sl, #4
 800844c:	d00f      	beq.n	800846e <_vfiprintf_r+0x30e>
 800844e:	4607      	mov	r7, r0
 8008450:	e7e7      	b.n	8008422 <_vfiprintf_r+0x2c2>
 8008452:	2100      	movs	r1, #0
 8008454:	9300      	str	r3, [sp, #0]
 8008456:	9808      	ldr	r0, [sp, #32]
 8008458:	460b      	mov	r3, r1
 800845a:	aa0d      	add	r2, sp, #52	; 0x34
 800845c:	f000 f9fc 	bl	8008858 <_wcsrtombs_r>
 8008460:	1c43      	adds	r3, r0, #1
 8008462:	4607      	mov	r7, r0
 8008464:	f000 816a 	beq.w	800873c <_vfiprintf_r+0x5dc>
 8008468:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
 800846c:	e000      	b.n	8008470 <_vfiprintf_r+0x310>
 800846e:	4667      	mov	r7, ip
 8008470:	b1c7      	cbz	r7, 80084a4 <_vfiprintf_r+0x344>
 8008472:	2100      	movs	r1, #0
 8008474:	ab10      	add	r3, sp, #64	; 0x40
 8008476:	9110      	str	r1, [sp, #64]	; 0x40
 8008478:	9111      	str	r1, [sp, #68]	; 0x44
 800847a:	9300      	str	r3, [sp, #0]
 800847c:	9808      	ldr	r0, [sp, #32]
 800847e:	a91c      	add	r1, sp, #112	; 0x70
 8008480:	aa0d      	add	r2, sp, #52	; 0x34
 8008482:	463b      	mov	r3, r7
 8008484:	f000 f9e8 	bl	8008858 <_wcsrtombs_r>
 8008488:	42b8      	cmp	r0, r7
 800848a:	f040 8157 	bne.w	800873c <_vfiprintf_r+0x5dc>
 800848e:	aa30      	add	r2, sp, #192	; 0xc0
 8008490:	19d3      	adds	r3, r2, r7
 8008492:	f04f 0000 	mov.w	r0, #0
 8008496:	f803 0c50 	strb.w	r0, [r3, #-80]
 800849a:	f04f 0a00 	mov.w	sl, #0
 800849e:	f10d 0870 	add.w	r8, sp, #112	; 0x70
 80084a2:	e0a9      	b.n	80085f8 <_vfiprintf_r+0x498>
 80084a4:	46ba      	mov	sl, r7
 80084a6:	e0a7      	b.n	80085f8 <_vfiprintf_r+0x498>
 80084a8:	2f00      	cmp	r7, #0
 80084aa:	4640      	mov	r0, r8
 80084ac:	db0c      	blt.n	80084c8 <_vfiprintf_r+0x368>
 80084ae:	4651      	mov	r1, sl
 80084b0:	463a      	mov	r2, r7
 80084b2:	f7f7 fee7 	bl	8000284 <memchr>
 80084b6:	2800      	cmp	r0, #0
 80084b8:	f000 809d 	beq.w	80085f6 <_vfiprintf_r+0x496>
 80084bc:	ebc8 0000 	rsb	r0, r8, r0
 80084c0:	42b8      	cmp	r0, r7
 80084c2:	f300 8099 	bgt.w	80085f8 <_vfiprintf_r+0x498>
 80084c6:	e001      	b.n	80084cc <_vfiprintf_r+0x36c>
 80084c8:	f7f7 ff48 	bl	800035c <strlen>
 80084cc:	4607      	mov	r7, r0
 80084ce:	e093      	b.n	80085f8 <_vfiprintf_r+0x498>
 80084d0:	f045 0510 	orr.w	r5, r5, #16
 80084d4:	f015 0f10 	tst.w	r5, #16
 80084d8:	f104 0204 	add.w	r2, r4, #4
 80084dc:	d000      	beq.n	80084e0 <_vfiprintf_r+0x380>
 80084de:	e003      	b.n	80084e8 <_vfiprintf_r+0x388>
 80084e0:	0668      	lsls	r0, r5, #25
 80084e2:	d501      	bpl.n	80084e8 <_vfiprintf_r+0x388>
 80084e4:	8823      	ldrh	r3, [r4, #0]
 80084e6:	e000      	b.n	80084ea <_vfiprintf_r+0x38a>
 80084e8:	6823      	ldr	r3, [r4, #0]
 80084ea:	4614      	mov	r4, r2
 80084ec:	2201      	movs	r2, #1
 80084ee:	e013      	b.n	8008518 <_vfiprintf_r+0x3b8>
 80084f0:	490d      	ldr	r1, [pc, #52]	; (8008528 <_vfiprintf_r+0x3c8>)
 80084f2:	9107      	str	r1, [sp, #28]
 80084f4:	f015 0f10 	tst.w	r5, #16
 80084f8:	f104 0204 	add.w	r2, r4, #4
 80084fc:	d000      	beq.n	8008500 <_vfiprintf_r+0x3a0>
 80084fe:	e003      	b.n	8008508 <_vfiprintf_r+0x3a8>
 8008500:	0669      	lsls	r1, r5, #25
 8008502:	d501      	bpl.n	8008508 <_vfiprintf_r+0x3a8>
 8008504:	8823      	ldrh	r3, [r4, #0]
 8008506:	e000      	b.n	800850a <_vfiprintf_r+0x3aa>
 8008508:	6823      	ldr	r3, [r4, #0]
 800850a:	4614      	mov	r4, r2
 800850c:	07ea      	lsls	r2, r5, #31
 800850e:	d502      	bpl.n	8008516 <_vfiprintf_r+0x3b6>
 8008510:	b10b      	cbz	r3, 8008516 <_vfiprintf_r+0x3b6>
 8008512:	f045 0502 	orr.w	r5, r5, #2
 8008516:	2202      	movs	r2, #2
 8008518:	f04f 0000 	mov.w	r0, #0
 800851c:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
 8008520:	e005      	b.n	800852e <_vfiprintf_r+0x3ce>
 8008522:	bf00      	nop
 8008524:	080092f8 	.word	0x080092f8
 8008528:	08009309 	.word	0x08009309
 800852c:	2201      	movs	r2, #1
 800852e:	2f00      	cmp	r7, #0
 8008530:	bfa8      	it	ge
 8008532:	f025 0580 	bicge.w	r5, r5, #128	; 0x80
 8008536:	b90b      	cbnz	r3, 800853c <_vfiprintf_r+0x3dc>
 8008538:	2f00      	cmp	r7, #0
 800853a:	d038      	beq.n	80085ae <_vfiprintf_r+0x44e>
 800853c:	2a01      	cmp	r2, #1
 800853e:	d002      	beq.n	8008546 <_vfiprintf_r+0x3e6>
 8008540:	2a02      	cmp	r2, #2
 8008542:	d103      	bne.n	800854c <_vfiprintf_r+0x3ec>
 8008544:	e027      	b.n	8008596 <_vfiprintf_r+0x436>
 8008546:	aa1c      	add	r2, sp, #112	; 0x70
 8008548:	210a      	movs	r1, #10
 800854a:	e01c      	b.n	8008586 <_vfiprintf_r+0x426>
 800854c:	f10d 026f 	add.w	r2, sp, #111	; 0x6f
 8008550:	f003 0107 	and.w	r1, r3, #7
 8008554:	3130      	adds	r1, #48	; 0x30
 8008556:	08db      	lsrs	r3, r3, #3
 8008558:	4690      	mov	r8, r2
 800855a:	7011      	strb	r1, [r2, #0]
 800855c:	f102 32ff 	add.w	r2, r2, #4294967295
 8008560:	d1f6      	bne.n	8008550 <_vfiprintf_r+0x3f0>
 8008562:	07e8      	lsls	r0, r5, #31
 8008564:	4643      	mov	r3, r8
 8008566:	d52d      	bpl.n	80085c4 <_vfiprintf_r+0x464>
 8008568:	2930      	cmp	r1, #48	; 0x30
 800856a:	d02b      	beq.n	80085c4 <_vfiprintf_r+0x464>
 800856c:	4690      	mov	r8, r2
 800856e:	2230      	movs	r2, #48	; 0x30
 8008570:	f803 2c01 	strb.w	r2, [r3, #-1]
 8008574:	e026      	b.n	80085c4 <_vfiprintf_r+0x464>
 8008576:	fbb3 f0f1 	udiv	r0, r3, r1
 800857a:	fb01 3310 	mls	r3, r1, r0, r3
 800857e:	3330      	adds	r3, #48	; 0x30
 8008580:	f802 3d01 	strb.w	r3, [r2, #-1]!
 8008584:	4603      	mov	r3, r0
 8008586:	2b09      	cmp	r3, #9
 8008588:	d8f5      	bhi.n	8008576 <_vfiprintf_r+0x416>
 800858a:	3330      	adds	r3, #48	; 0x30
 800858c:	f102 38ff 	add.w	r8, r2, #4294967295
 8008590:	f802 3c01 	strb.w	r3, [r2, #-1]
 8008594:	e016      	b.n	80085c4 <_vfiprintf_r+0x464>
 8008596:	f10d 026f 	add.w	r2, sp, #111	; 0x6f
 800859a:	9807      	ldr	r0, [sp, #28]
 800859c:	f003 010f 	and.w	r1, r3, #15
 80085a0:	5c41      	ldrb	r1, [r0, r1]
 80085a2:	091b      	lsrs	r3, r3, #4
 80085a4:	4690      	mov	r8, r2
 80085a6:	f802 1901 	strb.w	r1, [r2], #-1
 80085aa:	d1f6      	bne.n	800859a <_vfiprintf_r+0x43a>
 80085ac:	e00a      	b.n	80085c4 <_vfiprintf_r+0x464>
 80085ae:	b93a      	cbnz	r2, 80085c0 <_vfiprintf_r+0x460>
 80085b0:	07e8      	lsls	r0, r5, #31
 80085b2:	d505      	bpl.n	80085c0 <_vfiprintf_r+0x460>
 80085b4:	2330      	movs	r3, #48	; 0x30
 80085b6:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
 80085ba:	f10d 086f 	add.w	r8, sp, #111	; 0x6f
 80085be:	e001      	b.n	80085c4 <_vfiprintf_r+0x464>
 80085c0:	f10d 0870 	add.w	r8, sp, #112	; 0x70
 80085c4:	46ba      	mov	sl, r7
 80085c6:	af1c      	add	r7, sp, #112	; 0x70
 80085c8:	ebc8 0707 	rsb	r7, r8, r7
 80085cc:	e014      	b.n	80085f8 <_vfiprintf_r+0x498>
 80085ce:	2e00      	cmp	r6, #0
 80085d0:	f000 80b4 	beq.w	800873c <_vfiprintf_r+0x5dc>
 80085d4:	f04f 0000 	mov.w	r0, #0
 80085d8:	f88d 6048 	strb.w	r6, [sp, #72]	; 0x48
 80085dc:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
 80085e0:	2701      	movs	r7, #1
 80085e2:	f04f 0a00 	mov.w	sl, #0
 80085e6:	f10d 0848 	add.w	r8, sp, #72	; 0x48
 80085ea:	e005      	b.n	80085f8 <_vfiprintf_r+0x498>
 80085ec:	46c2      	mov	sl, r8
 80085ee:	2706      	movs	r7, #6
 80085f0:	f8df 8158 	ldr.w	r8, [pc, #344]	; 800874c <_vfiprintf_r+0x5ec>
 80085f4:	e000      	b.n	80085f8 <_vfiprintf_r+0x498>
 80085f6:	4682      	mov	sl, r0
 80085f8:	4557      	cmp	r7, sl
 80085fa:	bfac      	ite	ge
 80085fc:	463b      	movge	r3, r7
 80085fe:	4653      	movlt	r3, sl
 8008600:	9306      	str	r3, [sp, #24]
 8008602:	f99d 302f 	ldrsb.w	r3, [sp, #47]	; 0x2f
 8008606:	b113      	cbz	r3, 800860e <_vfiprintf_r+0x4ae>
 8008608:	9b06      	ldr	r3, [sp, #24]
 800860a:	3301      	adds	r3, #1
 800860c:	e003      	b.n	8008616 <_vfiprintf_r+0x4b6>
 800860e:	07a9      	lsls	r1, r5, #30
 8008610:	d502      	bpl.n	8008618 <_vfiprintf_r+0x4b8>
 8008612:	9b06      	ldr	r3, [sp, #24]
 8008614:	3302      	adds	r3, #2
 8008616:	9306      	str	r3, [sp, #24]
 8008618:	f015 0384 	ands.w	r3, r5, #132	; 0x84
 800861c:	9309      	str	r3, [sp, #36]	; 0x24
 800861e:	d11e      	bne.n	800865e <_vfiprintf_r+0x4fe>
 8008620:	9804      	ldr	r0, [sp, #16]
 8008622:	9906      	ldr	r1, [sp, #24]
 8008624:	1a43      	subs	r3, r0, r1
 8008626:	2b00      	cmp	r3, #0
 8008628:	dd19      	ble.n	800865e <_vfiprintf_r+0x4fe>
 800862a:	469c      	mov	ip, r3
 800862c:	e00c      	b.n	8008648 <_vfiprintf_r+0x4e8>
 800862e:	4845      	ldr	r0, [pc, #276]	; (8008744 <_vfiprintf_r+0x5e4>)
 8008630:	2110      	movs	r1, #16
 8008632:	465a      	mov	r2, fp
 8008634:	9302      	str	r3, [sp, #8]
 8008636:	f8cd c00c 	str.w	ip, [sp, #12]
 800863a:	f000 f897 	bl	800876c <_SMALL_PRINTF_puts>
 800863e:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8008642:	9b02      	ldr	r3, [sp, #8]
 8008644:	f1ac 0c10 	sub.w	ip, ip, #16
 8008648:	f1bc 0f10 	cmp.w	ip, #16
 800864c:	dcef      	bgt.n	800862e <_vfiprintf_r+0x4ce>
 800864e:	1e59      	subs	r1, r3, #1
 8008650:	f021 010f 	bic.w	r1, r1, #15
 8008654:	483b      	ldr	r0, [pc, #236]	; (8008744 <_vfiprintf_r+0x5e4>)
 8008656:	1a59      	subs	r1, r3, r1
 8008658:	465a      	mov	r2, fp
 800865a:	f000 f887 	bl	800876c <_SMALL_PRINTF_puts>
 800865e:	f99d 302f 	ldrsb.w	r3, [sp, #47]	; 0x2f
 8008662:	b11b      	cbz	r3, 800866c <_vfiprintf_r+0x50c>
 8008664:	f10d 002f 	add.w	r0, sp, #47	; 0x2f
 8008668:	2101      	movs	r1, #1
 800866a:	e009      	b.n	8008680 <_vfiprintf_r+0x520>
 800866c:	07aa      	lsls	r2, r5, #30
 800866e:	d50a      	bpl.n	8008686 <_vfiprintf_r+0x526>
 8008670:	2330      	movs	r3, #48	; 0x30
 8008672:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
 8008676:	f88d 6031 	strb.w	r6, [sp, #49]	; 0x31
 800867a:	eb0d 0003 	add.w	r0, sp, r3
 800867e:	2102      	movs	r1, #2
 8008680:	465a      	mov	r2, fp
 8008682:	f000 f873 	bl	800876c <_SMALL_PRINTF_puts>
 8008686:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008688:	2b80      	cmp	r3, #128	; 0x80
 800868a:	d118      	bne.n	80086be <_vfiprintf_r+0x55e>
 800868c:	9804      	ldr	r0, [sp, #16]
 800868e:	9b06      	ldr	r3, [sp, #24]
 8008690:	1ac6      	subs	r6, r0, r3
 8008692:	2e00      	cmp	r6, #0
 8008694:	dd13      	ble.n	80086be <_vfiprintf_r+0x55e>
 8008696:	4633      	mov	r3, r6
 8008698:	e007      	b.n	80086aa <_vfiprintf_r+0x54a>
 800869a:	482b      	ldr	r0, [pc, #172]	; (8008748 <_vfiprintf_r+0x5e8>)
 800869c:	2110      	movs	r1, #16
 800869e:	465a      	mov	r2, fp
 80086a0:	9302      	str	r3, [sp, #8]
 80086a2:	f000 f863 	bl	800876c <_SMALL_PRINTF_puts>
 80086a6:	9b02      	ldr	r3, [sp, #8]
 80086a8:	3b10      	subs	r3, #16
 80086aa:	2b10      	cmp	r3, #16
 80086ac:	dcf5      	bgt.n	800869a <_vfiprintf_r+0x53a>
 80086ae:	1e71      	subs	r1, r6, #1
 80086b0:	f021 010f 	bic.w	r1, r1, #15
 80086b4:	4824      	ldr	r0, [pc, #144]	; (8008748 <_vfiprintf_r+0x5e8>)
 80086b6:	1a71      	subs	r1, r6, r1
 80086b8:	465a      	mov	r2, fp
 80086ba:	f000 f857 	bl	800876c <_SMALL_PRINTF_puts>
 80086be:	ebc7 0a0a 	rsb	sl, r7, sl
 80086c2:	f1ba 0f00 	cmp.w	sl, #0
 80086c6:	dd13      	ble.n	80086f0 <_vfiprintf_r+0x590>
 80086c8:	4656      	mov	r6, sl
 80086ca:	e005      	b.n	80086d8 <_vfiprintf_r+0x578>
 80086cc:	481e      	ldr	r0, [pc, #120]	; (8008748 <_vfiprintf_r+0x5e8>)
 80086ce:	2110      	movs	r1, #16
 80086d0:	465a      	mov	r2, fp
 80086d2:	f000 f84b 	bl	800876c <_SMALL_PRINTF_puts>
 80086d6:	3e10      	subs	r6, #16
 80086d8:	2e10      	cmp	r6, #16
 80086da:	dcf7      	bgt.n	80086cc <_vfiprintf_r+0x56c>
 80086dc:	f10a 31ff 	add.w	r1, sl, #4294967295
 80086e0:	f021 010f 	bic.w	r1, r1, #15
 80086e4:	4818      	ldr	r0, [pc, #96]	; (8008748 <_vfiprintf_r+0x5e8>)
 80086e6:	ebc1 010a 	rsb	r1, r1, sl
 80086ea:	465a      	mov	r2, fp
 80086ec:	f000 f83e 	bl	800876c <_SMALL_PRINTF_puts>
 80086f0:	4640      	mov	r0, r8
 80086f2:	4639      	mov	r1, r7
 80086f4:	465a      	mov	r2, fp
 80086f6:	f000 f839 	bl	800876c <_SMALL_PRINTF_puts>
 80086fa:	076b      	lsls	r3, r5, #29
 80086fc:	d516      	bpl.n	800872c <_vfiprintf_r+0x5cc>
 80086fe:	9804      	ldr	r0, [sp, #16]
 8008700:	9b06      	ldr	r3, [sp, #24]
 8008702:	1ac5      	subs	r5, r0, r3
 8008704:	2d00      	cmp	r5, #0
 8008706:	dd11      	ble.n	800872c <_vfiprintf_r+0x5cc>
 8008708:	462e      	mov	r6, r5
 800870a:	e005      	b.n	8008718 <_vfiprintf_r+0x5b8>
 800870c:	480d      	ldr	r0, [pc, #52]	; (8008744 <_vfiprintf_r+0x5e4>)
 800870e:	2110      	movs	r1, #16
 8008710:	465a      	mov	r2, fp
 8008712:	f000 f82b 	bl	800876c <_SMALL_PRINTF_puts>
 8008716:	3e10      	subs	r6, #16
 8008718:	2e10      	cmp	r6, #16
 800871a:	dcf7      	bgt.n	800870c <_vfiprintf_r+0x5ac>
 800871c:	1e69      	subs	r1, r5, #1
 800871e:	f021 010f 	bic.w	r1, r1, #15
 8008722:	4808      	ldr	r0, [pc, #32]	; (8008744 <_vfiprintf_r+0x5e4>)
 8008724:	1a69      	subs	r1, r5, r1
 8008726:	465a      	mov	r2, fp
 8008728:	f000 f820 	bl	800876c <_SMALL_PRINTF_puts>
 800872c:	9805      	ldr	r0, [sp, #20]
 800872e:	9b06      	ldr	r3, [sp, #24]
 8008730:	9904      	ldr	r1, [sp, #16]
 8008732:	428b      	cmp	r3, r1
 8008734:	bfac      	ite	ge
 8008736:	18c0      	addge	r0, r0, r3
 8008738:	1840      	addlt	r0, r0, r1
 800873a:	e51a      	b.n	8008172 <_vfiprintf_r+0x12>
 800873c:	9805      	ldr	r0, [sp, #20]
 800873e:	b031      	add	sp, #196	; 0xc4
 8008740:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008744:	08009144 	.word	0x08009144
 8008748:	08009154 	.word	0x08009154
 800874c:	0800931a 	.word	0x0800931a

08008750 <vfiprintf>:
 8008750:	b530      	push	{r4, r5, lr}
 8008752:	4613      	mov	r3, r2
 8008754:	4a04      	ldr	r2, [pc, #16]	; (8008768 <vfiprintf+0x18>)
 8008756:	4605      	mov	r5, r0
 8008758:	460c      	mov	r4, r1
 800875a:	6810      	ldr	r0, [r2, #0]
 800875c:	4629      	mov	r1, r5
 800875e:	4622      	mov	r2, r4
 8008760:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8008764:	f7ff bcfc 	b.w	8008160 <_vfiprintf_r>
 8008768:	20000008 	.word	0x20000008

0800876c <_SMALL_PRINTF_puts>:
 800876c:	b538      	push	{r3, r4, r5, lr}
 800876e:	4604      	mov	r4, r0
 8008770:	b11a      	cbz	r2, 800877a <_SMALL_PRINTF_puts+0xe>
 8008772:	f9b2 300e 	ldrsh.w	r3, [r2, #14]
 8008776:	3301      	adds	r3, #1
 8008778:	d001      	beq.n	800877e <_SMALL_PRINTF_puts+0x12>
 800877a:	1865      	adds	r5, r4, r1
 800877c:	e013      	b.n	80087a6 <_SMALL_PRINTF_puts+0x3a>
 800877e:	8993      	ldrh	r3, [r2, #12]
 8008780:	f403 7302 	and.w	r3, r3, #520	; 0x208
 8008784:	2b00      	cmp	r3, #0
 8008786:	d0f8      	beq.n	800877a <_SMALL_PRINTF_puts+0xe>
 8008788:	6810      	ldr	r0, [r2, #0]
 800878a:	2300      	movs	r3, #0
 800878c:	e002      	b.n	8008794 <_SMALL_PRINTF_puts+0x28>
 800878e:	5ce5      	ldrb	r5, [r4, r3]
 8008790:	54c5      	strb	r5, [r0, r3]
 8008792:	3301      	adds	r3, #1
 8008794:	428b      	cmp	r3, r1
 8008796:	d1fa      	bne.n	800878e <_SMALL_PRINTF_puts+0x22>
 8008798:	18c3      	adds	r3, r0, r3
 800879a:	6013      	str	r3, [r2, #0]
 800879c:	bd38      	pop	{r3, r4, r5, pc}
 800879e:	f914 0b01 	ldrsb.w	r0, [r4], #1
 80087a2:	f7fa fadd 	bl	8002d60 <__io_putchar>
 80087a6:	42ac      	cmp	r4, r5
 80087a8:	d1f9      	bne.n	800879e <_SMALL_PRINTF_puts+0x32>
 80087aa:	bd38      	pop	{r3, r4, r5, pc}

080087ac <sprintf>:
 80087ac:	b40e      	push	{r1, r2, r3}
 80087ae:	b500      	push	{lr}
 80087b0:	f44f 7102 	mov.w	r1, #520	; 0x208
 80087b4:	b09c      	sub	sp, #112	; 0x70
 80087b6:	f8ad 1014 	strh.w	r1, [sp, #20]
 80087ba:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 80087be:	9104      	str	r1, [sp, #16]
 80087c0:	9107      	str	r1, [sp, #28]
 80087c2:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80087c6:	ab1d      	add	r3, sp, #116	; 0x74
 80087c8:	f8ad 1016 	strh.w	r1, [sp, #22]
 80087cc:	4908      	ldr	r1, [pc, #32]	; (80087f0 <sprintf+0x44>)
 80087ce:	f853 2b04 	ldr.w	r2, [r3], #4
 80087d2:	9002      	str	r0, [sp, #8]
 80087d4:	9006      	str	r0, [sp, #24]
 80087d6:	6808      	ldr	r0, [r1, #0]
 80087d8:	a902      	add	r1, sp, #8
 80087da:	9301      	str	r3, [sp, #4]
 80087dc:	f7ff fcc0 	bl	8008160 <_vfiprintf_r>
 80087e0:	9b02      	ldr	r3, [sp, #8]
 80087e2:	2200      	movs	r2, #0
 80087e4:	701a      	strb	r2, [r3, #0]
 80087e6:	b01c      	add	sp, #112	; 0x70
 80087e8:	f85d eb04 	ldr.w	lr, [sp], #4
 80087ec:	b003      	add	sp, #12
 80087ee:	4770      	bx	lr
 80087f0:	20000008 	.word	0x20000008

080087f4 <snprintf>:
 80087f4:	b40c      	push	{r2, r3}
 80087f6:	b530      	push	{r4, r5, lr}
 80087f8:	4b16      	ldr	r3, [pc, #88]	; (8008854 <snprintf+0x60>)
 80087fa:	1e0c      	subs	r4, r1, #0
 80087fc:	b09d      	sub	sp, #116	; 0x74
 80087fe:	681d      	ldr	r5, [r3, #0]
 8008800:	da04      	bge.n	800880c <snprintf+0x18>
 8008802:	238b      	movs	r3, #139	; 0x8b
 8008804:	602b      	str	r3, [r5, #0]
 8008806:	f04f 30ff 	mov.w	r0, #4294967295
 800880a:	e01e      	b.n	800884a <snprintf+0x56>
 800880c:	f44f 7302 	mov.w	r3, #520	; 0x208
 8008810:	f8ad 3014 	strh.w	r3, [sp, #20]
 8008814:	bf14      	ite	ne
 8008816:	f104 33ff 	addne.w	r3, r4, #4294967295
 800881a:	4623      	moveq	r3, r4
 800881c:	9304      	str	r3, [sp, #16]
 800881e:	9307      	str	r3, [sp, #28]
 8008820:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8008824:	9002      	str	r0, [sp, #8]
 8008826:	9006      	str	r0, [sp, #24]
 8008828:	f8ad 3016 	strh.w	r3, [sp, #22]
 800882c:	4628      	mov	r0, r5
 800882e:	ab21      	add	r3, sp, #132	; 0x84
 8008830:	a902      	add	r1, sp, #8
 8008832:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8008834:	9301      	str	r3, [sp, #4]
 8008836:	f7ff fc93 	bl	8008160 <_vfiprintf_r>
 800883a:	1c43      	adds	r3, r0, #1
 800883c:	bfbc      	itt	lt
 800883e:	238b      	movlt	r3, #139	; 0x8b
 8008840:	602b      	strlt	r3, [r5, #0]
 8008842:	b114      	cbz	r4, 800884a <snprintf+0x56>
 8008844:	9b02      	ldr	r3, [sp, #8]
 8008846:	2200      	movs	r2, #0
 8008848:	701a      	strb	r2, [r3, #0]
 800884a:	b01d      	add	sp, #116	; 0x74
 800884c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8008850:	b002      	add	sp, #8
 8008852:	4770      	bx	lr
 8008854:	20000008 	.word	0x20000008

08008858 <_wcsrtombs_r>:
 8008858:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 800885c:	2900      	cmp	r1, #0
 800885e:	bf08      	it	eq
 8008860:	f04f 33ff 	moveq.w	r3, #4294967295
 8008864:	6817      	ldr	r7, [r2, #0]
 8008866:	f89d c004 	ldrb.w	ip, [sp, #4]
 800886a:	460d      	mov	r5, r1
 800886c:	2400      	movs	r4, #0
 800886e:	f103 38ff 	add.w	r8, r3, #4294967295
 8008872:	e013      	b.n	800889c <_wcsrtombs_r+0x44>
 8008874:	4544      	cmp	r4, r8
 8008876:	d814      	bhi.n	80088a2 <_wcsrtombs_r+0x4a>
 8008878:	2b01      	cmp	r3, #1
 800887a:	d012      	beq.n	80088a2 <_wcsrtombs_r+0x4a>
 800887c:	b121      	cbz	r1, 8008888 <_wcsrtombs_r+0x30>
 800887e:	f805 cb01 	strb.w	ip, [r5], #1
 8008882:	6816      	ldr	r6, [r2, #0]
 8008884:	3604      	adds	r6, #4
 8008886:	6016      	str	r6, [r2, #0]
 8008888:	f857 6024 	ldr.w	r6, [r7, r4, lsl #2]
 800888c:	3401      	adds	r4, #1
 800888e:	b92e      	cbnz	r6, 800889c <_wcsrtombs_r+0x44>
 8008890:	b101      	cbz	r1, 8008894 <_wcsrtombs_r+0x3c>
 8008892:	6016      	str	r6, [r2, #0]
 8008894:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008896:	2200      	movs	r2, #0
 8008898:	601a      	str	r2, [r3, #0]
 800889a:	e002      	b.n	80088a2 <_wcsrtombs_r+0x4a>
 800889c:	429c      	cmp	r4, r3
 800889e:	4620      	mov	r0, r4
 80088a0:	d3e8      	bcc.n	8008874 <_wcsrtombs_r+0x1c>
 80088a2:	b004      	add	sp, #16
 80088a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080088a8 <_wcrtomb_r>:
 80088a8:	2001      	movs	r0, #1
 80088aa:	4770      	bx	lr
 80088ac:	6c656853 	.word	0x6c656853
 80088b0:	6e69206c 	.word	0x6e69206c
 80088b4:	70207469 	.word	0x70207469
 80088b8:	65636f72 	.word	0x65636f72
 80088bc:	00007373 	.word	0x00007373
 80088c0:	6e6c6554 	.word	0x6e6c6554
 80088c4:	73207465 	.word	0x73207465
 80088c8:	65767265 	.word	0x65767265
 80088cc:	00000072 	.word	0x00000072
 80088d0:	00000a0d 	.word	0x00000a0d
 80088d4:	6c656853 	.word	0x6c656853
 80088d8:	0000006c 	.word	0x0000006c
 80088dc:	6c656853 	.word	0x6c656853
 80088e0:	6573206c 	.word	0x6573206c
 80088e4:	72657672 	.word	0x72657672
 80088e8:	00000000 	.word	0x00000000
 80088ec:	706c6568 	.word	0x706c6568
 80088f0:	00000000 	.word	0x00000000
 80088f4:	706c6568 	.word	0x706c6568
 80088f8:	6873203a 	.word	0x6873203a
 80088fc:	2073776f 	.word	0x2073776f
 8008900:	73696874 	.word	0x73696874
 8008904:	6c656820 	.word	0x6c656820
 8008908:	00000070 	.word	0x00000070
 800890c:	0000003f 	.word	0x0000003f
 8008910:	73203a3f 	.word	0x73203a3f
 8008914:	73776f68 	.word	0x73776f68
 8008918:	69687420 	.word	0x69687420
 800891c:	65682073 	.word	0x65682073
 8008920:	0000706c 	.word	0x0000706c
 8008924:	6c6c696b 	.word	0x6c6c696b
 8008928:	006c6c61 	.word	0x006c6c61
 800892c:	6c6c696b 	.word	0x6c6c696b
 8008930:	3a6c6c61 	.word	0x3a6c6c61
 8008934:	6f747320 	.word	0x6f747320
 8008938:	6c612070 	.word	0x6c612070
 800893c:	7572206c 	.word	0x7572206c
 8008940:	6e696e6e 	.word	0x6e696e6e
 8008944:	6f632067 	.word	0x6f632067
 8008948:	6e616d6d 	.word	0x6e616d6d
 800894c:	00007364 	.word	0x00007364
 8008950:	6c6c696b 	.word	0x6c6c696b
 8008954:	00000000 	.word	0x00000000
 8008958:	6c6c696b 	.word	0x6c6c696b
 800895c:	6f633c20 	.word	0x6f633c20
 8008960:	6e616d6d 	.word	0x6e616d6d
 8008964:	203a3e64 	.word	0x203a3e64
 8008968:	706f7473 	.word	0x706f7473
 800896c:	73206120 	.word	0x73206120
 8008970:	69636570 	.word	0x69636570
 8008974:	20636966 	.word	0x20636966
 8008978:	6d6d6f63 	.word	0x6d6d6f63
 800897c:	00646e61 	.word	0x00646e61
 8008980:	6c6c756e 	.word	0x6c6c756e
 8008984:	00000000 	.word	0x00000000
 8008988:	6c6c756e 	.word	0x6c6c756e
 800898c:	6964203a 	.word	0x6964203a
 8008990:	72616373 	.word	0x72616373
 8008994:	6e692064 	.word	0x6e692064
 8008998:	00747570 	.word	0x00747570
 800899c:	74697865 	.word	0x74697865
 80089a0:	00000000 	.word	0x00000000
 80089a4:	74697865 	.word	0x74697865
 80089a8:	7865203a 	.word	0x7865203a
 80089ac:	73207469 	.word	0x73207469
 80089b0:	6c6c6568 	.word	0x6c6c6568
 80089b4:	00000000 	.word	0x00000000
 80089b8:	74697571 	.word	0x74697571
 80089bc:	00000000 	.word	0x00000000
 80089c0:	74697571 	.word	0x74697571
 80089c4:	7865203a 	.word	0x7865203a
 80089c8:	73207469 	.word	0x73207469
 80089cc:	6c6c6568 	.word	0x6c6c6568
 80089d0:	00000000 	.word	0x00000000
 80089d4:	706f7453 	.word	0x706f7453
 80089d8:	676e6970 	.word	0x676e6970
 80089dc:	6d6f6320 	.word	0x6d6f6320
 80089e0:	646e616d 	.word	0x646e616d
 80089e4:	00000020 	.word	0x00000020
 80089e8:	6c6c696b 	.word	0x6c6c696b
 80089ec:	6f633c20 	.word	0x6f633c20
 80089f0:	6e616d6d 	.word	0x6e616d6d
 80089f4:	203a3e64 	.word	0x203a3e64
 80089f8:	6d6d6f63 	.word	0x6d6d6f63
 80089fc:	20646e61 	.word	0x20646e61
 8008a00:	656d616e 	.word	0x656d616e
 8008a04:	73756d20 	.word	0x73756d20
 8008a08:	65622074 	.word	0x65622074
 8008a0c:	76696720 	.word	0x76696720
 8008a10:	00006e65 	.word	0x00006e65
 8008a14:	00000000 	.word	0x00000000
 8008a18:	6d6d6f43 	.word	0x6d6d6f43
 8008a1c:	20646e61 	.word	0x20646e61
 8008a20:	20746f6e 	.word	0x20746f6e
 8008a24:	6e756f66 	.word	0x6e756f66
 8008a28:	00203a64 	.word	0x00203a64
 8008a2c:	69617641 	.word	0x69617641
 8008a30:	6c62616c 	.word	0x6c62616c
 8008a34:	6f632065 	.word	0x6f632065
 8008a38:	6e616d6d 	.word	0x6e616d6d
 8008a3c:	003a7364 	.word	0x003a7364
 8008a40:	6f63203a 	.word	0x6f63203a
 8008a44:	6e616d6d 	.word	0x6e616d6d
 8008a48:	6f6e2064 	.word	0x6f6e2064
 8008a4c:	6f662074 	.word	0x6f662074
 8008a50:	20646e75 	.word	0x20646e75
 8008a54:	79727428 	.word	0x79727428
 8008a58:	65682720 	.word	0x65682720
 8008a5c:	2927706c 	.word	0x2927706c
 8008a60:	00000000 	.word	0x00000000
 8008a64:	6f63203a 	.word	0x6f63203a
 8008a68:	6e616d6d 	.word	0x6e616d6d
 8008a6c:	6c612064 	.word	0x6c612064
 8008a70:	64616572 	.word	0x64616572
 8008a74:	75722079 	.word	0x75722079
 8008a78:	6e696e6e 	.word	0x6e696e6e
 8008a7c:	00000067 	.word	0x00000067
 8008a80:	65707954 	.word	0x65707954
 8008a84:	273f2720 	.word	0x273f2720
 8008a88:	646e6120 	.word	0x646e6120
 8008a8c:	74657220 	.word	0x74657220
 8008a90:	206e7275 	.word	0x206e7275
 8008a94:	20726f66 	.word	0x20726f66
 8008a98:	706c6568 	.word	0x706c6568
 8008a9c:	00000000 	.word	0x00000000
 8008aa0:	00007370 	.word	0x00007370
 8008aa4:	203a7370 	.word	0x203a7370
 8008aa8:	7473696c 	.word	0x7473696c
 8008aac:	6c6c6120 	.word	0x6c6c6120
 8008ab0:	6e757220 	.word	0x6e757220
 8008ab4:	676e696e 	.word	0x676e696e
 8008ab8:	6f727020 	.word	0x6f727020
 8008abc:	73736563 	.word	0x73736563
 8008ac0:	00007365 	.word	0x00007365
 8008ac4:	636f7250 	.word	0x636f7250
 8008ac8:	65737365 	.word	0x65737365
 8008acc:	00003a73 	.word	0x00003a73
 8008ad0:	00000000 	.word	0x00000000
 8008ad4:	6e696c62 	.word	0x6e696c62
 8008ad8:	0000006b 	.word	0x0000006b
 8008adc:	6e696c62 	.word	0x6e696c62
 8008ae0:	6e5b206b 	.word	0x6e5b206b
 8008ae4:	3a5d6d75 	.word	0x3a5d6d75
 8008ae8:	696c6220 	.word	0x696c6220
 8008aec:	4c206b6e 	.word	0x4c206b6e
 8008af0:	20734445 	.word	0x20734445
 8008af4:	756e5b28 	.word	0x756e5b28
 8008af8:	74205d6d 	.word	0x74205d6d
 8008afc:	73656d69 	.word	0x73656d69
 8008b00:	00000029 	.word	0x00000029
 8008b04:	6f686365 	.word	0x6f686365
 8008b08:	00000000 	.word	0x00000000
 8008b0c:	6f686365 	.word	0x6f686365
 8008b10:	65743c20 	.word	0x65743c20
 8008b14:	3a3e7478 	.word	0x3a3e7478
 8008b18:	69727020 	.word	0x69727020
 8008b1c:	3c20746e 	.word	0x3c20746e
 8008b20:	74786574 	.word	0x74786574
 8008b24:	0000003e 	.word	0x0000003e
 8008b28:	706e6962 	.word	0x706e6962
 8008b2c:	746e6972 	.word	0x746e6972
 8008b30:	00000000 	.word	0x00000000
 8008b34:	706e6962 	.word	0x706e6962
 8008b38:	746e6972 	.word	0x746e6972
 8008b3c:	7270203a 	.word	0x7270203a
 8008b40:	20746e69 	.word	0x20746e69
 8008b44:	616e6962 	.word	0x616e6962
 8008b48:	64207972 	.word	0x64207972
 8008b4c:	20617461 	.word	0x20617461
 8008b50:	64206e69 	.word	0x64206e69
 8008b54:	6d696365 	.word	0x6d696365
 8008b58:	66206c61 	.word	0x66206c61
 8008b5c:	616d726f 	.word	0x616d726f
 8008b60:	00000074 	.word	0x00000074
 8008b64:	00006468 	.word	0x00006468
 8008b68:	203a6468 	.word	0x203a6468
 8008b6c:	6e697270 	.word	0x6e697270
 8008b70:	69622074 	.word	0x69622074
 8008b74:	7972616e 	.word	0x7972616e
 8008b78:	74616420 	.word	0x74616420
 8008b7c:	6e692061 	.word	0x6e692061
 8008b80:	78656820 	.word	0x78656820
 8008b84:	63656461 	.word	0x63656461
 8008b88:	6c616d69 	.word	0x6c616d69
 8008b8c:	726f6620 	.word	0x726f6620
 8008b90:	0074616d 	.word	0x0074616d
 8008b94:	657a6973 	.word	0x657a6973
 8008b98:	00000000 	.word	0x00000000
 8008b9c:	657a6973 	.word	0x657a6973
 8008ba0:	7270203a 	.word	0x7270203a
 8008ba4:	20746e69 	.word	0x20746e69
 8008ba8:	20656874 	.word	0x20656874
 8008bac:	657a6973 	.word	0x657a6973
 8008bb0:	20666f20 	.word	0x20666f20
 8008bb4:	20656874 	.word	0x20656874
 8008bb8:	75706e69 	.word	0x75706e69
 8008bbc:	00000074 	.word	0x00000074
 8008bc0:	00000000 	.word	0x00000000
 8008bc4:	30257830 	.word	0x30257830
 8008bc8:	00207834 	.word	0x00207834
 8008bcc:	00207525 	.word	0x00207525
 8008bd0:	00756c25 	.word	0x00756c25
 8008bd4:	656d6974 	.word	0x656d6974
 8008bd8:	00000000 	.word	0x00000000
 8008bdc:	656d6974 	.word	0x656d6974
 8008be0:	65735b20 	.word	0x65735b20
 8008be4:	646e6f63 	.word	0x646e6f63
 8008be8:	203a5d73 	.word	0x203a5d73
 8008bec:	7074756f 	.word	0x7074756f
 8008bf0:	74207475 	.word	0x74207475
 8008bf4:	20656d69 	.word	0x20656d69
 8008bf8:	62206e69 	.word	0x62206e69
 8008bfc:	72616e69 	.word	0x72616e69
 8008c00:	6f662079 	.word	0x6f662079
 8008c04:	74616d72 	.word	0x74616d72
 8008c08:	726f202c 	.word	0x726f202c
 8008c0c:	74657320 	.word	0x74657320
 8008c10:	6d697420 	.word	0x6d697420
 8008c14:	6e692065 	.word	0x6e692065
 8008c18:	63657320 	.word	0x63657320
 8008c1c:	73646e6f 	.word	0x73646e6f
 8008c20:	6e697320 	.word	0x6e697320
 8008c24:	31206563 	.word	0x31206563
 8008c28:	00303739 	.word	0x00303739
 8008c2c:	656d6974 	.word	0x656d6974
 8008c30:	6d617473 	.word	0x6d617473
 8008c34:	00000070 	.word	0x00000070
 8008c38:	656d6974 	.word	0x656d6974
 8008c3c:	6d617473 	.word	0x6d617473
 8008c40:	70203a70 	.word	0x70203a70
 8008c44:	65706572 	.word	0x65706572
 8008c48:	6120646e 	.word	0x6120646e
 8008c4c:	6d697420 	.word	0x6d697420
 8008c50:	61747365 	.word	0x61747365
 8008c54:	7420706d 	.word	0x7420706d
 8008c58:	6164206f 	.word	0x6164206f
 8008c5c:	00006174 	.word	0x00006174
 8008c60:	65706572 	.word	0x65706572
 8008c64:	00007461 	.word	0x00007461
 8008c68:	65706572 	.word	0x65706572
 8008c6c:	73207461 	.word	0x73207461
 8008c70:	65767265 	.word	0x65767265
 8008c74:	00000072 	.word	0x00000072
 8008c78:	65706572 	.word	0x65706572
 8008c7c:	3c207461 	.word	0x3c207461
 8008c80:	3e6d756e 	.word	0x3e6d756e
 8008c84:	69743c20 	.word	0x69743c20
 8008c88:	203e656d 	.word	0x203e656d
 8008c8c:	6d6f633c 	.word	0x6d6f633c
 8008c90:	646e616d 	.word	0x646e616d
 8008c94:	72203a3e 	.word	0x72203a3e
 8008c98:	61206e75 	.word	0x61206e75
 8008c9c:	6d6f6320 	.word	0x6d6f6320
 8008ca0:	646e616d 	.word	0x646e616d
 8008ca4:	65766520 	.word	0x65766520
 8008ca8:	3c207972 	.word	0x3c207972
 8008cac:	656d6974 	.word	0x656d6974
 8008cb0:	6573203e 	.word	0x6573203e
 8008cb4:	646e6f63 	.word	0x646e6f63
 8008cb8:	00000073 	.word	0x00000073
 8008cbc:	646e6172 	.word	0x646e6172
 8008cc0:	74696177 	.word	0x74696177
 8008cc4:	00000000 	.word	0x00000000
 8008cc8:	646e6172 	.word	0x646e6172
 8008ccc:	74696177 	.word	0x74696177
 8008cd0:	616d3c20 	.word	0x616d3c20
 8008cd4:	6d697478 	.word	0x6d697478
 8008cd8:	3c203e65 	.word	0x3c203e65
 8008cdc:	6d6d6f63 	.word	0x6d6d6f63
 8008ce0:	3e646e61 	.word	0x3e646e61
 8008ce4:	6177203a 	.word	0x6177203a
 8008ce8:	66207469 	.word	0x66207469
 8008cec:	6120726f 	.word	0x6120726f
 8008cf0:	6e617220 	.word	0x6e617220
 8008cf4:	206d6f64 	.word	0x206d6f64
 8008cf8:	656d6974 	.word	0x656d6974
 8008cfc:	66656220 	.word	0x66656220
 8008d00:	2065726f 	.word	0x2065726f
 8008d04:	6e6e7572 	.word	0x6e6e7572
 8008d08:	20676e69 	.word	0x20676e69
 8008d0c:	6f632061 	.word	0x6f632061
 8008d10:	6e616d6d 	.word	0x6e616d6d
 8008d14:	00000064 	.word	0x00000064
 8008d18:	00000000 	.word	0x00000000
 8008d1c:	67617375 	.word	0x67617375
 8008d20:	00203a65 	.word	0x00203a65
 8008d24:	67617375 	.word	0x67617375
 8008d28:	00302065 	.word	0x00302065
 8008d2c:	67617375 	.word	0x67617375
 8008d30:	00312065 	.word	0x00312065
 8008d34:	67617375 	.word	0x67617375
 8008d38:	00332065 	.word	0x00332065
 8008d3c:	006e7572 	.word	0x006e7572
 8008d40:	3a6e7572 	.word	0x3a6e7572
 8008d44:	616f6c20 	.word	0x616f6c20
 8008d48:	6e612064 	.word	0x6e612064
 8008d4c:	75722064 	.word	0x75722064
 8008d50:	2061206e 	.word	0x2061206e
 8008d54:	20475250 	.word	0x20475250
 8008d58:	656c6966 	.word	0x656c6966
 8008d5c:	00000000 	.word	0x00000000
 8008d60:	206e7572 	.word	0x206e7572
 8008d64:	6c69663c 	.word	0x6c69663c
 8008d68:	203a3e65 	.word	0x203a3e65
 8008d6c:	656c6966 	.word	0x656c6966
 8008d70:	656d616e 	.word	0x656d616e
 8008d74:	73756d20 	.word	0x73756d20
 8008d78:	65622074 	.word	0x65622074
 8008d7c:	76696720 	.word	0x76696720
 8008d80:	00006e65 	.word	0x00006e65
 8008d84:	00000000 	.word	0x00000000
 8008d88:	676f7250 	.word	0x676f7250
 8008d8c:	206d6172 	.word	0x206d6172
 8008d90:	64616f6c 	.word	0x64616f6c
 8008d94:	20676e69 	.word	0x20676e69
 8008d98:	20746f6e 	.word	0x20746f6e
 8008d9c:	70707573 	.word	0x70707573
 8008da0:	6574726f 	.word	0x6574726f
 8008da4:	00000064 	.word	0x00000064
 8008da8:	0000002e 	.word	0x0000002e
 8008dac:	676e6970 	.word	0x676e6970
 8008db0:	00000000 	.word	0x00000000
 8008db4:	676e6970 	.word	0x676e6970
 8008db8:	6f683c20 	.word	0x6f683c20
 8008dbc:	3a3e7473 	.word	0x3a3e7473
 8008dc0:	6e697020 	.word	0x6e697020
 8008dc4:	6e612067 	.word	0x6e612067
 8008dc8:	20504920 	.word	0x20504920
 8008dcc:	74736f68 	.word	0x74736f68
 8008dd0:	00000000 	.word	0x00000000
 8008dd4:	676e6970 	.word	0x676e6970
 8008dd8:	65733c20 	.word	0x65733c20
 8008ddc:	72657672 	.word	0x72657672
 8008de0:	73203a3e 	.word	0x73203a3e
 8008de4:	65767265 	.word	0x65767265
 8008de8:	73612072 	.word	0x73612072
 8008dec:	64646120 	.word	0x64646120
 8008df0:	73736572 	.word	0x73736572
	...
 8008dfc:	7374656e 	.word	0x7374656e
 8008e00:	00746174 	.word	0x00746174
 8008e04:	7374656e 	.word	0x7374656e
 8008e08:	3a746174 	.word	0x3a746174
 8008e0c:	6f687320 	.word	0x6f687320
 8008e10:	44552077 	.word	0x44552077
 8008e14:	6e612050 	.word	0x6e612050
 8008e18:	43542064 	.word	0x43542064
 8008e1c:	6f632050 	.word	0x6f632050
 8008e20:	63656e6e 	.word	0x63656e6e
 8008e24:	6e6f6974 	.word	0x6e6f6974
 8008e28:	00000073 	.word	0x00000073
 8008e2c:	202c6425 	.word	0x202c6425
 8008e30:	252e7525 	.word	0x252e7525
 8008e34:	75252e75 	.word	0x75252e75
 8008e38:	3a75252e 	.word	0x3a75252e
 8008e3c:	202c7525 	.word	0x202c7525
 8008e40:	202c7325 	.word	0x202c7325
 8008e44:	202c7525 	.word	0x202c7525
 8008e48:	202c7525 	.word	0x202c7525
 8008e4c:	25206325 	.word	0x25206325
 8008e50:	00000063 	.word	0x00000063
 8008e54:	20504354 	.word	0x20504354
 8008e58:	00000000 	.word	0x00000000
 8008e5c:	656b6f70 	.word	0x656b6f70
 8008e60:	00000000 	.word	0x00000000
 8008e64:	656b6f70 	.word	0x656b6f70
 8008e68:	64613c20 	.word	0x64613c20
 8008e6c:	73657264 	.word	0x73657264
 8008e70:	3c203e73 	.word	0x3c203e73
 8008e74:	65747962 	.word	0x65747962
 8008e78:	77203a3e 	.word	0x77203a3e
 8008e7c:	65746972 	.word	0x65746972
 8008e80:	74796220 	.word	0x74796220
 8008e84:	623c2065 	.word	0x623c2065
 8008e88:	3e657479 	.word	0x3e657479
 8008e8c:	206f7420 	.word	0x206f7420
 8008e90:	72646461 	.word	0x72646461
 8008e94:	20737365 	.word	0x20737365
 8008e98:	6464613c 	.word	0x6464613c
 8008e9c:	73736572 	.word	0x73736572
 8008ea0:	0000003e 	.word	0x0000003e
 8008ea4:	6b656570 	.word	0x6b656570
 8008ea8:	00000000 	.word	0x00000000
 8008eac:	6b656570 	.word	0x6b656570
 8008eb0:	64613c20 	.word	0x64613c20
 8008eb4:	73657264 	.word	0x73657264
 8008eb8:	203a3e73 	.word	0x203a3e73
 8008ebc:	64616572 	.word	0x64616572
 8008ec0:	62206120 	.word	0x62206120
 8008ec4:	20657479 	.word	0x20657479
 8008ec8:	6d6f7266 	.word	0x6d6f7266
 8008ecc:	64646120 	.word	0x64646120
 8008ed0:	73736572 	.word	0x73736572
 8008ed4:	64613c20 	.word	0x64613c20
 8008ed8:	73657264 	.word	0x73657264
 8008edc:	00003e73 	.word	0x00003e73
 8008ee0:	67617375 	.word	0x67617375
 8008ee4:	00302065 	.word	0x00302065
 8008ee8:	00000000 	.word	0x00000000
 8008eec:	67617375 	.word	0x67617375
 8008ef0:	00312065 	.word	0x00312065
 8008ef4:	67617375 	.word	0x67617375
 8008ef8:	00322065 	.word	0x00322065
 8008efc:	72646461 	.word	0x72646461
 8008f00:	20737365 	.word	0x20737365
 8008f04:	62207025 	.word	0x62207025
 8008f08:	20657479 	.word	0x20657479
 8008f0c:	30257830 	.word	0x30257830
 8008f10:	000a7832 	.word	0x000a7832
 8008f14:	30257830 	.word	0x30257830
 8008f18:	00007832 	.word	0x00007832
 8008f1c:	00000d0a 	.word	0x00000d0a
 8008f20:	50494c53 	.word	0x50494c53
 8008f24:	69726420 	.word	0x69726420
 8008f28:	00726576 	.word	0x00726576
 8008f2c:	45494c43 	.word	0x45494c43
 8008f30:	0000544e 	.word	0x0000544e
 8008f34:	45494c43 	.word	0x45494c43
 8008f38:	4553544e 	.word	0x4553544e
 8008f3c:	52455652 	.word	0x52455652
 8008f40:	000000c0 	.word	0x000000c0
 8008f44:	4150493f 	.word	0x4150493f
 8008f48:	00000000 	.word	0x00000000
 8008f4c:	4150493d 	.word	0x4150493d
 8008f50:	00000000 	.word	0x00000000
 8008f54:	6e657645 	.word	0x6e657645
 8008f58:	69742074 	.word	0x69742074
 8008f5c:	0072656d 	.word	0x0072656d
 8008f60:	6d697443 	.word	0x6d697443
 8008f64:	70207265 	.word	0x70207265
 8008f68:	65636f72 	.word	0x65636f72
 8008f6c:	00007373 	.word	0x00007373
 8008f70:	203a7069 	.word	0x203a7069
 8008f74:	61766e69 	.word	0x61766e69
 8008f78:	2064696c 	.word	0x2064696c
 8008f7c:	73726576 	.word	0x73726576
 8008f80:	206e6f69 	.word	0x206e6f69
 8008f84:	6820726f 	.word	0x6820726f
 8008f88:	65646165 	.word	0x65646165
 8008f8c:	656c2072 	.word	0x656c2072
 8008f90:	6874676e 	.word	0x6874676e
 8008f94:	0000002e 	.word	0x0000002e
 8008f98:	203a7069 	.word	0x203a7069
 8008f9c:	6b636170 	.word	0x6b636170
 8008fa0:	73207465 	.word	0x73207465
 8008fa4:	74726f68 	.word	0x74726f68
 8008fa8:	74207265 	.word	0x74207265
 8008fac:	206e6168 	.word	0x206e6168
 8008fb0:	6f706572 	.word	0x6f706572
 8008fb4:	64657472 	.word	0x64657472
 8008fb8:	206e6920 	.word	0x206e6920
 8008fbc:	68205049 	.word	0x68205049
 8008fc0:	65646165 	.word	0x65646165
 8008fc4:	00002e72 	.word	0x00002e72
 8008fc8:	203a7069 	.word	0x203a7069
 8008fcc:	67617266 	.word	0x67617266
 8008fd0:	746e656d 	.word	0x746e656d
 8008fd4:	6f726420 	.word	0x6f726420
 8008fd8:	64657070 	.word	0x64657070
 8008fdc:	0000002e 	.word	0x0000002e
 8008fe0:	203a7069 	.word	0x203a7069
 8008fe4:	20646162 	.word	0x20646162
 8008fe8:	63656863 	.word	0x63656863
 8008fec:	6d75736b 	.word	0x6d75736b
 8008ff0:	0000002e 	.word	0x0000002e
 8008ff4:	203a7069 	.word	0x203a7069
 8008ff8:	7469656e 	.word	0x7469656e
 8008ffc:	20726568 	.word	0x20726568
 8009000:	20706374 	.word	0x20706374
 8009004:	20726f6e 	.word	0x20726f6e
 8009008:	706d6369 	.word	0x706d6369
 800900c:	0000002e 	.word	0x0000002e
 8009010:	706d6369 	.word	0x706d6369
 8009014:	6f6e203a 	.word	0x6f6e203a
 8009018:	63692074 	.word	0x63692074
 800901c:	6520706d 	.word	0x6520706d
 8009020:	2e6f6863 	.word	0x2e6f6863
 8009024:	00000000 	.word	0x00000000
 8009028:	3a706475 	.word	0x3a706475
 800902c:	64616220 	.word	0x64616220
 8009030:	65686320 	.word	0x65686320
 8009034:	75736b63 	.word	0x75736b63
 8009038:	00002e6d 	.word	0x00002e6d
 800903c:	3a706475 	.word	0x3a706475
 8009040:	72657a20 	.word	0x72657a20
 8009044:	6f70206f 	.word	0x6f70206f
 8009048:	002e7472 	.word	0x002e7472
 800904c:	3a706475 	.word	0x3a706475
 8009050:	206f6e20 	.word	0x206f6e20
 8009054:	6374616d 	.word	0x6374616d
 8009058:	676e6968 	.word	0x676e6968
 800905c:	6e6f6320 	.word	0x6e6f6320
 8009060:	7463656e 	.word	0x7463656e
 8009064:	206e6f69 	.word	0x206e6f69
 8009068:	6e756f66 	.word	0x6e756f66
 800906c:	00000064 	.word	0x00000064
 8009070:	3a706374 	.word	0x3a706374
 8009074:	64616220 	.word	0x64616220
 8009078:	65686320 	.word	0x65686320
 800907c:	75736b63 	.word	0x75736b63
 8009080:	00002e6d 	.word	0x00002e6d
 8009084:	3a706374 	.word	0x3a706374
 8009088:	72657a20 	.word	0x72657a20
 800908c:	6f70206f 	.word	0x6f70206f
 8009090:	002e7472 	.word	0x002e7472
 8009094:	3a706374 	.word	0x3a706374
 8009098:	756f6620 	.word	0x756f6620
 800909c:	6e20646e 	.word	0x6e20646e
 80090a0:	6e75206f 	.word	0x6e75206f
 80090a4:	64657375 	.word	0x64657375
 80090a8:	6e6f6320 	.word	0x6e6f6320
 80090ac:	7463656e 	.word	0x7463656e
 80090b0:	736e6f69 	.word	0x736e6f69
 80090b4:	0000002e 	.word	0x0000002e
 80090b8:	3a706374 	.word	0x3a706374
 80090bc:	746f6720 	.word	0x746f6720
 80090c0:	73657220 	.word	0x73657220
 80090c4:	202c7465 	.word	0x202c7465
 80090c8:	726f6261 	.word	0x726f6261
 80090cc:	676e6974 	.word	0x676e6974
 80090d0:	6e6f6320 	.word	0x6e6f6320
 80090d4:	7463656e 	.word	0x7463656e
 80090d8:	2e6e6f69 	.word	0x2e6e6f69
 80090dc:	00000000 	.word	0x00000000
 80090e0:	69706374 	.word	0x69706374
 80090e4:	756f5f70 	.word	0x756f5f70
 80090e8:	74757074 	.word	0x74757074
 80090ec:	7355203a 	.word	0x7355203a
 80090f0:	63742065 	.word	0x63742065
 80090f4:	5f706970 	.word	0x5f706970
 80090f8:	5f746573 	.word	0x5f746573
 80090fc:	7074756f 	.word	0x7074756f
 8009100:	75667475 	.word	0x75667475
 8009104:	2928636e 	.word	0x2928636e
 8009108:	206f7420 	.word	0x206f7420
 800910c:	20746573 	.word	0x20746573
 8009110:	6f206e61 	.word	0x6f206e61
 8009114:	75707475 	.word	0x75707475
 8009118:	75662074 	.word	0x75662074
 800911c:	6974636e 	.word	0x6974636e
 8009120:	00006e6f 	.word	0x00006e6f
 8009124:	2f504354 	.word	0x2f504354
 8009128:	73205049 	.word	0x73205049
 800912c:	6b636174 	.word	0x6b636174
 8009130:	00000000 	.word	0x00000000
 8009134:	66205049 	.word	0x66205049
 8009138:	6177726f 	.word	0x6177726f
 800913c:	6e696472 	.word	0x6e696472
 8009140:	00000067 	.word	0x00000067

08009144 <blanks.6648>:
 8009144:	20202020 20202020 20202020 20202020                     

08009154 <zeroes.6649>:
 8009154:	30303030 30303030 30303030 30303030     0000000000000000

08009164 <_ctype_>:
 8009164:	20202000 20202020 28282020 20282828     .         ((((( 
 8009174:	20202020 20202020 20202020 20202020                     
 8009184:	10108820 10101010 10101010 10101010      ...............
 8009194:	04040410 04040404 10040404 10101010     ................
 80091a4:	41411010 41414141 01010101 01010101     ..AAAAAA........
 80091b4:	01010101 01010101 01010101 10101010     ................
 80091c4:	42421010 42424242 02020202 02020202     ..BBBBBB........
 80091d4:	02020202 02020202 02020202 10101010     ................
 80091e4:	00000020 00000000 00000000 00000000      ...............
	...

08009268 <autostart_processes>:
 8009268:	20000448 20000438 00000000              H.. 8.. ....

08009274 <closed>:
 8009274:	534f4c43 00004445                       CLOSED..

0800927c <syn_rcvd>:
 800927c:	2d4e5953 44564352 00000000              SYN-RCVD....

08009288 <syn_sent>:
 8009288:	2d4e5953 544e4553 00000000              SYN-SENT....

08009294 <established>:
 8009294:	41545345 53494c42 00444548              ESTABLISHED.

080092a0 <fin_wait_1>:
 80092a0:	2d4e4946 54494157 0000312d              FIN-WAIT-1..

080092ac <fin_wait_2>:
 80092ac:	2d4e4946 54494157 0000322d              FIN-WAIT-2..

080092b8 <closing>:
 80092b8:	534f4c43 00474e49                       CLOSING.

080092c0 <time_wait>:
 80092c0:	454d4954 4941572d 00000054              TIME-WAIT...

080092cc <last_ack>:
 80092cc:	5453414c 4b43412d 00000000              LAST-ACK....

080092d8 <none>:
 80092d8:	454e4f4e 00000000                       NONE....

080092e0 <running>:
 80092e0:	4e4e5552 00474e49                       RUNNING.

080092e8 <called>:
 80092e8:	4c4c4143 00004445                       CALLED..

080092f0 <uip_broadcast_addr>:
 80092f0:	ffffffff                                ....

080092f4 <uip_all_zeroes_addr>:
 80092f4:	00000000 33323130 37363534 42413938     ....0123456789AB
 8009304:	46454443 32313000 36353433 61393837     CDEF.0123456789a
 8009314:	65646362 6e280066 296c6c75 00004300     bcdef.(null).C..

08009324 <_init>:
 8009324:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009326:	bf00      	nop
 8009328:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800932a:	bc08      	pop	{r3}
 800932c:	469e      	mov	lr, r3
 800932e:	4770      	bx	lr

08009330 <_fini>:
 8009330:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009332:	bf00      	nop
 8009334:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8009336:	bc08      	pop	{r3}
 8009338:	469e      	mov	lr, r3
 800933a:	4770      	bx	lr
